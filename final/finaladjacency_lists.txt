welcome to our 27th video with data
structures and algorithms we're going to
continue with graphs probably should
have done this one before the last two
videos but that's okay let's do it now
we're going to do a jason see lists and
adjacency matrices so we let's start off
with an adjacency list we're going to
kind of go in a different direction here
now this is what this is a
representation of our graph so let's do
some practice with converting this into
an adjacency matrix so firstly with the
adjacency matrix what we're going to
write a 1 if there's an edge between the
two right and we're going to write zeros
otherwise right so we're going to start
from a left right this will be the nodes
that are in the actual array here and
these will be its adjacency list this is
top the columns ok you'll see what I
mean in a second so for a in its
adjacency list we have C D and G so
along this row we are going to write
ones at C oh let's say at C D and G now
everything else is going to be zeroes
we're going to write in zeroes later so
that we can kind of visualize this a
little better let's keep going so with B
it has a jason Siletz with e all right
so E is in its adjacency list it's
connected to visit there's an edge from
B to e C has an edge right it has a
self-loop D also has a self-loop it also
has an edge from D to E and there's also
an edge from D to F with e U has an edge
to G all right has a direct path to G F
has a path to B right an edge between F
and B and another edge there's another
edge between G are from G to B ok so
that's kind of what our matrix
looks like now this is a directed graph
and we know that because this is not
symmetrical okay that means there's not
an edge you can see this is an edge from
A to C but there is not an edge from C
to a okay so this is this is a directed
graph so now let me just pick a
different color and we're going to put
in zeros okay for the rest of this just
to be a little bit more complete okay
that's a lot of zeros I know just hang
with me for a second
zero zero all these zeros fun times
there we go here we go zero zero zero
zero okay and there we go so that's what
our adjacency matrix looks like for this
graph now let's do a little something
else let's translate this into the graph
like a visual representation that we are
used to so I'm kind of running out of
space here so we're going to have to
kind of go back and forth that's okay so
let's start with node a so we have a
node a here let's put it like this okay
and we know that there's an edge from A
to C so I'm going to put C up here okay
there's that there's also an edge from A
to D so let's draw a D node and we'll do
an edge there and then another one to G
so we're going to put G down here okay
there we go that's our first one you did
the same looking at this right so
looking at this we're going to show
another one but we'll do it from this
side so let's do B from this side so B
has an edge there's an edge from B to e
right here so let's do that
so let's do be down here and there's
another ed right there's a edge from B
to e so we're going to put e right here
okay
make that a little better well that's
not better at all that's okay
so next one is C right C has a self loop
you can see that right here if you'd
like to look at this one instead right
there's a one at C C so there is a self
loop on C for D D has an edge from D to
D so this also has a self loop there's
an edge from D to e okay so let's do
that here I've horrible arrows all right
let's just clean that one up a bit it's
a little better and there's also an edge
from D to F so f is not on here so let's
draw our F node okay so there's that he
has an edge to G so let's scroll down so
we can make a little loop here so we
have a edge from E to G and from F we
have an edge to be you know what I'm
going to redraw this to come over here
and F has an edge to be there we go you
don't have to cross lines and then G
also has an edge to be able to go that
works out good stuff okay so there is
our graph right now let's do some more
exercise while we're here and let's do
on line just a second here let's grab my
color I'll have the right color I lost
it so let's do this
okay let's do depth-first search on this
depth-first search just for some
practice and let's start from here
actually we can signify starting with
just this one oh wow that was not right
so we start here right have one now
we're going to take this we're going to
do this in this order the order of our
list so C is going to be the first place
that we go all right so let's go along
see we've discovered this at time two
and now let's do C right C has a
self-loop so it's already been
discovered so we're done with this one
three now back to a right so the next
one in a is d now you can see that here
so let's go that path okay and time for
this was discovered so let's look at D
the first one D is a self-loop so that's
already been discovered already gray he
is the next one so let's take that path
so time five so e down here has a path
from E to G alright so let's take this
path and it's been discovered at times
six G has a path to be right it has an
edge from G to B so now B has been
discovered at time seven let's go up to
B let's take the path to e except E has
already been discovered so we're done
with this one so it's been discovered a
time eight back to G this is done at
time nine there's nothing left and it's
list back to e
there's nothing left in its list right
so that's done at time 10 back to D the
next one in these lists is f so let's
take a path over to F and this has been
discovered at time 11 so f has be right
in its
adjacency list bees already been
discovered so we're done with this one
at time 12 and that means that we are
done with D at time 13 and then we are
done with a because G has already been
discovered so we were done with this at
time 14 all right that was kind of fun
let's do breadth-first search on this on
the same one let's just redraw this
alright let's just get some practice in
might as well so we got C over here
we've got G we put F over here whoops
it's kind of messed up
but F over here B is down here and E is
over here so we've got this kind of
crazy lines here okay there's a path
here so path here here and here I think
that's all of them yep okay
and let's do breadth-first search over
here breadth-first search now we have a
queue remember so here's our Q first
it's empty we're going to start at a
alright start here its distance is zero
so we put a right in the queue we take a
out of the queue and we put its
adjacency list on all right
all the distance of one so we have C D
and G we take C off right see points to
itself so we have we don't put anything
else on the queue next we take D off and
we put E and F on right who comes
first he comes first in the adjacency
list so that's we're going to put on
first so we've got G E and F all right
these are distance of two so next we
take G off and we put B on here all
right so now our cue looks like this
e F B okay next in the queue is e so you
take a off G has already been discovered
so we don't put anything else on so I'm
going to write this over here so f and B
are now on the queue we take F off the
cube B has already been discovered it's
already in the queue so we don't put
anything in there right B we would put
we take B off the queue now that would
be e right except E has already been
discovered so we don't put anything on
the queue and there's no nodes left
that's we've gone through all the nodes
and that's it so there's our depth-first
search or breadth-first search and our
adjacency matrix in our adjacency list
so there you have it
Today we are going to start talking about
graphs. We are going to spend quite a lot
of time understanding the basic definition
in terminologies associated with graphs, see
some examples and then if time permits we
are going to do the graph abstract data type
or I think we will able to do the graph data
type today.
So question is what is a graph? So pictorially
this is what a graph is and what are terms
we are going to have. So graph is always represented
by a two tuple V and E typically, V's what
we will call the set of vertices and E will
call the set of edges. So set of vertices
and a set of edges together specify a graph.
In this picture these red circles are the
vertices. I have given each of these vertices
a name a b c d e to distinguish them and the
blue lines are the edges, so edge really is
a pair of vertices. An edge is a pair of vertices
or an edge is specified by giving a pair of
vertices so this edge is said to connect what
is u and v or will not use the term connect
but this edge is an edge between u and v;
when I say e = u v is an edge then that means
it's an edge between vertices u and vertex
v, vertices u and v.
So for instance in this example this graph
could be specified either by giving this drawing
or giving these this detail. As in v the set
of vertices is 5 vertices a b c d e and what
are the edges I have? Each edge as you can
see is a pair of vertices, an unordered pair
of vertices here, a comma b is the same as
b comma a. All that specifies is it is an
edge between vertices a and b. So a comma
b, a comma c is this edge; a comma d is this
edge, b comma e is this, c comma d is that,
c comma e is this and d comma e is this. So
there are 1, 2, 3, 4, 5, 6, 7 edges and there
are the 7 pairs mentioned here. So set of
vertices and a set of edges. What are they
used for? They are for lots and lot of applications,
you can model circuits as graphs, each of
component of the circuit could be a vertex.
So this could be a vertex, this could be a
vertex, this could be a vertex, this could
be a vertex, this is a vertex which is your
CS201, you are trying to find out the path
of these resistance to get CS201, they can
be used to model networks. So I can take the
map of the city and every intersection could
be modeled as a vertex and the roads which
are connecting to intersections could be modeled
as an edge and then that could be a graph
and then start asking various questions on
whether how can I go from this place to this
place by asking the corresponding question
on a graph. So transportation networks, lots
of this communication networks all of them
are modeled as graphs.
One more example. So this is typically student
day so you wake up, you mediate first 201
then you eat, may be you work then more CS201,
play CS201 programming sleep and you dream
of CS201 cycles. so idealistic There is no
room for any other course. This is the day
before mine. So this is slightly different
from the graph that I had shown in the previous
example. Why directed directed. So this is
what we call directed graph because we can't
do any meditation before you wake up. So there
is clearly an edge going from wake up to meditation.
So every edge has a direction associated with
it, we will call such graphs directed graphs.
So we also consider directed graphs but in
the rest of the lecture I am going to spend
most of time with undirected graphs. Whatever
things I define will carry over in a straight
forward way to directed graphs as well so
I will tell you what the difference is.
So to begin with let me go back to the previous
slide. In this example or in this definition
where would the difference be when I am talking
of a directed graph? So e comma u v is not
just a pair, it is an ordered pair let's say.
So the ordering is important, the first vertex
typically specify what the start of the edges
is or the origin of the edge and the other
would specify the destination of the edge
where the edge is going from, so what is the
start and what is the end.
So as I said today is a fairly simple lecture,
we are going to look at lots of terminologies.
So now you have understood what a graph is.
So there are two kinds of graphs a directed
graph and an undirected graph. So graph which
is not directed is called undirected graph
and you understand what a vertex is, what
vertices are, what edges are. Adjacent vertices,
so two vertices so this is all terminologies
associated with an undirected graph so two
vertices which are connected by an edge are
called adjacent. Is this vertex and this vertex,
these two vertices are they adjacent? No,
they are not connected by an edge while this
and this are adjacent and this and this are
not adjacent either. So what is it which are
connected by an edge are called vertices,
the degree of a vertex.
The degree of the vertex is the number of
adjacent vertices it has. So what is the degree
of this vertex? 3. So in fact I have written
down the degrees of the various vertices on
these so this vertex is degree is 2, this
vertex is degree 3, this is degree 3, this
is degree 3, everyone understands the degree
of the vertex. It is the number of adjacent
vertices. Sometimes we say that this edge
is incident to these two vertices. Should
I write down the word? So this edge, let's
say this vertex is vertex a and vertex b and
this edge is e, so e equals a b is incident
to vertices a and b. So this edge is incident
to these two vertices similarly this edge
is incident into this vertex as well as this
vertex. So degree of a vertex can also be
defined as the number of edges which are incident
to that vertex. There are three edges which
are incident to this vertex, so the degree
of this vertex is 3. These are equivalent
ways of saying the same thing. So question
is what is the sum of the degrees of all the
vertices, twice the number of edges. Because
when I am counting, so let's think of it in
the following manner. So the answer is right,
twice the number of edges and the argument
is actually half a line of an argument.
So pictorially I would say the following;
when I am counting three for this, I am counting
three because I am counting this one edge,
this edge and this edge. So let me put 3 stones,
one on each of these three edges then when
I am counting 3 here I am counting this edge,
this edge let me put down 3 stones. Then here
I am putting down 2 stones, here I am putting
down 3 stones, here I am putting down 3 stones.
So I have to put as many stones or pebbles,
if you want as many peppules as the sum of
the degrees of the vertices. Now if I look
at any edge, how many pebbles are there on
that edge? Exactly 2, so the sum of the degrees
of the vertices equals two times the number
of edges. So that's degree and you understand
what degree is, you understand what adjacent
vertices are. Now let's define the notion
of a path.
So a path in a graph is a sequence of vertices
let's say V1, V2, Vk such that consecutive
vertices have an edge between them. So if
I take vertex Vi and Vi+1 then these two vertices
are adjacent there is an edge between this
vertices. So there are two examples here.
So this is my graph, the same graph as before
recall that there is an edge between c and
e also. So this is the path a b e d c e. Why
is this a path? Because there is an edge between
a and b, there is an edge between b and e,
there is an edge between e and d, between
d and c and c and e, so this is a path. Similarly
this is the path b e d c because there is
an edge between b and e, between d and e,
between d and c.
it is easy to construct examples which are
not paths.
Suppose I had written down a b c, a b c is
not a path in this graph. Why because while
there is an edge from a to b there is no edge
from b to c, so everyone understands what
a path is. A simple path is a path in which
no vertex is repeated so this is an example
of a simple path b e c.
These three vertices are all distinct so it
is a simple path. A cycle is a simple path
in which the first and the last vertices are
the same. So a c d a is a cycle, d a c d is
the same cycle, c d a c is also a same cycle.
So you can read the cycle anywhere, this is
a cycle this is a simple path. In the previous
slide we had an example of a path which is
not simple. This is not a simple path. Why,
this is not a simple path because vertex e
is repeated here.
So this is a simple path except that the first
and the last vertices are the same. That's
what a cycle is. A graph is said to be connected
if there is a path between every pair of vertices
in the graph, that the graph is connected.
Is 
this graph connected? yes, the path path.
So this graph is connected, this is not connected
there is no path from here to here, so this
is connected this second one is not connected
and this is the common mistake connected there
should be a path between every pair of vertices.
If there is a path then it is connected, if
there is no path it's not connected. So these
two vertices so again this is the common mistake
when you are writing a minus especially you
are going to say these two vertices are not
connected because you don't see an edge between
them that's wrong terminology. These two vertices
do not have an edge between them but they
are connected because there is a path between
these two vertices. So we say two vertices
are connected if there is a path between them
and a graph is connected if there is a path
between every pair of vertices. Is this clear
to everyone? Let's understand the notion of
a sub graph, so this is a graph on the left
hand side suppose I take a subset of the vertices
and of the edges such that the resulting thing
is also a graph.
So I took some vertices from here, this vertex
you can see it's corresponding. I took 1,
2, 3, 4, 5, 6, 7, 8, 9, 10, 11 vertices from
here. There are 13 vertices in here I took
11 of them and I took some of the edges between
these vertices. I am not taken all the edges,
as you can see this edges is not here, this
would be called a sub graph of this graph.
I cannot takes this edge because the other
point of this edge is not there, I have not
included here at all. For an edge, the two
vertices between which the edge is running
are also called the end points of that edge.
Each edge has two end points and those are
the two end points so this is called the sub
graph of this graph.
Now let's understand what a connected component
is. A connected component is a maximal connected
graph. Suppose this is one graph, it is not
3 graphs I have drawn just one graph in. This
is not a connected graph. Is this connected?
this is not connected
this is not a connected graph. Why, because
there is no path from here to here. This is
not connected because there is no path from
here to here, there is no path from here to
here, so it is not a connected graph. If I
look at this sub graph it is connected just
this sub graph. These three vertices and these
three edges it's connected.
These 4 vertices and these 3 edges are also
connected, these 5 vertices and the 7 edges
on them are also connected. These 3 are the
connected components of this graph. Now what's
the definition of connect? It's a maximal
connected sub graph. What does a maximal connected
sub graph mean? This needs to be understood
more carefully. Suppose I were to take this
vertex and this vertex and I were to take
this edge and this edge. This is a sub graph,
yes or no? This is a sub graph of the original
graph but this is not a connected component,
I am not going to call this a connected component.
Why? Because it is not maximal so what does
maximal mean? So when we say maximal in this
class, we mean a set is called maximal if
we cannot increase the size of the set while
retaining the property. So a set is said to
be maximal with respect to a certain property.
If we cannot add more elements to the set
and retain the property that's not true here
I can add more elements to this set, I can
add more edges or I can add more vertices
and both. So I can add this edge and it is
still connected I can this vertex and this
edge and it is still connected, I can add
this vertex and this edge and it is still
connected, I can add this edge now it is still
connected, I can add this edge now it is still
connected. Now if I add any other vertex or
any other edge, suppose I decided to add this
vertex, I add this but it is not connected
anymore. So this is a maximal connected sub
graph and so we will call this a connected
componenent so this entire thing is the connected
component. This is also a connected component
and this is also a connected component. I
cannot add any other vertices and still have
the property of it being connected.
So essentially intuitively how do you think
of connected component? You just see which
are the pieces which are connected among each
other, each of them is a connected component
as simple as that. So this graph is 3 connected
components. More terminologies; what is a
forest? Forest is a jungle, jungle is a collection
of trees and animals but we will leave out
the animals. So we are thinking of forest
as a collection of trees so these are trees
in the forest now what is a tree here.
A tree here is a connected graph which does
not have any cycles in it. It's the same as
the tree that we till now except the. So
this is an example of the tree it is a connected
sub graph as we can see and it does not have
any cycle in it. This is also a tree, this
is also a tree, this is also a tree when you
have collection of trees it is a forest. So
forest is a collection of trees so everyone
understands this. What a trees? Tree is a
connected sub graph which does not have any
cycle in it. So I am typically going to use
n to denote the number of vertices and m to
denote the number of edges in any graph. So
what is the complete graph? A complete graph
is one in which there is an edge between every
pair of vertices, between every pair of vertices
there is an edge. This is an example of a
complete graph.
This is a graph on 5 vertices between every
pair of vertices there is an edge. So how
many edges does a complete graph have? nc2,
because there are n22 pairs of vertices and
there is an edge between every pair and so
you will have so many edges. How many edges
does a complete directed graph have? three
by two two two times nc2 a directed and a
complete. So basically there will have to
be and edge in both directions right so it
will become twice. If a graph is not complete
then the number of edges going to be strictly
less than n chose two. So in an undirected
graph this is the maximum number of edges
that a graph can have, n chose two.
Suppose I give you a graph on n vertices,
zero, it might not have any edge at all. So
the minimum number of edges in a graph on
n vertices is zero and the maximum number
of edges is n chose two. So once again we
have n number of vertices, m number of edges.
minimum elements connected in graph. That's
the slide, suppose in a tree so what is a
tree? Recall a tree is the connected graph
which does not have any cycle in it. How many
edges are there in a tree? I have said number
of edges in the tree is n -- 1, why? every
pair of start from a node and we end and we
cannot have a like a cycle so starting So
we can have about one two one two two three
after and the number of edges these vertices
two] each vertex is degree two. In a tree
every vertex is degree two, no. nodes we write
a so that will be n minus one you can't have
repetition sir we get we can count the edges
by, we will take the direction so the edge
coming to a node is one.
What do you mean coming to a node? So is this
edge coming into this node or this edge coming
into this node? sir we take this as even starting
from if you start from any particular node
you don't have whether number of node have
to have a Let's prove this. it is a true statement
so let's prove that so what will be the proof?
We have to prove that a tree on n vertices
has n - 1 edges, induction as simple as that.
So proof by induction, so what should be the
base case? Let's say n equals two so suppose
I have a connected graph on two vertices statement
is true. So number of edges equals n - 1 equals
one. So induction hypothesis statement true
for all n less than or equal to k let's say.
So now the induction step. So given a graph
on k + 1 vertices. Why should this have k
edges? one leaf good. So he is saying something
useful, he is saying there is no cycle in
the graph. We have to use somewhere the fact
there is no cycle in
the graph. He says that there has to be one
leaf degree one good. So let's define a leaf,
now as a vertex, a leaf is a vertex of degree
one. So his claim is that
given a tree on k + 1 vertices. We are given
a tree, we are proving this. The tree or every
tree has a leaf so maybe we come back to one
of the vertices we have already visited so
it is not a tree because that was a leaf.
there should be part of the path relating
these vertices exactly this edge cannot be
part of any simple path between any two vertices
because this edge cannot be part of any simple
path and so even after I remove this edge
and this vertex this there is a path between
every pair of vertices. So this is still connected,
this is connected and by removing an edge
and a vertex I cannot create a cycle. I can
apply my induction hypothesis on it so we
have removed only one vertex. So this is a
tree on k vertices and has k - 1 edges, this
is by induction hypothesis and so we prove
that.
You have to use the fact, both the facts are
critical that it is a connected graph and
it does not have a cycle in it. Otherwise
you will not be able to argue that it has
k - 1 edges. That's the proof for this, everyone
follows this. Most text books would have this
proof also, you can also go back and and look
at one of the text. So if the number of edges
is less than n - 1 in a graph then the graph
cannot be connected at all. Why? This statement,
if the number of edges is less than n - 1
then the graph is not connected proof by contradiction.
Suppose if it is connected then so let's follow
this argument. So suppose it is connected,
if it is connected then why is it not a tree?
It is not a tree because it has a cycle. So
let's take lets remove an edge from the cycle
I should have switched but okay so what what
are we trying to argue? If number of edges
is less than n - 1 then G is not connected.
So this is another useful thing to remember
that suppose I have a cycle, G is a graph.
Suppose I have a graph in which there is a
cycle if you have a cycle and if you remove
any edge from the cycle you cannot make the
graph disconnected by doing that.
So what is the argument that to prove this
claim? If suppose I have a graph on less than
n - 1 on less than n - 1 which is connected.
Why it is not a tree? It is not a tree because
there is a cycle in let me remove an edge
from the cycle I only reduce the number of
edges and it's still connected. If there is
another cycle let me still remove another
edge so I will only get less than n - 1 edges
and the graph will remain connected eventually
I will get a tree after removing all of this.
So I am contradicting the earlier claim which
says that any tree has to have exactly n - 1
edges in it.
It cannot have less than n - 1 edges so any
graph which has less than n -1 edges cannot
be connected. Is there something that is not
clear? So couple of examples n =5, m=4 this
is a tree on 5 vertices.
It has to have four edges, this is a graph
on 5 vertices and 3 edges and it cannot be
a tree, it cannot be a connected graph at
all. Let me ask you a question suppose I have
graph on n vertices and it has n - k edges
n - k edges. How many connected components
do you think it has? I have a graph on n vertices
and n - k edges, how many connected components
it has? k or more, k when there would be no
cycle and if there were cycles then it could
have more number of connected components,
try to prove this. This is a very simple exercise.
So a given a graph on n vertices and n - k
edges how many connected components does it
have? So more terms; a spanning tree is a
sub graph which means you are given a graph
so it is a sub graph of a graph and this sub
graph has to be a tree and it should include
all the vertices of the graph.
So spanning tree tree which means the sub
graph has to be a tree and it should include
everything; include everything here means
include all the vertices. So as you can see
this sub graph includes all the 4 3 7 and
3 10 13 vertices that are there and it is
a tree. There is no cycle here so this is
the spanning tree of this graph, this is the
graph and this is the spanning tree of this
graph. G has to be connected if G is not connected
then there is no notion of the spanning tree.
If G is not connected then no sub graph of
the graph of G cannot be a spanning tree.
So this is a useful thing to have, quite often
your network could be a just spanning tree.
Suppose these are points I want to connect
so these are cities, these are possible roads
that I can build but I just want to put the
minimum amount of effort, I want to build
has few roads as possible so that all these
cities are still connected so I could built
a spanning tree but this does not provide
you any fault tolerance what does that mean
you cannot reach from some city to some other
city now. As you can see if I cut of this
link then these 4 vertices would be disconnected
from the other 8 vertices these 6 vertices
would be disconnected from the other 7. Spanning
tree is a useful but they provide don't provide
much fault tolerance.
Let's talk about bridges. Koenigsberg, this
is a city in Germany or Austria I don't remember
where. So pragal river okay I don't remember
where this is. This city has this nice thing,
there is a river flowing through the city
and there is an island in the river and there
are bridges in this manner so A is this island
and there is a bridge from here to here, here
so there are 7 bridges in all. This black
bar are the edges so question is can you start
from here let's say or any point. So can one
across each bridge exactly once and return
to the starting point. Why no, so suppose
I start from here I can take this bridge go
here it will land up and you can go on land
up so on and see.
Let's see whether we can solve this problem
or not? Suppose this would have been useful
if you were a postmen who had to visit the
various brides and you did not want to retrace
the steps. So this is also known as koenigsberg
problem and Euler proved that this is not
a problem and we will give a simple proof
for that one. So we can model this thing as
a graph, there is this island A so these are
the going to be the vertices of my graph.
This island A this is one piece of land and
there is this part B because I can go from
anywhere to here. This is one vertex, there
is a vertex D and there is a vertex C which
is this part. So I will have a graph with
4 vertices in it A B C D and then depending
upon so since there is a bridge from B to
A.
In fact there are two bridges from B to A
so I will put two edges between B and A. similarly
there are two bridges between A and C so I
will put two edges between A and C. There
is one bridge from A to D so I will put one
edge between A and D, there is an bridge between
D and B so I will put one edge between B and
D and an edge between C and B so I will get.
This is not a graph. Why is this not a graph?
Because we did not define a notion of two
edges between pair of vertices, we just talked
about pair of vertices. The edges don't form
a set, they form a multi set so this is called
multi graph.
What is a multi-graph? In which they put the
many edges between a pair of vertices is called
a multi graph but this captures that problem
in certain sets. So eulerian tour is a path
that traverse every edge exactly once and
returns to the first vertex and that's exactly
what we want to do. Because these are the
bridges so we want to traverse each bridge
exactly once and return to the starting vertex.
Can you do that on this graph? So same problem
can now be thought of here, can is start from
A and come back to A and and visit each or
traverse each exactly once. So the same question
a same, can you draw this picture without
lifting your pencil or redrawing an edge,
you know coming back over a line twice.
So Euler theorem says that you can do this
if and only if every vertex has even degree.
When you come to a vertex, you come by one
edge and then you have to go by another edge
and if you come again then you will need another
edge to or fresh edge to go off by so every
vertex has to have an even degree for this
to work but here there are all vertices of
odd degrees so clearly this cannot be done.
Now let's quickly do the uninteresting part,
the abstract data type. The graph can be thought
of as a container of positions. So you have
the regular methods for any positional container
like queues and stacks. We always had this
methods called size and Is Empty and elements;
elements would return all the vertices and
the edges that's in and you can have some
methods like swap which can swap two positions
replaceElement those kind of thing, these
are methods associated with the regular positional
container swap is the generic method for any
positional container. When you are saying
that provide two positions and swap the contents
at those two positions that's the swap method.
So here I am not saying it specifically to
the graph abstract data type, you will have
to think of what it would mean. So you could
decide what it means here for this particular
data type but I am saying it is a generic
methods. These are all generic methods for
positional container and I am just saying
in that context. So here I have methods which
are specific to graphs so numVertices would
be a method which returns number of vertices
numEdges number of edges vertices would know
be an enumeration of all the vertices.
So it would be a method returns an iterator
which will let you iterate through the various
vertices of the graph, edges could be a method
which returns all the edges. DirectedEdges
would be a method if you had a directed graph,
it would return all the enumerated all the
directed edges in the graph. What does enumerator
do and an iterator? It basically returns an
object which has two methods associated with
it, one method is next and the other method
is whether there is anything left, has next
whether there is a next method next element
at all or not.
So as you every time you call next it gives
you a next object in the enumeration so when
you are enumerating edges I call next once
it will give me one edge, when I call next
again it will give me another edge. What order
this edge is come in that you typically do
not know. It depends upon how you implemented
the iterator. UndirectedEdges could similarly
enumerate all the undirected edges incident
Edges, if I specify a vertex it would enumerate
all the edges incident at that vertex. This
is for an undirected graph incident Edges;
for a directed graph right there are two kinds
of edges either there would be edges which
start from this vertex or there would be vertex
which end at this vertex. So it could have
a notion of any incident edges which are edges
entering a vertexV which are ending at vertex
V and 
you could have an out incident edges which
are edges which are starting from vertex V
going out of vertex, opposite. so I specify
an edge e, all of these are objects an edge
is also an object and I specify one end point
on the edge so this method gives me the other
end point of that edge.
Degree gives me the degree of the vertex,
inDegree so degree would be for an undirected
graph, for a directed graph there would be
the notion of in degree and an outdegree.
Indegree would be n number of edges coming
into the vertex outDegree would be the number
of edges leaving the vertex. Similarly I could
have adjacent vertices, adjacent vertices
would be a method which will turns an iterator
over all the vertices which are adjacent to
this particular vertex. This would be for
the undirected graph, for a directed graph
you could similarly have a notion of inAdjacent
and an outAdjacentVertices. Then you could
have a method areAdjacent whether vertices
two vertices v and w are adjacent or not.
So this would be return a Boolean value; endVertices
given an edge it will return the two end points
of that edge.
Origin, for a directed edge e it would return
where the edge is starting from, destination
for a directed edge e it would return where
the edge is ending. Given an edge e it will
tell whether it is directed or not. This method
would be useful when you have, what are called
mixed graphs, mixed graphs some edges are
directed and some are undirected. Can you
give me a setting where it would be useful
to have a
mixed graph, what 
kind of
a problem setting can you imagine there?
It would be natural to have a roads roads,
traffic network once again where you have
some roads are one ways. So you are bi directed
edges, roads which are two way could be undirected
edges and roads which are only one way could
be directed edges. There such a methods could
be useful because given an edge you can then
determine whether it is a directed edge or
an undirected edge. I will just take, I guess
this is last slide yes it is.
Make Undirected e, so you are given edge and
you set it to be an undirected edge. You can
have a method which reverses the direction
so you can have tonnes and tonnes of update
method also. You can have methods to create
the graph, change remove an edge, remove a
vertex do whatever you want. So set direction
from, so you can set the direction of an edge
suitably we just look through this these slides
that I have given. So this is just a subset
of method depending upon what application
you have, you could design your own set of
methods.
So graph can be thought of as data type, is
an abstract datatype on which you can have
a bunch of methods which you can use to update
and modify the data type. So with that we
will end our discussion on graphs we will
continue in next class however to see how
to actually represent a graph what kind of
data structures can you use to represent graphs.
hello everyone in our previous lessons
we introduced you to graphs and we also
looked at and talked about some of the
properties of graph but so far we have
not discussed how we can implement graph
how we can create a logical structure
like graph in computer's memory so let
us try to discuss this a graph as we
know contains a set of vertices and a
set of edges and this is how we define
graph in pure mathematical terms a graph
G is defined as an ordered pair of a set
V of vertices and a set of edges now to
create and store a graph in computer's
memory the simplest thing that we
probably can do is that we can create
two lists one to store all the vertices
and another to store all the edges for a
list we can use an array of appropriate
size or we can use an implementation of
a dynamic list in fact we can use a
dynamic list available to us in language
libraries something like vector in C++
or ArrayList in Java now a vertex is
identified by its name so the first list
the list of vertices would simply be a
list of names or strings I just filled
in names of all the vertices for this
example graph here now what should we
fill in this edge list here an edge is
identified by its two endpoints so what
we can do is we can create an edge as an
object with two fields we can define
edge as a structure or class with two
fields one to store the start vertex and
another to store the end vertex edge
list would basically be an array or list
of this type struct edge in these two
definitions of edge that I have written
here in the first one I have used
character pointers because in C we
typically use character pointers to
store or refer to strings we could use
character array
also in C++ or Java where we can create
classes we have string available to us
as a datatype so we can use tattles so
we can use any of these for the fields
we can use character pointer or
character array or string datatype if
it's available depends on how you want
to design your implementation now let's
fill this edge list here for this
example graph each row now here has two
boxes let's say the first one is to
store the start vertex and the second
one is to store the end vertex the graph
that we have here is an undirected graph
so any vertex can be called start vertex
and any vertex can be called end vertex
order of the vertices is not important
here we have 9 edges here 1 between a
and B another between a and C another
between a and D and then we have B E and
B F instead of having B F as an entry we
could also have F B but we just need one
of them and then we have CG D H E H and
F H actually there's one more we also
have G H we have 10 edges in total here
and not 9 now once again because this is
an undirected graph if we are saying
that there is an edge from F to H we are
also saying that there is an edge from H
to F there is no need to have another
entry as HF we will unnecessarily be
using extra memory if this was a
directed graph F H and H F would have
meant two different connections which is
the start vertex and which is the end
vertex would have mattered maybe in case
of undirected graphs we should name the
fields as first vertex and second vertex
and in case of directed graphs we should
name the fields as start vertex and end
vertex now our graph here could also be
a weighted graph we could have some cost
or weight associated with the edges as
you know in an unweighted graph
cost of all the connections is equal but
in a weighted craft different
connections would have different weight
or different cost now in this example
graph here I have associated some
weights to these edges now how do you
think we should store this data the
weight of edges well if the graph is
weighted we can have one more field in
the edge object to store the weight now
when entering my edge list has three
fields one to store the start vertex one
to store the end vertex and one more to
store the weight so this is one possible
way of storing the graph we can simply
create two lists one to store the
vertices and another to store the edges
but this is not very efficient for any
possible way of storing and organizing
data we must also see its cost and when
we say cost we mean two things time cost
of various operations and the memory
usage typically we measure the rate of
growth of time taken with size of input
or data what we also call time
complexity and we measure the rate of
growth of memory consumed with size of
input or data what we also call space
complexity time and space complexities
are most commonly expressed in terms of
what we call Big O notation for this
lesson I am assuming that you already
know about time and space complexity
analysis and Big O notation if you want
to revise some of these concepts then
you can check the description of this
video for link to some lessons we always
want to minimize the time cost of most
frequently performed operations and we
always want to make sure that we do not
consume unreasonably high memory okay so
let's now analyze this particular
structure that we are trying to use to
store our graph let's first discuss the
memory usage for the first list the
vertex list least number of rows needed
or consumed would be equal to number of
vertices now each row here in this water
list is a name or string and string can
be of any length right now all strings
have just one character because I simply
named the nodes a B C and so on but we
could have names with multiple
characters and because strings can be of
different lengths all rows may not be
consuming the same amount of memory like
here Here I am showing an intra-city
road network as a weighted graph cities
are my nodes and Road distances are my
weights now for this graph as you can
see names are of different lengths so
all rows in vertex list are all rows in
edge list would not cost the same more
characters will cost us more bytes but
we can safely assume that the names will
not be too long we can safely assume
that in almost all practical scenarios
average length of strings will be a
really small value if we assume it to be
always lesser than some constant then
the total space consumed in this vertex
list will be proportional to the number
of rows consumed that is the number of
vertices or in other words we can say
that space complexity here is Big O of
number of vertices this is how we write
number of vertices with two vertical
bars what we basically mean here is
number of elements in set V now for the
edge list once again we are storing
strings in first two fields of the edged
object so once again each row here will
not consume same amount of memory but if
we are just storing the reference or
pointer to a string like here in the
first row instead of having values
filled in these two fields we could have
references or pointers to the names in
the vertex list if we will design things
like this each row will consume same
memory this in fact is better because
references in most cases would cost us a
lot lesser than a copy of the name and
as reference we can have the actual
address of the string and that's what we
are doing when you are saying that start
and end vertex can be character pointers
or maybe a better design would be simply
having the index of the name word string
in vertex list let's say a is at index
zero in the vertex list and B is at
index 1 and C is at index 2 and I'll go
on like this now for start what X hand
end vertex we can have two integer
fields as you can see in both my
definitions of edge start vertex and end
vertex are of type int now and in each
row of edge list first and second field
are filled with integer values I have
filled in appropriate values of indices
this definitely is a better design and
if you can see now each row in edge list
would cost us the same amount of memory
so overall space consumed in edge list
would be proportional to number of edges
or in other words space complexity here
is Big O of number of edges okay so this
is analysis of our memory usage overall
space complexity of this design would be
Big O of number of vertices plus number
of edges is this memory usage
unreasonably high well we cannot do a
lot better than this if we want to store
a graph in computer's memory so we are
alright in terms of memory usage
now let's discuss time cost of
operations what do you think can be most
frequently performed operations while
working with graph one of the most
frequently performed operations while
working with graph would be finding all
nodes adjacent to a given node that is
finding all nodes directly connected to
a given node what do you think would be
time cost of finding all nodes directly
connected to a given node well we will
have to scan the whole edge list we will
have to perform a linear search we will
have to go through all the entries in
the list and see if the start or end
node in the entry is our given node for
a directed graph we would see
if the start node in the entry is our
given node or not and for an undirected
graph we would see both the start as
well as the end node running time would
be proportional to number of edges or in
other words time complexity of this
operation would be Big O of number of
edges okay now another frequently
performed operation can be finding if
two given nodes are connected or not in
this case also we will have to perform a
linear search on the edge list in worst
case we will have to look at all the
entries in the edge list so worst-case
running time would be proportional to
number of edges so for this operation to
time complexity is Big O of number of
edges now let's try to see how good or
bad this running time Big O of number of
edges is if you remember this discussion
from our previous lesson in a simple
graph in a graph with no self loop or
multi edge if number of vertices that is
the number of elements in set V is equal
to n then maximum number of edges would
be n into n minus 1 if the graph is
directed each node will be connected to
every other node and of course minimum
number of edges can be 0 we can have a
graph with no edge maximum number of
edges would be n into n minus 1 by 2 if
the graph is undirected but all in all
if you can see number of edges can go
almost up to square of number of
vertices number of edges can be of the
order of square of number of vertices
let's denote number of vertices here as
small V so number of edges can be of the
order of v square in a graph typically
any operation running in order of number
of edges would be considered very costly
we try to keep things in order of number
of vertices when we are comparing the
two running times this is very obvious
Big O of V is a lot better than Big O of
v square
all in all this what X list and edge
list kind of representation is not very
efficient in terms of time cost of
operations we should think of some other
efficient design we should think of
something better we will talk about
another possible way of storing and
representing graph in next lesson this
is it for this lesson thanks for
watching
okay so let me tell you just for fun
it's an example this pocket cube which
is 2 by 2 by 2 your rubik's cube what we
have in mind is it's called the
configuration graph or sometimes the
configuration space but it's a graph so
this graph has a vertex for each
possible state of the cube so this is a
state creaky here this is a state this
is a state this is a state now I'm
hopelessly lost
ok anyone want to work on this board
no one all right leave it I'm solving ok
so all those are vertices there's
actually a lot of vertices there are 264
million vertices or so if you want as an
aside here number vertices is something
like 8 factorial times 3 to the eighth
and one way to see that draw to bethe
veggie rubik's cube so these are these
guys are yeah these are what you might
call cubelets or cubies i think is
standard term in rubik's cube land and
so the there's eight of them and a 2 by
2 by 2 2 cubed you can essentially
permute those cubies within the cube
however you like that's 8 factorial and
then each of them has three possible
twists it could be like this it could be
like this or it could be like this ok so
you've got three for each and this is
actually an accurate count you're not
over
counting the number of configurations
all of those are at least in principle
conceivable if you take apart the cube
you can reassemble it in each of those
states and that number is about 264
million okay which is not so bad for
computers you could search that life is
a little bit easier you get two divided
by 24 because there's 24 symmetries of
the cube 8 times 3 you can divide by 3
also because only 1/3 of the
configuration space is actually
reachable if you're not allowed to take
the parts apart you have to get there by
emotion you can only get to 1/3 of the
two 2 by 2 by 2 so it's a little bit
smaller than that if you're actually
doing a breadth-first search which is
what you're going to be doing on your
problem set but in any case it's
feasible
okay that is vertices should talk about
edges for every move every move takes
you from one configuration to another
you could traverse it in one direction
I'll make that move you could also undo
that move because every move is undoable
in a rubik's cube this graph is
undirected or you can think of it as
every edge works in both directions so
so this is a move is called a quarter
twist some it's a controversy if you
will some people allow a whole half
twist as a single move whether you
define that as a single move or a double
move not that big a deal just changes
some of the answers but you're still
exploring essentially the same graph
so that's the graph and you'd like to
know some properties about it so let me
draw a picture of the graph I'm not
going to draw all 264 million vertices
but in particular there's the solved
state we kind of care about that one
where all the colors are aligned then
there's all of the configurations you
could reach by one move so these are the
possible moves from solve state and then
from those configurations there's more
places you can go
maybe there's multiple ways to get to
the same node
okay but these would be all of the
configurations you can reach in two
moves okay and so on and at some point
you run out of graph so there might be
some ways to get there might be a few
things
she knows out here these are kind of the
way I'm drawing this this is everything
you can reach in one move and two moves
and three moves at the end this would be
11 moves if you if you allow half twists
and I guess as puzzlers we're
particularly interested in this number
which you would call as a graph theorist
the diameter of the graph puzzlers call
it God's number if you were God or some
me something being you have the optimal
algorithm for solving the Rubik's Cube
how many moves do do you need if you
always follow the best path and the
answer is in the worst case 11 so we're
interested in the worst case of the best
algorithm for 2 by 2 by 2 the answer is
11 for 3 by 3 by 3 the answer is 20 that
was just proved last summer with a
couple years of computer time for a 4 by
4 by 4 I don't have one here I think
we'll never know the answer for 5 by 5
by 5 we'll never know the answer for 6 4
same deal but for 2 by 2 by 2 you can
you will compute it on your problem set
and it's kind of nice to know because it
says whatever configuration I'm in I can
solve it in 11 moves but the best known
way to compute it is basically to
construct this graph one layer at a time
until you're done and then you know what
the diameter is the trouble is in
between here this grows exponentially at
some point it decreases a little bit but
getting over that exponential hump is
really hard
hey you you green be targeted again
to weigh finally
it presents all the material list
wanted to send everyone at linkliste
full text lowered she wanted the
is president inside the mold to left
so this was about enemies finally
as well as a video tv video hifi if
wc as you remain a when it finally
anger is linkliste it is a target
it not that
these details would be ex boyfriend max
finally so many politicians on
pointer sisters anyway remains a
Hague's very strong in me is totally
number of notes and more than any
exot is a chain is left with 6 1
next thought and siris regulated how
at least as you may care not max
is not a theory
next is correction and 600 how to how
You wc still one of the not any other cases
visualize how such a cattle Triemli
Member of video wiki envy15 link
can they present
if it is useless as a presence in the form
is
is similar representation is not
not further
grabbed the front of electric nissan direct
I wanted the studio the sundaytimes
wants how well it
to 16
goal-it's the mavericks
she is fully present them to
graf think
hi I'm Jonah in this video I'm going to
explain two different ways to implement
a graph and then I'm going to explain
some of the pros and cons of each and
I'll show you how to implement both of
these methods in Python so the first way
to implement a graph is using an
adjacency list so let's look at this
undirected graph it has five vertices
and some edges connecting them an
adjacency list actually is a set of
adjacency lists because each list is
stored in its own vertex so a keeps its
own list of directly connected neighbors
other vertices that it has an edge to so
a has neighbors B C and E node B has
neighbors a and C as we can see here
this is going to be stored within each
node or each vertex is going to store
its own adjacency list now the other way
is using an adjacency matrix and the
adjacency matrix is a two dimensional
array and it basically stores a zero
where there is no edge or a one where
there is an edge from A to B we can see
there is an edge there or from A to C
there is an edge as you'd expect since
this is an undirected graph this is
going to be symmetrical across this
diagonal so from A to B is a 1 from B to
a is also going to be a 1 then the
adjacency matrix like I said it's a 2d
array and is stored in the graph object
so there's one adjacency matrix
centrally located in the graph object
how about if you have weighted edges on
an undirected graph well it's much
easier to implement weighted edges with
an adjacency matrix instead of putting a
one for edges where there is a
connection you just put the weight of
that edge so it's very easy to do that
you already have the cell you can put
instead of a 1 you can just put the
number of the cost or the distance or
weight of that edge in the cell so
extremely easy to implement using
adjacency matrix you can also implement
weighted edges in an adjacency list but
it's a little bit trickier so if you
have a directed graph again very easy to
do this using an adjacency list so here
we would have
a has one outbound edge to see so we
list under a only C as a neighbor that's
the only neighbor we can get to from a
so we're going to list all the outbound
edges for that vertex so C has edges to
B D and E and we list all the outbound
edges from C here in C's a Jason C list
you know Jason C matrix the same thing
we're basically going to put ones where
we have an edge outbound from that
vertex so we have the from on the left
and the two is div columns so which is
better well before we can answer that
question let's look at some other
characteristics of graphs a dense graph
is a graph where this is not absolute
value this is the number or count of
edges and the count of vertices so a
dense graph is a graph where you have
the number of edges is about equal to 2
the number vertices squared in other
words almost every vertex is connected
to every other vertex in the graph so
you get a really large number of edges
relative to the number of vertices a
sparse graph is a graph where E is about
equal to V which is what we have here in
this picture so there are a lot of
possible edges that are not actually
there another thing we're going to look
at before we answer the question which
is better adjacency matrix takes up V
squared space right this is a big factor
the amount of space required for this
adjacency matrix is going to be V
squared or number of vertices squared
regardless of how dense the graph is so
very very sparse graph you still are
going to take up the same amount of
space so for our little 5x5 you know we
only have 5 vertices in this example who
cares right but if you can picture a
graph that has ten thousand or a hundred
thousand vertices that's going to take a
project gigantic amount of storage space
so with those things in mind an
adjacency list is better in cases where
you have a sparse graph because it's
going to be faster and it uses less
space but the disadvantage of an
adjacency list this is slower for very
dense graphs large dense graphs is going
to be slower and the adjacency matrix is
going to be better for dense graphs
it's going to be faster and the space
complexity is the same as it would be
thrown on dense graph and another
advantage is that is simpler to
implement for weighted edges but the
disadvantage of this adjacency matrix is
that it uses more space and especially
for large sparse graphs or perhaps to
have a lot of vertices but relatively
few edges the adjacency matrix is not a
good choice so depending on the nature
of your graph you have to decide which
one of these is a better implementation
to go with so I'll give a quick
explanation of the adjacency list
version of the graph implementation
first we have our vertex class which
basically has two variables as a name
and it has a neighbors list and as we
add neighbors we see we have an add
neighbor function that basically is just
appending that vertex to the list and
then sorting it in the graph itself we
only have one graph variable which is a
dictionary of vertices so that we can
find any vertex by its name so when we
add a vertex we basically just check
that that object that you passed in
actually is a vertex object and then it
doesn't exist in the vertices dictionary
yet and if those two conditions are met
then it goes in as the vertex to the
vertices dictionary and when you try to
add an edge with vertices U and V then
it's first going to check if u and V are
both actually in this vertices
dictionary before adds it so if there's
an invalid vertex and it's not going to
be able to add that edge then we iterate
through the vertices and we locate
vertex U and vertex V and we add the
other to its neighbors and that's pretty
much it then I have a print graph
function down here at the bottom so this
is a pretty straightforward
implementation of graph I think it's a
little bit simpler so I usually favor
this over the matrix version although
the matrix version is not too hard and
then down below I have some test code
that we can test our our code up here so
implementing a graph using an adjacency
matrix this version is actually going to
support both weighted and unweighted
edges for undirected graphs and you have
to do slight modifications to support
directed graphs
so our vertex class you'll notice only
has one variable and that's just the
name of the vertex we don't need
adjacency this stored locally in the
vertex that doesn't happen here they're
stored centrally under the graph so we
have the same vertices dictionary so
that we can locate any vertex given its
name we also have this edges list which
is going to be our two-dimensional array
of edges that's the matrix and then we
have edge indices so that we can quickly
locate the index of any edge given its
name so when we add a vertex first we're
gonna check if it's actually vertex and
it is not in the vertices list already
and if not we add to the dictionary and
then our for loop here and the statement
right after that basically we need to
add another row and column of all zeros
to our edges matrix so we're going to do
that here we're add another row of zeros
and in another column of zeros on to
that edges matrix because we have mapped
any edges to this new vertex yet but we
need to add it to this matrix with all
zeros and lastly we add the index for
this vertex name into our edge indices
dictionary so to add an edge we're first
going to verify that both vertices U and
V are in our vertices dictionary and if
they both are then recall that this
edges matrix is symmetrical along the
diagonal so we want to add this edge we
want to enter the weight in the matrix
in both the top right bar in the bottom
left part so we're going to add the edge
to both u comma V and to V comma u we'll
set the edge weight and that's it for
add edge if we achieve that and we'll
return true and if not the return false
then lastly I have a pretty pretty
simple print graph function that prints
a pretty crudely formatted edges matrix
for us so you can see what that looks
like and our interface is exactly the
same as for the adjacency list version I
have exactly the same test code down
here below where we we set up a graph we
add some vertices and some edges to it
and we print it out I posted all of my
Python code here in my github site and
you can download that pin you also have
access to the PowerPoint file posted
here Omega up site so I hope this video
was helpful for you if you liked it
please click like and subscribe to my
channel I'm Joe James thanks for
watching
you're listening to coding box episode
28 subscribe to us and leave us a review
on iTunes stitcher and more using your
favorite podcast app and visit us at
coding buckstein net we can find show
notes examples discussion and more and
send your feedback questions and rants 2
comments at coding blocks net and follow
us on twitter at coding blocks or head
to cutting blocks net and find our other
social links there at the top of the
page and with that welcome to coding
blocks I'm Alan Underwood I'm Joe Zack
and I'm micro outlaw and this is our
first remote recording so we'll see how
well this works out yeah pseudo so so me
and outlaw in the same room and then Joe
zach is somewhere in sunny Florida we're
sending smoke signals to him it's ready
see that now it's dark now oh yeah this
isn't going to go over well alright so
let's kick it off with our news this
week or this week I say it like that I
mean it's been a while since we record
have been busy so too long oh yeah it
has been too long we were all kind of
chomping at the bit to get back to this
so yeah it's been too long yeah the
first thing we want to talk about our
the poll results so first off thank you
for all of you that went up there and
told us how often you wanted to hear us
and if you haven't now is your chance
you go to slash pole or slash episode 27
you know coding box.net / episode 27 or
cutting box.net / poll and you know let
your voice be heard yeah so right now we
got a pretty tight race between the way
that we do it right now to where we
release once every 12 weeks yeah wait
White once every 12 weeks whatever get
out of here you know what though you
know what though I like I still want to
go through the results yet so i'm not
sure if we wanted to say that but was
also were but i will say this though
about some of these like especially for
those that like took the time to to
write your own you know result there it
will definitely make it harder to
tabulate all of that but there were some
awesome little gems in there and i'm
pretty sure one of you guys i'm talking
to you
on in you Jeff set some of these up that
because like for example someone said
yeah their quote was a tee time I can
hear Michael's voice would be awesome
yeah we did not do that but it was fun I
don't bleed he then I'll believe you and
I thought there was another one that was
similar along that same vein it was like
but it said sweet voice or something no
my absolute favorite was what a week one
hour long sweet Jesus oh yeah right yeah
now they're there were some really good
ones in there they were like that so you
know I really do appreciate the time
where we appreciate you taking the time
to go up there and vote and like I said
if you haven't now is your chance and I
think we're going to make this a regular
thing you know we'll have some different
polls and see see what happens try to
put some interesting questions out to
you guys and give you guys an
opportunity to you know let your voices
be heard yep so definitely appreciate
the time taken to do that and speaking
of appreciation wanted to give a big
shout out and thanks to give up Sam
Gordon web guy at be cry corn to Kenneth
glish Olli 724 and there's two names
yeah I'm gonna need some help from
outlaw pronouncing Oh ed be I got that
one and Gordon web guy hey note I did
those man are gonna use the hard ones
well I guess this first one is mr.
Furley that one's not so bad right I
thought you're gonna say ruefully not I
think I got that one right and then I
mean why would you do this to me um em
go fast M umber mang may I am Berman PGA
right yeah maybe that's it yeah in Bern
ma'am pukka ok I actually um that
reminds me I was watching a tosh point-o
the other night and by the way he's from
right around here and there wasn't a
half have you got I want to know if you
guys heard of this is called speech
jammer know and what you do is you plug
your headphones into this thing and
you you know kind of hit play and then
you try to talk and it kind of sends
this a little like feedback loop of your
own voice back to you that's supposed to
kind of mess with your speech centers in
your brain so it's actually really hard
to talk while you're kind of hearing
this stuff so I thought it was kind of
funny there might be a fun little gag
like you know get your wife on there and
ask her to tell you a story something
and you just end up sounding ridiculous
I thought he was trying to give us like
some kind of hint about this remote
recording setup he was like having a
hard time because he was hearing himself
apparently no I think he's making
excuses already we're five minutes in
he's already like dropping an excuse
bucket the but yeah we drop into the
sleep bucket in it yeah but seriously
some of these reviews are absolutely
fantastic we got several that said hey
this is a must add to your podcast
collection or you know quickly becoming
one of my favorites so hey guys
seriously thank you very much we haven't
gotten enough of them it's not like the
one where I mr. Furley and he says that
we're funny we try to be sometimes and
sometimes it just comes across that way
anyways but but yeah keep them coming we
absolutely love and appreciate that you
guys take the time to do that so thank
you super super appreciated the next
thing we want to talk about was built
Atlanta yeah man that was awesome
outlaws even wearing the shirt right now
yeah coincidentally um that was a so
outlaw and myself went to this to this
all day event that Microsoft hosted here
at the atlanta aquarium and it was very
well done first off like I mean it was
this is like the the on the road version
of build yeah right yeah so we didn't
actually get to see the hololens man
they did well I mean we got to see
pictures of it get a nice touch one or
see an actual I think everybody there
wanted to see it right like I think
that's how I have two people showed up
to it but is this thing real though I'm
now is this really going to hit the
market man personally I think it's
vaporware I don't think he's ever going
to happen I don't ones the hardware
equivalent of vapor wear whatever that
is that's what that is
no glass well see Google glass actually
felt like to me like it that really was
vaporware but this thing looking but
that actually made it in the market and
people could buy it yeah now is it in
the market anymore well no not now but
well yeah whatever but but what I mean
though it was actually a name that
people could buy it was just a
ridiculously expensive thing like I'm
curious to see if this ever even gets
that far though where is this going to
be like the the surface table that you
only hear rumors about I feel like
anything at CES like if you see it at
CES it's just an we're going to happen
like but you know what here's the thing
though from my perspective just looking
at this like what they've shown of it if
they can bring the price of this thing
down into within reason let's say within
an xbox one type price range you know
500 ish dollars if they can get in there
google glass was 1500 1500 this thing's
going to be less so so think about it
like this Microsoft has been known to
take a hit on hardware knowing that
they'll make it up on the back end the
xbox 360 sol de los the xbox hold a lot
that's just how game consoles are done
now not not always but but the thing is
is think about this if they can get this
in the hands of people and they can and
they can monetize a market because
they're going use case for thing is so
small I don't know it the thing is i
can't imagine building software for it
like that would be incredible ears a
problem here's the problem in in in it
would doesn't suffer these the exact
same fate is 3d tvs but a similar one
and that is that for people in glasses
like myself I'm automatically like me is
probably going to be uncomfortable to
wear on top of my glasses or not you
know comfortable or not like look
correct or something do you need
contacts yeah that's not me yeah I don't
let me down as gosh I don't know man
like it looks really cool to me like
some of the things that I saw that they
could do with it now how well it
actually works in real interaction who
knows like you can't even see the thing
anywhere but I just can't imagine
writing software for it could you
imagine actually trying to do an
augmented reality type thing to wear
it's you know it's not like something
your phone where you point your phone in
a direction it shows you the windies as
the closest right maybe this should be
the next poll is hololens real because
it it's real no I mean I this thing
could actually be like a Michael Bay
production right just making you think
like like you Optimus Prime looked
pretty convincing in those movies right
this could be another one of this yeah I
don't know I'm excited about it i hope
it i hope it is real but i mean we
haven't seen one yet but anyway I guess
back to the show on the on the Atlanta
build it was really like it was a day
full of information that i thought was
really cool like the approach that
Microsoft is now taking to software is
you it's almost like responsive web
design like but what I got out of the
day's worth of stuff where they have
what was called WP oh no not WPF uh it
was the oh god what can I not remember
what it was right now but basically
they're bringing the entire platform all
together so you'll be able to write a
piece of software that we could run on
something from a raspberry pi to a
windows phone to a windows tablet to the
desktop like they're trying to they're
trying to unify the experience I mean
they've been touting that for years that
they have but now they're actually
forcing it all through the same
programming model which is which is a
cool thing um you know back in the day
see had this grand vision that you could
write your C code on you know one time
and run in anywhere to well javale's and
Java came along with a similar promise
and Microsoft's been saying a similar
thing with a write your universal app I
mean I get it it's cool there's some
stuff out there I'm not trying to be a
debbie downer but there you can tell
that they're definitely feeling pressure
from you know Apple and Google
especially in the mobile market but yeah
and I reason really there was some
really cool stuff there but you know one
thing to just like the expense of it
though oh god that that whole day was
covered yeah I mean we didn't we didn't
pay for parking we didn't pay for food
and dude they rented out the entire
ballroom of the Atlanta query
so it was not a cheap event and I mean
they want people to get excited about
what they've got going on and and I will
say this as a dot net developer it is
exciting but it would be way more
exciting if they had you know a ton of
mobile users or you know something along
that line because right now still like
if you're going to write an application
you're writing it for windows right
you're not you're not really going to be
writing it for the windows phone now the
the one cool part is if you're our
mobile app you're going to write it for
iOS first that's what I'm saying but
here's the cool part right like if let's
just say if this this thing happens and
this is what they're saying windows 10
is going to be a part of this universal
platform that they're doing if you can
write it for windows and then for
essentially free it will scale down to a
phone and a tablet and the Internet of
Things devices that could be cool right
like now you have buy into a platform
and you didn't really have to work at it
because like a surfer you're not going
to any application you're going to write
for a Raspberry Pi isn't gonna be
something that you're going to be
interested in on your phone no no no
what I'm saying is you write a core for
your desktop app and now let's say it's
a business layer or something like that
or you you layer your application
properly that now becomes available
across all devices yet you're not going
to write a desktop application that's
going to translate perfectly to a phone
but it is cool that you could have that
same core be a part of it right I got
two words for you and they came out of
that event was a data lake that was cool
yannick what's that he was it I you know
honestly I don't even know there was
there was some you know as your
announcements that were I made thereto
and like one of them was this new data
like service for dealing with with gobs
of data but I couldn't help but like
laughs when I heard the name because it
just sounded kind of humorous and then
yeah there's the the image of the dump
truck spill and trash everywhere and I
just kind of thought of that as like you
know here comes the the data truck
coming to get your your data to take it
to the data link
yeah man the result in code was the most
most disappointing part of it for me
like the massive text editor that is
code so so at the original build event
they announce code and then I guess I
misunderstood its purpose because i was
thinking like hey this is a cool you ide
that they're creating that to be
cross-platform but at the build event in
atlanta they were very careful every
time they mentioned it they referred to
it as an editor yeah they never once
talked to it because because even in my
own experience like as soon as it was
talked about I was like oh let me go
download this thing and start playing
with it see if i can write some code you
know like let me just write a simple
hello world app and compile it and watch
it run or debug it or whatever and you
know you try to bring up a task okay do
a build and it's like okay yeah I can
figure that you're like no you should
already know how to do the build it's
like it Sublime competitor nope no bad
plus plus well well yeah maybe but and
they at one point during the
presentation in Atlanta they mentioned
that you could do compiles for what was
it it had to be a mono specific project
in order to compile only on linux and OS
10 so I you know I've been playing
around with this on Windows 8 bucks and
that explains why I couldn't do any kind
of compile with it well it does say like
on their site code visual studio com
that it has an integrated debugging
experience yes for JavaScript oh yeah so
if you wanted to write C sharp on it
right and then compile it you have to a
be on something other than windows which
means be it's a mono project because at
the moment they haven't released their
own their own core yeah non-microsoft
form
I run hot that's really hmm that's
interesting I mean it okay so i will say
this if you throw it into this into the
camp of sublime that is still pretty
cool right I mean but then was it buying
you though that that's very
disappointing part it's free oh my god
so so you can download sublime and use
it for ever for free and it'll let you
in notepad or I'm not saying I'm not
saying that you should I mean you know
you know give them a few bucks right but
but I believe if I'm cremy from Rama I'm
fairly certain that this is based on
Adam which is another free editor yeah
Adam is I don't know is it based on adam
i really don't know fairly certain it is
uh well in which way i mean they did
they did talk about it but it wasn't a
huge it wasn't a huge part of build I
mean build they definitely they showed
some stuff with Azure that was really
cool like some of the analytics you get
if you're hooked up into their services
I mean they were they were walking
through like I mean if you were in love
with statistics and you like to analyze
every bit of everything that happens
like you can see all kinds of cool stuff
on their dashboards and Azure um I mean
the the unified platform was one other
big selling points and that was mostly
using WPF and zamel right i was at WPF
or was a jizz amal i know that they were
talking about things but but it was
seriously it was similar to responsive
design because you had things like
saying hey if the if the screen with is
you know 1024 or less than then switched
to this mode so that's pretty exciting
you know like for a while there we were
kind of afraid that maybe they're going
to be getting away from zamel because
they kind of killed off silverlight and
we're promoting HTML Javascript but
looks like it's still still in there
actually not only is it still in there
it seems to be the focus for yeah it's
definitely if there's a marine question
that's how like what was the future for
Sam oh it seems like it's a not going
away yeah it's it's pretty much the
predominant for creating your UI stuff
um so that that was really cool um but
let's go back to the day too late though
to give you a more like definition of it
it Microsoft's touted as a hyperscale
repository for big data analytic
workloads
so now you know what it means clear as
mud um no fixed size on file limits or
account size it's based on a Hadoop
distributed file system blah blah blah
blah yeah they they also said some
ridiculous statistic there that didn't
make much sense like some some massive
percentage of Linux running in the cloud
it was those do you remember what that
in my battery of my laptop was dying
because I mean oh I don't have the notes
with me yes they made some ridiculous
claim about well I say ridiculous like
some obscene percentage of all the Linux
greater than web servers who I want to
say it was like that they said something
like that I don't mean I wish I could I
wish I had my net with me on from the
show but they said that they were all
running on Azure like cloud-based
versions were running on Azure and all I
could think was there's no way with AWS
being there I mean you got google
compute yeah AWS ec2 instance is out
there like a digital ocean really you
have let's take all the small guys let's
just talk about just focus on the two
big wises yeah there's no way AWS is
definitely leading the way I actually
found that stat it's um over seventy
percent of all links boxes running on
azure are running on Azure I believe
that nice oh well done there she did uh
yeah yeah there were something else is
on the tim @aa ya when it was said
they're like literally both me and Mike
looked at each other like no way the.net
native uh that was another cool feature
cuz I where you could just simply
recompile your app to be a dotnet native
app and it would you would gain it was a
huge performance boost yeah the numbers
were like 20 40 60 so I'm trying to
murder like which was which though you
got you got a smaller file size in a
smaller memory footprint and oh so you
know I know what it was I know what it
was it was
it was something like a dang no I don't
one of them was the one of them was the
start time a cold start time and then
the other one was the warm start time
for the app and then the other one was
the memory footprint yeah yeah I can't
so here's what he's talking about with
dot net native thing is basically what
happens is right now when you compile a
dotnet application it you know it
compiles it into the what is the CIL or
whatever um hey hell are all right now
yeah so then that gets run but the first
time you take a big hit because it has
to basically load it all up and and get
it ready to run when you do it this way
it actually compiles it down to sea
level code right wasn't that what it was
no this was it compiles it down to
native machine code that machine like
C++ ahead but this is taking you know
like your your Universal apps you see
sharp app and compiling it down to
native here we go it performs it you
know their app will start from a fresh
start sixty percent faster than it did
and all you had to do which is recompile
it and it would use anywhere from
fifteen to twenty percent less memory
than it did and again you're just
recompiling the app yeah and another
thing that they were talking about a lot
is they spent a lot of time in their run
time making sure that applications now
are easier on the processor because
they're more concerned than ever about
doing things on the mobile platforms and
tablets and that kind of thing so
they've really been focusing on these
things a lot I mean there was definitely
some cool things that came out there was
another website it was something to cat
a Microsoft man I tweeted all this stuff
out actually real quick I just wanted to
mention that there actually was a tool
called engine I think I even came out
like when done that came out that let
you compile things to native code but
I'd always heard it was kind of a bad
thing because you lost a lot of the
benefits of like just in time compiling
so I've never been really clear on what
the difference between engine and the
new native stuff is but I've heard the
same claims about performance benefits
and everything so kind of interested to
hear the difference in
you know what the difference is I would
love to hear it yeah Oh in the site the
site i was talking about oh and it's
free by the way you can go up there and
check out all these things that we were
just kind of mentioning is microsoft
virtual academy com um so they
definitely have a lot of cool stuff and
it's all free like they teach you things
they have sections broken down by types
of C sharp and zamel hybrid cloud
automation cloud app development blah
blah blah blah blah there's a ton of
stuff so I'll definitely go check that
out if you're interested in the newest
things coming and learning for free yep
all right so i think i think we've we've
hit a lot of points on the build atl so
what you got yeah there's playing stuff
out there that you can find yeah yep so
just want to mention really quick tampa
code camp is coming up i missed the
orlando code camp on a move to the area
but just kind of throwing it out there i
do stop plan on starting to hit up some
of the meetups in Central Florida so if
you guys are in Central Florida what you
say is that i'll be there oh yeah you're
gonna be there should i drive now tried
any death I'm looking out i think it's
july fourteenth so you got a couple
weeks i'm actually gonna be down there
dude i'm not gonna be too far from you
oh really in tampa yeah yeah i will be
just across the way from Tampa so I
might actually come out to that awesome
I July eighteenth today excellent dude
I'm going to be done there alright
alright so um the next one I actually
appreciated this so Rebecca on on
Twitter the other night I had a very
very long coating night I think the
longest ever that I've done and in i was
getting a little punch drunk and I
needed some humor and she came to the
rescue she said um what do they call and
elevate an alligator in a vest all right
anybody I I don't know an investigator
that's wonderful it was super corny and
exactly what I needed at about three or
4am whenever sometimes a good bad joke
just make you feel fuzzy oh wait wait
wait why are you calling her jack a bad
joke
is fantastic it's a good bad joke you
know the great part is is I think all of
us looked at this on our phone and it
cut off the actual answer it I was like
we should never get to give us the
answer is ridiculous you're like text me
back forth like what's the answer I
don't know it was just further down on
tweet she built suspense so I
appreciated that that was fun yeah now I
have to pour one out for my buddy here
so you'll sense oh oh god no no means
thing about that are tight no resharper
oh my god so we've already talked about
you know how I had uninstalled it and
everything and iming yeah the sands
resharper and honestly I've kind of I've
kind of gotten addicted to productivity
tools the the ad in that Microsoft makes
for visual studio productivity tools are
pro tools or some like that yeah 2013
and it's got its got some nice little
add-ins to studio but definitely not to
the degree that resharper has especially
resharper with dot cover which was my
favorite combination and so you know I
said last time that I would eventually
come back to truant you know try and
reach sharper out like you know if I
ever decided to or felony to so I did I
decided hey you know what I'm going to
ultimate and because every version I've
ever used in the past has just been
immediate gold like I've loved it and it
has just been like you know a part of me
why am I going to bother with this trial
i'm just i'm all in let's buy the
upgrade to ultimate and awesome things
will happen and I didn't like it really
like to slow or shortcuts what I didn't
like okay like yeah it was really it was
really bad wait really bad well my
experience was really bad let me be
clear you know how you you hear a lot of
people that say
what they don't like about resharper is
that it's slow and you know the what it
does to visual studio and things like
that they're not wrong so I had problems
where like just trying to navigate
between like especially like you know
the current code base i'm working in as
a rather large in terms of the number of
files and whatnot and going between
files it was just visual studio would
hang often almost always and you'd get a
not responding prompt coming up from
visual studio all because you decided it
was time to look at another file and it
was random little things like that and
just even sluggishness while using it
and again like I know before anyone
jumps on this because I mentioned the
productivity tools there is a known
issue where productivity tools and
resharper can not coexist so I had
already at first I tried just leaving it
productivity tools disabled and see if
you know that would work and then that
still wasn't by him anything so i
uninstalled productivity tools because
you know really wanted to commit to
resharper especially after I'd already
paid for the license without trying the
trial but but and it's still my my luck
still wasn't bad so I wasn't good yeah
I'm sorry yeah uh yeah it did not work
out well for me and so I ended up
uninstalling it almost within 24 hours
Wow paying for the license although and
so for the first time what's your
license key I'll try it out make sure
yeah no connect so you're on Twitter and
just let whoever gets it yeah I mean I
just want to make sure it really is bad
right right but so so I but for the
first time though like like vision
resharper like a lot of tools or not a
lot but you know several tools do this
thing where like you know after you
install it they immediately
open up a browser to their feedback page
and they want to know like a yr un
installing this thing right and I have
always just been like if I'm gonna talk
for that forget it and why wow why do
you care whatever right but this was the
first time where I was like no this is I
love this thing I've loved this thing
for so long now right like hi I have you
told everyone I've gone to the hilltop
that I've sang its praises for so long
hell and now it has betrayed me I need
to let you know how I feel about this
betrayal right so i actually did write
back so i will say that it's not over
right because they're so there's there's
there is advantage to filling out those
forms it turns out because their support
team immediately got back in touch with
me to wanting to find out why and one of
the JetBrains tools is the profiler and
so i sent them some profile information
from visual studio so that they could
debug see like what was happening with
it so maybe they'll fix the problem in a
future resharper bug but until then I'm
kind of like you know at the mercy of if
they fix the bug you know if they decide
to fix it if they can reproduce it if
they can't fix it whatever right and to
be clear you're not running on like your
core i3 you have like an i7 with 16 gigs
of RAM right oh yeah yeah yeah so yeah
SSD and all that good stuff yeah it's
not it's not a slot machine and I can't
use my favorite tool mmm that's a little
road which really makes it difficult
like you know I suppose I haven't tried
and saw doc cover by itself because I
mean it hurts too much yeah the pains a
little too fresh yeah that's what it is
yeah I feel you though that would hurt
so all you reach our poor naysayers I
guess scoot over here he is alright so
one last quick thing in the news section
before we get into the real stuff here
today
is it this hit me so hard the other
night because we've all been there where
you got to get something done right like
it has to be done you have to get it
done dude I'm sitting there i think i
even i am out long i was like dude I'm
really just starting to throw away good
programming so it's right now he's like
dude you need to tweet that and I did
and a lot of people favored it because
apparently everybody feels his pain
right like you're open it's the 11th
hour and you've got you know 10 more
hours of work to do and it's like Oh God
and so you just really start you know
almost just forgiving yourself ahead of
time for what you're about to do because
it's like I don't have time to make this
perfect I don't have time to make this
even decent I'm just making this right
well maybe this should be the poll the
next paulding because I dare say that
like a majority of code that ain
developer has written where they were
like under the gun you know tightening a
tight deadline and really pressured
that's when they probably wrote the code
that they are the least proud of or
there's a portion of cut they're like
yeah not proud of that part but I had to
get it done too although i'd love to see
that commit message i just imagined
saying like I dare you to say something
you know for I am actually i was i was
laughing about this earlier so i've
become a fan of rebase and get because i
thought you could squash your own
history well apparently there's a way to
do that but the way that I've done it
doesn't so my commit messages like
there's things like man this is some BS
like I definitely had a bunch of commit
so I'm like man I'm fixing another
problem with their framework I'm so
ticked off right now right like remove
test case since code didn't ask you a
wait I didn't run a test case I guess
that's very good bracket sale but no I
mean seriously like we've all been there
where it's like oh you started out you'd
separated all your classes you had this
nice roadmap ahead of you and you get
down into it and you know 90 bugs later
that you're trying to work or
you like man I don't even care what this
looks like when it's done as long as it
comes up on the screen the way it's
supposed to right so yeah it just wanted
it all of those who favorited we tweeted
I'm sure that you've all been there I
did it along nerve did it for the walls
right get commit commented out failing
tests if you guys don't recall or if the
if this is new to you and you do find
yourself in a similar situation as Alan
did where it's 4am and you know you got
to do a commit and I gosh would I I
don't even know what to say about this
commit you really should just go to what
the commits calm and let it tell you
what your commit message should be yeah
that's I probably I wish I would have
remembered that the other night because
I would have or the other morning so
yeah man that was that was a rough night
so anyways on to what we're talking
about today which are hierarchical data
sets um we did a cat yeah we did a
couple episodes on sequel a while back
and these kind of things come up all the
time and they're a little bit more
advanced topic so we're going to start
down at the bottom with this but we're
going to work our way up so the first
one that we're going to talk about is
called the adjacency list and it's
pretty simple if you've worked in
databases for long at all you've seen
this stuff essentially you if you if you
think of an employee table just a simple
table typically what you'll have is an
employee ID and a manager ID that is the
adjacency list right there essentially
it's a self-referencing parent-child
relationship within the same table well
let me let me sum it up in an easier way
or every record knows its immediate
parent yes yes so if you have an
employee ID let's say that you know
let's say that Michaels the boss on the
middle quit if Michaels boss Jose the
middle guy and I'm the grunt down at the
bottom so that's why you're up at 4am
right Michael's ID 1 jose ID too so
Michael his manager ID is going to be
null because he's the top of the chain
right
that's right um Joe like where this is
going Joe is ID too well his manager ID
is going to be one that's Michael and
then me down at the bottom my employee
IDs three and my manager is too so
that's Joe so if you were to query this
thing going up then you'd see that hey i
am jose worker and joe is mike's worker
and that's how the table looks okay so
it's a tree basically right so everyone
has only one parent but each you know
parent could theoretically be parent to
multiple yeah so if we wanted to break
that down to where it wasn't a complete
waterfall down right to where it was
Mike than you than me it could be Mike's
at the top you know I d1 manager ID null
then your ID to manager ID 1 i'm
employee ID three with manager ID 1 so
both of us are just one level below him
but multiple children just like you said
okay so an example thing I might want to
query is uh give me all Michels reports
yep and yep and well are we gonna talk
about direct reports or reading time I
like the full trees let's start with
your direct reports right it easy yeah
we'll get we'll get into the meat of the
problem in a second but yeah so direct
reports you basically be like hey select
star from or star that's a bad idea
anyways but select star splat splat from
employees where manager ID equal one
give me all of Mike's direct reports
right so that's it pretty simple another
thing that you typically see in these
type of situations are hey show me the
top level guy and there's usually two
ways of going about this you'll either
have the manager ID null or you'll have
the manager ID equal whatever his ID is
so you'd say hey select star from
employee where manager ID equal know
that give you Mike back or if they had
filled it in you could say we're
employee ID equal manager ID and now you
have the top level guy so those have
covered the basics of of what the
adjacency list is um now to get into the
harder part right so let's say that you
are a few levels deep how do you go
about doing that well this is where
you'd be tempted to use you recurse
of CTE not to solve that's not your
problem okay well do this you could do
it this way yeah so but go ahead CTE for
those who don't know or haven't listened
to the previous one so that's a common
table expression oh and just to be clear
the previous episodes that we're talking
about were episodes 13 and 14 yep and
they those are pretty deep episodes so
um if you if you want to put your sequel
hat on it's there there's a lot of our
hats are a must yea though that those
are some pretty deep episodes um but a
CT is a common table expression and all
that is it gives you it kind of allows
you to create virtual tables in your
queries um with some added benefits what
we're talking about with the recursive
CT now here's the here's the thing with
it it's only available in some are dbms
s my sequel does not have ctes postgres
does sequel server does Oracle does a
lot of what they call enterprise based
database management systems do have this
but like my sequel one of the most
popular on the planet does not have a
recursive or even see T's sometimes
people call these width clauses right or
I think I've seen that word before we'll
say you're doing a width in your sequel
yep that's that's what it starts with as
a with um so with the recursive CT there
and I know why Mike saying that you
would be tempted to do it and here's the
thing if you have relatively shallow or
smaller data sets that you're using just
go ahead and use them they're awesome um
you know what's smaller like a hundred a
thousand I mean it kind of depends right
it depends on the load of your system
and all that um I mean I've definitely
done it with thousands of records and it
and it performs fine it's going to be
manageable it will be manageable I mean
so said just be clear then the way the
CTE is going to work is like let's say
you have like with employee hierarchy as
and then you'll do a select star from
what was your table employees right
where employee ID equals one yep write
your first guy or Leslie we're manager
ID
is no let's get let's get the top level
guy okay where it's no where employee ID
equals no union all select star from
employee what did I name the CT
originally CTE hierarchy okay so select
star from employee where employee
manager equal employee hierarchy dot
employee ID yep right so that that that
second portion of that second select
statement and that Union all is going to
call back on the CTE itself right so
it's going to recursively call on it and
that's going to be fine in your smaller
data set example yep or or it could even
be a large data set within that table
but depending on what you're doing with
that across other tables that you're
joining too and that kind of thing it
can get really big really fast and and
now your performance can really degrade
you say performance you mean CPU we talk
in memory everything all of it right
like so it could be your CPU well so
here's the thing you can index these
columns the one great thing about the
adjacency list is super easy to index
right you got two columns you have your
employee ID and your manager ID so
sequel server can utilize these indexes
well I mean there's other there's other
ways to solve hierarchical data to where
you could also index at night so I
wouldn't say that's necessarily the
benefit of adjacency list well so the
fact it's simple those what I'm saying
is right like you have your parent child
relationship in one table when we get a
nested set models though that's are
pretty simple things that you're gonna
enjoy building them not build know but
we're talking about the indexing now
okay okay forms part so because what I'm
thinking like when you talk about the
employee ID in the manager ID in the
benefits of the adjacency list
immediately I'm thinking of the fact
that you you could have integrity on
those columns that yep very easy yep
omission yeah cyclic data oh if you have
something that references something up
above yet so here's the thing with
something like sequel server I think it
has it has a mac version yeah max recur
of like 99 a it might be higher than
that I can't so I won't totally kill the
box but really it's invalid for this
you're not gonna be able to model this
with this approach no actually what you
would run into any ways is that would
eventually end up breaking you because
yeah if you have something if if you
have a record five down that references
a record that was three up from it then
yeah you're going to start getting into
this recursion so essentially you're
just going to start getting back a ton
of data that doesn't make sense right so
yeah that's a problem but that's
actually a data problem right that's an
integrity issue and it depends on your
data you know for like a manager
hierarchy that would be a bad thing but
well is it might be well I mean I said
there are some there are some management
chains that are called flat right to
where people can report to multiple
different people so yeah really checks
and balances like the legislative branch
checks the judicial no I'm thinking of
like the one the more proper the big
known one was blackberry when they there
was a period of time where blackberry
had to see a few CEOs right to the whole
company like it's starting at the top
there were two guys yeah I'm oh yeah
that's yeah if you've got two parents
this is right out the window too yep so
so that's all this is automatic though
like brainy get into like circular data
structures like that though this is this
wartime up higher cool I don't know if
you heard Joe by the beginning of the
show but we say we're drink about
hierarchies not circular circles right I
think that's a different show yeah
that's the graph databases so difficult
being remote you can't see that we're
coming hierarchies yeah you guys can't
hit me anymore it start throwing things
across the table oh so yeah I mean
here's the thing we do get into the CTE
so when we were talking about the
performance and all that if you think
about what sequel server is actually
having to do behind the scenes I'm sure
they've built in optimizations but in
the old days before you had things like
CTS essentially what people do is they'd
write prox right that would then fill in
temporary tables and it would loop over
and say okay go give me all the children
of this so hey select star from from
employees where manager ID equal this
then you get down another level and then
you and then you'd step through every
one of those and say all right give me
all the employees that report to them
and so you kind of fill this in behind
the scenes that's really what sequel
server is probably doing is it saying
okay give me all those parents now or
all those children now give me all those
children and so it's one at a time
stepping down the hierarchy so if you
have a really deep tree and and if you
have a wide table and by a wide table
you have a ton of columns in it these
these queries get expensive especially
if these if the data sets split across
pages like there's all kinds of things
that can happen there but the deeper you
go the more recursive levels are the
more expensive it is to actually run
that and but you know on the plus side
there are JC list very easy to implement
Oh super easy I mean right especially if
you have an R DBMS that supports ctes
right if you have a database system that
does not like my sequel then you end up
building something like we what we just
mentioned where you were filling in some
sort of temporary table some staging
table tour you can pull the data out
with an adjacency list well not only not
only is the implementation of a simple
which is easy for me to say the the crud
on it is also easier to see a moving
data around the leading data inserting
data into it you know those are all
cheap you're relatively cheap operations
compared to other hierarchical data
implementations yep absolutely um I mean
what moving somebody for manager want a
manager to you basically say hey update
employees set manager ID equal to two
where employee ID equal five right
whatever so super super easy and you're
done if you do that you're done there's
nothing else to look at nothing else to
touch I mean chances are if you're
writing any code where you even touch
the database you even look at the
database you've probably already seen
data that matches this model they're
like you you already know about it yep I
mean old
the old like not dashboards like what
can I think forms this is how the
commenting system would work in a lot of
forms right you'd have common ID equal
one if somebody replied to that then
then common ID tues parent ID was one
and so on down the list and that's how a
lot of commenting system works heck I
think even if you look in the WordPress
database um you'll actually see those
type of relationships right this is this
particular piece of content belongs to
that piece of content belongs to that
piece of content so it's a very simple
way to structure schema for represented
in a hierarchy so so what are the
problems with it so we mentioned that
you know large trees aren't cost process
if you're dealing with large data sets
it then this might not be your guy right
that that's really that's like the
number one thing that comes to mind for
me as far as like problems for this yeah
and here's another thing i will say even
if you're not going down a ton of levels
even if it's something that you are
constantly querying that way it can get
expensive right oh that's a great point
here yeah so you kind of need to look at
the frequency of it because you know
taking the hit on it once or twice may
not be a big deal but if every single
query you have and I'll give a good
example if you have um let's say you
have slim so as a product catalog right
that's a perfect example yeah if you're
constantly having to query down the the
categories every single time you are
going after products that gets really
expensive because you're now crawling
that that that tree on every single
query and if you got a lot of people
hitting that I mean that they can really
start running into some performance
issues okay so um just to make sure I
understand this I wanted to kind of sum
it up so would you say that and
adjacency list is one strategy for
solving the hierarchical data problem
where each record keeps track of its
parent yep
works for me double all right so I think
we've got adjacency list down it it's
it's a fairly simple one you've seen it
before but we wanted to go ahead and lay
the groundwork before we moved on to any
other because we wanted to do this is
going to be the first of a few episodes
where we wanted to talk about different
hierarchical data models right and so we
need to lay some groundwork out so some
some you know framework out that we can
all talk on a common language here so I
think we got a Jason see list but before
we move on to the next model I do want
to say that you know if you haven't
already we would greatly appreciate if
you would leave us a review you can go
to coding box net / review and find your
platform of choice be it itunes or
stitcher or whatever if you know of
another platform that you like to find
us on and you want to leave a review
their hey by all means please do and let
us know about that that platform because
you know there's there's probably
there's a ton of aggregators out there
that we're not aware of so yep um so I'm
being distracting on camera he is being
destroyed there you go I figured if I
took a selfie of myself sitting here
then I could just kind of tape my phone
to my webcam and go to the bathroom
interesting all right maybe the poll for
this one should be like how do you think
this remote gig is working should Joe
move back to Atlanta yeah i'm going to
go ahead and vote yes yeah yeah and if
our sound quality sucks this time you
guys to let us know we'd appreciate it
blame ya yep um alright so the next one
what's the next one we're going to look
at so as we as we step into our deep
dive here for nested for hierarchical
data models the next one we want to talk
about is nested set models right you
want to give us a brief overview or you
want me to dig into it I will try and
give a brief overview
we brought this up previously as well um
bow yeah I did want to say we did talk
about this in episode 13 and around the
44 or 45 minute mark but there was still
some some I don't know that we went into
it as deep as we probably could have
right yeah I mean it definitely wasn't
centered around higher hierarchical data
sets i think it was kind of a mention in
passing so so essentially what it is is
this if if you tried to take a hierarchy
and flatten it out to where if you
thought about everybody that was
underneath something let's talk about
employees and managers again because if
something people can kind of relate to
if if you were to just take your arms
and wrap them if they were big enough to
wrap around all the people under you
that's kind of what the nested set is so
essentially if if you envisioned that
everybody has a left and a right all
right and they're right is always one
more than their left if they are the
only person at that level so let's say
you're at the very so you kind of need
to picture it from the bottom of the
tree first right if you're at the very
bottom of the tree let's let's say that
your ID is 20 hold on before you go down
that path that yeah because because I
already see like there's some confusion
and I think I got a better way to
visualize this okay right like let's get
out of the the employee mindset for a
moment alysha talk family tree okay
right so so if you're building your own
family tree and let's say that you're
making the smallest family tree you
could possibly make and being lazy and
you just start with you and your parents
ok so this left right business that
Alan's talking about basically what
you're going to do is you're going to
start at the top of the tree right and
you're going to go down every node and
and count it and then when you get to
the bottom of a branch you're going to
start walking back up and in continue
counting right and then when you get to
wear a branch Forks then you're going to
go down that branch and continue
counting and you're going to come back
up and you're gonna keep doing that
until all branches have been visited and
node in the tree has been visited at
least twice yeah okay and this is where
the left right value part the Allen
comes in so as you walk down these nodes
the first time you're adding or you're
setting a value for the left side and
then as you start walking back up a
branch is when you set the right value
okay so in this in this very shallow
family tree version then if i start with
myself my left is one and then let's say
I start with my mom her left is too
because I don't go any further right her
right is now 3 and I come back to me and
then I go to my dad and his left is for
and because I'm not going any further
down the tree his right is five and then
I come back to me and now my right is
six so I have a left value of one and a
right value of six my mom has a left
value of two and a right value of three
and my dad has a left of four and a
right of five yep okay now that is as
simple as I can explain that but it's
hard to appreciate the value of it just
yet yeah now if you keep if you were to
make this tree bigger right let's say
that we we decided to include my mom's
parents in this tree then as I let's
start over with the counting yeah I
start with myself my left is one I go to
my mom her left is to I go to her mom
which is be my grandmother her left is
three she's now the end so her right is
for go back up to my mom and we go back
to the next branch which would be her
father so his left is five right six and
then come back to my mom her right is
now seven now we come back up to me and
then we go to my dad to calculate his
left of eight his right of nine and now
my right is 10 yep so now you can see
the
when there was just three people in that
hierarchy my left was one in six but as
soon as we added two more my values went
left of one and right of 10 yeah and
what we're going to do to help
illustrate this is we're going to put an
image up on the show notes for / episode
28 so the so that you could actually
kind of see what we're talking about
here but it will link to some there's
already some that are made i'm using a
family tree as an example just because
everybody can relate to that that's an
easy one to understand but yeah there's
some particularly in like a the
Wikipedia article if you look at this
where they talk about product catalogs
as an example for you know how you might
use this but the point that I wanted to
illustrate though is just that with
before you went too deep into left right
that really all that is is I consider it
and I haven't actually read this
anywhere and I'm curious to hear your
take on it but I consider this to be the
expense of walking the tree yep that
that's what those two values represent
the legends that you walk that tree
every time you insert or update yeah
yeah the left whoa okay hold on the Left
value represents the the expense of
walking the branch the first path down
that branch right and the right value
represents the expense of walking like
all of the brain all of the sub-branches
until you got back to that node now as
you already kind of hinted at though and
as you might have noticed when I
introduced just two more people in that
hierarchy I couldn't just I had to start
over with my counting I couldn't just
easily insert that in so those those
would be extremely expensive operations
especially in large data sets yes so so
notice what he said his first when when
he was first just including his two
parents his left was one his right was
six right when he introduced his
grandparents
his right bound completely changed at
that point but that's not just the
important part so did all the left
values for everybody under or after his
mom after the first note was visited
after him every other node at that point
changed for its left and right values so
he essentially had to recalculate the
entire tree at that point right um which
means that like if I had to if if I
wanted to remove my grandmother from
that list no she was the third note i
went to yeah but if i wanted to remove
her then she would change the values for
my grandfather my mother my father and
myself like that entire tree everybody
had at least one value whether it be the
left or the right or both changed yep so
that's why I like typically in
implementations where necessary used you
wouldn't want to bother trying to even
maintain your doing those type of crud
operations in the head instead you want
this data to be throwaway you create it
you save it into a table and when you're
done with it you throw it away and you
rebuild it yep it's it's one of those
things to wear it's probably not if it's
for mission critical time critical
applications where data is transactional
and changing you're not using this this
particular model because it would be too
hard to maintain however if it's
something that's not like to the minute
critical then if it's something that you
can build every hour every two hours
something like that you could do in
batch is something that you can do in
batch that you can basically let it run
do its thing and be done with it this is
when you use the nested set model but
let's go into some people be like why
would you even do that right because
we've only described like bad things
about it right like right even even me
describing it to you like hurt my brain
a little bit just saying it and I
already knew what it was right if you've
never ran across this before then I can
I can only assume that you would ask
like well it sounds horrible i never
want to do that and and here's the thing
to a lot of times um
the interesting part of this is it
typically typically relates back to the
arm cotton we call it the the adjacency
list so just to just to give you an idea
this is usually something that you build
off of an existing schema like an
adjacency list this is not something you
start with the nested list is almost I'm
not saying it never is I'm sure somebody
out there spent a lot of time writing
crud operations to make this work which
seems somewhat insane to me but
typically the way that this is used is
you take an adjacency list um where they
already have a hierarchical model built
and then you build this nested set and
we'll go into the reasons for it what
might as well right now anyways right
like what's yeah it makes sense to me
like if you want to know the ancestors
of Michael you just take that left to
right values and say give me everything
in between and yep you're done right
well more specifically let's drill let's
talk about like where if you wanted to
find only the ancestors or you know you
know that the lineage of my mother in
that example right her left value was
too and her right value was six right so
you can know who sit yeah because if
grandmother was three left four right
500 says yeah okay yeah real time
editing so yeah I'm sorry so mother my
mom would have been two and seven and
then you could do a search where the
left value is greater than 2 and the
right value is less than seven and then
that would immediately return back the
anyone in the tree below mother right
now here's that here's the big advantage
of this right like they are depending on
how much data you're working with you
know it does it is a little bit more
involved to create this data now that
doesn't like you could you can have
hundreds of thousands of records and
still create this data within like
yeah 30 seconds right so that might not
sound horrible it is horrible if you
were trying to do that inside of a web
call right yes oh you wouldn't want to
do it then that's why you'd want to do
it in batch but you so you could build
that all up front but the so you take
this relative term of it it takes a
while to create but once you have this
data created the querying of it is
ridiculously fast and easy into a really
large data sets back of these trees
right of you know these and sub trees or
start at the entire tree like whatever
portion of the tree you need right you
can real quickly get to all that data
and because we're just talking about
simple integers right or depending on
how large you need you know you can
easily index these which is why I wanted
to comment on any of the adjacency lists
like that's not necessarily just you
know rum you know specific to that so so
you can do some some nice indexing too
and really get your query performance on
it so what you would typically do when
you implement these nested set models is
you'd have the data and like Alan said
you would have going back to our
employee example you know you have that
employed table and built into that and
you know each one of those records is
the adjacency list where every employee
knows its manager right so there's a
column called manager ID right you would
have typically this nested set model
that that output in its own table right
and there would be a foreign key
relation between the employee table and
the hierarchy table so that you could
join those back and forth and so that
you can say like hey where the employee
and joint on the input where the
employee ID equals the hierarchies
employee ID and then find where the
values of for the left match whatever
you're looking for and the values for
right so if you wanted to find you know
if you wanted to find everyone in the
tree
above someone like going back to the
example where it said that my mom's
value was too and her right value was
seven or eight let's go no this time
about this used the grandmother in that
example her left was three and her right
was for will hold up before we go that
far I think there's one more piece that
we need to add in here now we got the
left and the right okay that tells us
what we encapsulate right like what our
reach is will say there's also one other
piece of information typically when
you're doing the nest and set model that
you add as well and that's the level so
so as you're walking down and and you
know and we'll go into why you do this
in a minute but I wanted to add this in
here because this is where the querying
becomes easier so right now Mike was at
the top so we'd say his node level is 1
or 0 depending on what your ordinals
work his mom is level two his
grandmother and grandfather level three
is dad when it started coming back up
the tree now is also level two alright
so we have nodes 1 2 and 3 node levels 1
2 and 3 and this is important in a
second when we start getting into kind
of where he was going with this so so
now each record has a left a right and a
level will call it all right and so now
let's go back to where you were talking
about so you're going to query from your
mom or your grandma well yes I was with
grant I was thinking the grandmother
because then you're going down like
three deep right because her her left
was three her right was four right right
so before we were saying where the
values were greater than but instead we
could say like where the left is less
than three and the right is greater than
four yep and that's going to walk you
back up the tree right and so that's
going to find that would return back my
mother in that case and myself in that
case and this is where the level comes
into play but the level wasn't necessary
it is so here's why so if you were going
to do something like um say hey tell me
everybody that is a direct report or a
direct on parent of Mike the easiest way
to do that yes yes yes I see where your
timeout and even going back up
even going back it up because you could
say hey who were her parents now you
would just say hey we're node level
equal no level minus 1 and left is uh
less than that left and right is greater
than this right and then that way you're
just going up one because if you just
said less than it's just what you said a
second ago if you'd say give me
everything with the left is less and the
right is greater that's going to give
you everybody above her okay I
understand what you're saying and I
don't disagree with it but the only
reason why I wasn't bringing that in
immediately though it was because it's
not required right like you could
implement you can have the necessary
that level yeah you could you can have
that you could have the necessary that
it I don't think it's just if depending
on the years listing specific kinds of
queries where you wanted to go as
particular levels and if that was the
case then yes it would absolutely be
crucial I don't I don't know that you
could do some of these queries without
it and the reason I say is because when
you start doing the left less than and
the right greater then um there's no way
to narrow it down to just one level
above you without the afraid he's a joy
and if that's the type of thing that you
needed to do if you didn't need to do
that type of query then that level isn't
it is irrelevant and that's why I'm
saying like if you only needed if you
only needed to build a model where you
either need to go down the tree from
where you start or from up the tree from
where you start then who cares about the
level but if you say that you only want
direct reports or direct parents we'll
see but and I'm saying I didn't list has
example but no but that's why I'm saying
like typically when you are doing a
nested set model you want those three
key pieces of information and the reason
I say it because without without the
level you are now hindered to what you
can do you can only go all the way up or
all the way down you get hint you can't
say I only want his first two levels or
I only want his first level or I only
one piece of math on that and that's
what I'm saying a lesson now that left
value now it becomes extremely expensive
and your joins are going to be crazy too
so so okay yet fair enough I'm not I'm
not I'm not discounting this but when
I'm when I'm trying to get at though is
the core for the necessary yes adding
the depth to it or the level or whatever
you want to call that is a variation on
this that definitely makes it far more
beneficial depending on what you're
trying to do but the root core of what's
required for the necessary that right it
doesn't that's the only point that I was
trying to make and that's why I hadn't
brought it up yet but but now to where
you're talking about though now you
could do some some more advanced queries
like what you were saying yeah I mean
and if we I don't even know that we've
so yet we somewhat talked about the
pseudo query on it right like if you
wanted to do it you'd say a select star
from a in let's say that you call this
employee tree right or something like
that because you still have your
employee table which like we talked
about earlier or not employ a little
istic with the employee because it was
already there you have your employee
table that had the manager ID and the
employee ID right if you're going to
create a nested set table you're
probably going to call it employee
hierarchy or something like that right
um and then in that table what you would
do is you'd say hey select all from
employee hierarchy where you know
employee ID equal one and then you would
join back to itself and say join
employee hierarchy where left is greater
than employ the the parent employee will
call it its left and or you just do the
between right we talked about this
before you can just say it between we're
left is it is between um the top
employees left and right yeah you ask me
a little bit there okay go ahead no I'm
trying to
trying like so so if you're trying to
find everybody that's a child of that
top level right you can say give me
everybody where their left is in between
my left and my right right in that will
return back the tree blood that are
returned about you area below you so
it's a very simple query that's another
part of the nested set that is actually
pretty awesome is when you first put it
all together it's kind of hard to look
at it doesn't make a lot of sense but
once you actually fully understand what
you're what you're looking at which is a
flattened hierarchy is really all it is
when you do that querying this thing
becomes easy hey give me all the left
values below me that's going to fall in
between my left and my right if you want
if you want everybody above you can say
hey give me everybody above where their
left is less than mine and they're right
is greater than mine right to get the
entry above yep and it's just it's a
it's a self join back to itself to the
same table so you would join employee
hierarchy to employee hierarchy on these
type of predicates that we're saying
we're left is between you know this
employees left in this employees right
so it's it's pretty simple to query
which is one of the big things now
building this table I think you did one
recently yeah it's a it's a bit of an
exercise right it's definitely it's
definitely a fun little challenge if you
haven't done one in a while but the yeah
it in again like let's exclude where Joe
was trying to get crazy with us on the
circular crap which breaks it completely
you can't even do it right I mean
circular is any problematic for a lot of
higher cool just about anything yeah
what's why they're called higher but how
do you prevent that right like you know
if my query for kind of recalculating
this stuff on it insert or update breaks
you know there's no sort of constraint
that I can really put in the database
right to prevent this from happening no
you could you could in sequel server you
can create constraints that would that
would not allow that you basically
create a blue
Eve you can create a check constraint
and sequel server and you can buy me
levels deep we should write a CTE that
would be that check constraint so it's
going to be fairly excited but but it
could be fairly expensive right but what
I'm saying is you can actually create a
check constraint I believe that would
allow you to query the hierarchy and
make sure that you're not inserting
anybody to weigh down here that's or
that's referencing you know somebody
that's going to put them into some sort
of circular loop that's kind of hard for
this model because you know it's almost
like I need to kind of disabled that
restriction while I'm doing all these
individual little updates in a
transaction and then I need to kind of
put that constrain back on right cuz
like as I'm kind of going through and
rejiggering this unless I you know wipe
out all the columns that's what we
really do again this will only way you
you wouldn't even have this this data
you would not want to be attached to
your main table you want this in its own
table because at every time this batch
runs you will be blowing that data away
and restarting and so if you had that as
columns in your main table then it's
going to decrease the performance of it
because you're going to end up locking
that all the time yeah every time this
batch runs but if you put it into a
separate table then you could do all
your work in memory and then at the very
end just truncate table and yep does it
in and let's be clear you would never
ever want to try and recalculate these
things on the fly I've heard of of
people who have tried to put enough
space in between left and right like pad
the left and right so that some hundred
in between exactly and you can kind of
fill ins by exactly so like what law was
saying a minute ago where you know he
was one as mom was to his grandma was
three and then so on back up instead of
that he would be he would be 100 she'd
be 200 and then 300 and yeah but then
you still take a hit because you had to
have something on your constraint to be
able to verify like hey have I gone
beyond yet because if i have now it's
time to take the big hit and redo this
out and that's nothing in it take it
even further now the logic you have to
build in to actually determine when you
need to rebuild this thing if it's not
just going to be some sort of time
it's going to be insane so basically
what I'm saying is you'd have to write
incredibly complicated code to manage an
update on something like this whereas
typically what you do is in sequel
server like a way that you will probably
go about this is you do a select into a
new table it's so so that you didn't
lose any any gap of time in between when
this thing is being built and if you
wanted to swap it out like a strategy
that I've seen done is you select into a
new table and then you would do
something like an SP rename to where
it's almost instantaneous you rename the
old table to underscore old and you
rename your new table to what the old
tables name was and then that basically
swaps it in immediately um and let's
let's take it back to it the two primary
reasons for building this table are one
performance in two easy to query right I
mean that's yet there is one other you
know another downside of this that we
haven't mentioned it yet and that's that
you don't have the referential integrity
that you're Jason c-list had right there
like these left right values are just
calculated values they're meaningless
outside of that table yeah like even
that depth column that you talked about
like if you did go with left right and
the depth none of those mean anything
other than what you know within this
table don't that's their only in place
where they provide value yep so and
let's be clear though they are extremely
useful like if you need performance they
are incredible oh yeah the nest set
model you mean yes yeah yeah and also
too I don't think that we mentioned this
but the guy who named it that Joe so co
GI Joe cellco cellco you know he's the
one with a giving credit for having
introduced the name nested set model and
will have shit will have some links in
the show notes to it it's it's once you
see this
some of these imagery to back this up
it'll it'll it'll lock in it'll sink in
a little bit better because I can
understand how like if you're hearing
this for the first time this is going to
be a tad much to understand so that's
why I'm trying to be I'm trying to
explain it as well as I can and I hope
I've done a good job of that lots of
good pictures in the show notes yeah
yeah I mean we'll have to it's but I
mean like everything we do on the
podcast all this stuff is kind of hard
to completely visualize but hopefully
this will give you something to go look
at be like oh if I run across this
problem in the future I have an idea of
how I can solve it right um I've used
nested set tables in the past and I
definitely did them to where their
process like every few hours or whatever
in in situations to where you know you
needed to see things like employees or
even products or things like that um
because the performance gain that you
get out of it is absolutely fantastic
now if you have bad data it can cause
you problems right like if you're a
referential integrity on your on your
real table that contains that data
doesn't do things like check for
circular dependencies or there's gaps
and the data now you have to figure out
what you're going to do with it right
like like typically you're going to look
down from the CEO and then you're going
to have that manager and then their
manager or whatever but what happens
when you have a break somewhere in the
middle where this guy's just kind of
floating he doesn't report to anybody
what do you do with that data right oh
well this is a good thing that we
haven't mentioned though is because that
this by having this data in its own
table right there's nothing to say that
you can't have multiple hierarchies in
red table right so if you're as you're
creating these nest set models right
you're as you're creating the data for
this nessa set model you depending on
your data structure you might have
multiple people who are considered you
know that at the top of their respective
tree and you can have multiples of those
trees yep no that's why tying it back to
the original table where the foreign key
is going to be crucial in that regard so
like in the employee example that I gave
where you would have an employee ID in
this hierarchal you know I think you
referred to it as the employee tree
table so you'd have an employee ID
column that was a foreign key back to
the employee tatis yes oh now one thing
this does not do though and will not
allow you to do is you could not have a
child be a child of multiple parents all
right no so that is there are other
situations and other solutions that
we're going to talk about other models
and well that does kind of confuse the
family tree example that we started with
that okay that's flipping the tree guys
fucking yeah so the way that he actually
created the tree where he was at the top
kind of surprised me because it sounded
like he created his parents but but no
if you were to take it from his
grandparents down you'd see that so like
I could not report to both Michael and
Joe in this type of situation unless you
have the tree upside down but but then
you'd have the inverse problem too um
but that is one thing that this
particular model will not support is a
child can only be a child of one parent
it cannot have multiple parents there
are other models that will allow that
but that's just something to be aware of
yeah and we're going to we're going to
just got like I said we're going to
discuss some other models in coming
episode so we look forward to this as
being you know a fun topic to be able to
dig into so and by the way family trees
start you start it yourself and worked
out I'd ever save every tree like that I
thought the truths always like the
branches came out those are all the kids
and everything right yeah they go down
like when you draw a family tree ok
maybe I'm just crazy I don't know that
I've ever drawn a family treats I'm
probably the worst person to ask about
that oh alright so yeah there are some
other examples we get into materialised
path closure tables you know we're going
to come into these into coming upset so
we're really looking forward to this
yeah it's and I think this is all really
useful information I mean if you ever
cross these paths you'll know some of
the pains that you that you um that you
hit doing this kind of stuff hey it
looks like we lost Joe yeah I don't know
what happened there we've had our first
technical diff our first technical
difficulty on the show which
not too bad a now until now militancy
yes and I reboot the internet down
alright so technical difficulties have
been resolved and we're back yep so I
just wanted to recap the adjacency model
is basically where records sources
parent ID and it's a simple model but
the problem is that it's scales poorly
so as the data size grows it gets slower
and slower and to contrast it with what
we've just been talking about the other
solution we talked about tonight is the
nested set model which is much easier to
query much faster much more elegant but
the problem is that you have to maintain
that data so it's harder on inserts and
updates but it's much quicker for
actually queering that data I agree with
most of that except with maintaining the
data you would just blow it yeah you
want in and you just can't do with that
often right well you could I mean it's
on your batch yeah it could I mean so
like like outlaw said I mean we've had
situations I know he's done it recently
and I've done situations where I had you
know hundreds of thousands if not close
to a million records and you can do it
in under a minute yeah I mean I had it
down to like look within the teens i
think in seconds yes no or huggies low
records so save loads got to be less
than a second right so you wouldn't do
it on the page load that's why you'd
batch it but you might do it every 10
minutes you might do it every five you
might do it every so it's not anything
that you're actually going to be
dependent on a user interaction this is
going to happen in batch behind the
scenes and then you're just going to use
that table for my purpose i was able to
do it like once a day yeah right and and
you know that that's 16 seconds or
whatever you know yeah you wouldn't want
to take that in a web request but 16
seconds you know at 4am the morning who
cares yeah right so even throughout the
day right if nobody's actually using
that code it's just happening and then
you get the benefit by using the table
and we'll have like I said we'll have
some some links to this stuff in the
show notes and you know some imagery to
to help describe it so be sure to check
out the show notes and yeah so let's get
into the resources that we like
yep so um one that I had found a while
back and kind of what sparked a little
bit of this was on SlideShare there was
a nice little thing that it got put
together that was literally several
different types of models for
hierarchical data and we'll go ahead and
link to that one and then one that I had
found years and years ago was Joe cellco
sequel for Smarties that's a book that's
available on Amazon and it's it's really
good i mean if you want to get some mind
benders this is I think we're the first
nested set model thing came into play so
um or at least one of the first
references that I'm aware of so that's
another reference yeah and there's also
a link that will include to stack
overflow where talks about different
options for hierarchical data to that
that gives a really nice concise
overview of different models so we'll
include that as well all right so now it
is time for the tip of the week oh yeah
let's get into it we tip of the month
whatever my idea may I be like that it
hurts okay so so here's the thing like
how well be honest with yourself now how
well do you recall all of your big o
notation totally like like not not just
all the variants but also like the
expense of it which one's better than
another one you have memorized which is
worse which is best like you know
average you know do you remember all of
that right I remember like the time
complexity this is a thing called Big O
there's a lot of it and and it is it is
a bit much to try to remember all of it
so so especially if you don't use it
regularly you know yeah let me out know
how much you know you talk about Big O
notation with your spouse but you know
it comes up every now and then right but
if it doesn't then this is where you
have the Big O cheat cheat com it's
awesome and is this really cool resource
that you can go to in it it
maps it all out you can see which ones
are that you know average performers
which ones are the worst performers
which ones are the best performers for
different it gets into it like for data
structure operations are a sorting
operations graph operations like heap I
mean there's a bulk of different ways
that it talks about you know which
operations perform better and gives
their big o notation for each of those
operations so again Big O cheat sheet
calm and we'll have a link to it in the
sugar yep that's most excellent yeah and
the one I wanted to mention is actually
from let's say they've got a
pronunciation guide div V us as your
website's net has a great setup for
basically the shortcuts they use with
their gaming mouse so we talked about
this a little bit in episode 8 um you
know basically gaming mice have all
sorts of crazy buttons and they've got a
great diagram here it's got maybe I
don't know eight buttons on the side of
their mouth and they show actually the
kinds of things that they have hooked up
to these different buttons so you can
press a single button to build a single
button to step over step into stuff like
that so this is really nice and whatever
that was kind of funny about as if um if
I tried to you know be honest with
myself and kind of setup shortcuts for
myself for things that I actually do
commonly I might have one for like
restarting visual studio I might have
one for you know I can go ahead and add
and commit with a message of I don't
know why this works you know
uninstalling resharper exactly how god
that hurts yeah it hurts even make the
jack troubleshooting now wireless and
the question though how did you say they
perhaps this because if I look at their
URL I got to hear this again yeah it's
on the first the first syllable is the
problem one it's like under
pronunciation guides dih which looks to
me like did but I always thought the
word was devious yeah because when I
look at their URL it's definitely
devious ghosty vyas so how do you
pronounce dih devious yeah I don't know
yeah this is wrong yeah that their their
URL is devious double major websites I
think I just got it it's Devi asst no
but yeah there's actually underneath the
pronunciation there's a definition for
the word which is showing a skillful use
of programming tactics to achieve goals
as in he's a devious as a programmer
needs to be ok ok it's devious all right
yeah I hate that I just said it totally
wrong even though his pronunciation
guide at the very top oh well anyway
it's awesome article and it's got great
pictures and it's great idea excellent
so mine is is because I ran into some
issues or a couple of us ran into issues
recently where we couldn't see
dimensions in a cube oh my god you go
into sequel manager on a hotter hotter
hotter haha you can't you can't bring up
this we haven't even talked about mdx or
cubes not even once and suddenly you're
just going to throw this on us as a tip
of the week i'm going to because anybody
else out there who runs across this will
probably be like Oh hallelu hallelujah
right yeah their brains are melting too
so if you have the misfortune of working
with cubes &amp; M DX and you have to look
at dimensions and things like this ran
across a thing to wear I get this query
from somebody in mdx query that has
these dimensions in it that I can't see
in the cube browser in ssms management
studio and in it it just stomped right
like there's magic here not all know
what this magic is the answer is to get
a data tools I forget what it was I'm a
business of business intelligence data
tools for visual studio and if you
install that you can then open up an
announced the services database within
visual studio and you'll have access to
everything now well basically at that
point you're looking at
what it takes mattituck yelled the cube
yes so super clarity all of them so for
those who aren't familiar with mdx is a
multi-dimensional wine or the X stands
for query I don't know I for you x times
4 but it's a multi-dimensional query
language yeah and it's disgusting it's
it's great and if you wonder like what's
a multi-dimensional query language Excel
yeah it seriously I we're not going to
go to open up our open up Microsoft
Excel and now imagine you know you have
you have your table as your worksheet
but then there are multiple worksheets
within that Bob's you could have
multiple workspaces or workbooks is what
they cry right we could have multiple
Excel files and they could reference
other ones like it's it's truly a 40
space but the key here is if you're not
able to see all the dimensions that you
think you should if you open up the cube
inside Visual Studio using that plug-in
then you will then you will be able to
see all the dimensions and everything
else that went into building that cube
and there was a trick to with this with
this plug-in that you should probably
mention which is if you already have
well you probably already have sequel
server tools installed but it during the
install it's going to bring up your
standard looking sequel server install
GUI and it's going to prompt you hey do
you want to install any kind of add-ons
to an existing instance or do you want
to create a new instance and you're
going to be tempted to say hey I just
want to add onto an existing instance
and because all I want to be able to do
is add in this ability to view cubes but
that's not going to work yeah you will
need to specify a new instance and even
though it sounds like it's going to
create a new instance it's actually not
yeah it doesn't is complete garbage for
you I for install I think that's just
the cost of reusing the regular
installer yeah yeah but um yeah pretty
cool pretty cool information frustrating
that you have to find out that way but
you know
yeah oh oh oh I have one other tip okay
only because he is now witness the
greatness that it is a 34 inch ultra
wide monitor what is your take outlaw I
don't know any time out hey I think he's
gonna try and steal it tonight what you
don't even have one yet he's gonna get
clubbed on you don't even have one yet I
don't know what you're talking about you
keep talking about wanting to buy one
you jealous of mine it's amazing right
you're jealous of mine hey what did you
do when you sat down with visual studio
on that thing well I did what any
self-respecting developer would do I
started tearing off tabs yep yeah i saw
you started nesting so I set up your own
little bat cave dude he had he had four
vertical tab groups on that modern man
it's a beautiful thing i I've never seen
someone have so much fun setting up
vertical tabs he's like look I'm at
third now I'm gonna take away I'll put
two more I I don't know why I'm calling
you out hey I'll tell you guys right now
we're gonna put another I'm gonna link
to it again in the show notes or
somebody's going to that monitor is
glorious like there's no other word for
it it is it's pretty spectacular I'm not
gonna lie like if you there's actually
there's actually include this and share
notes there was a life hacker article
where it was talking about you know
should you go multi monitor or
ultra-wide monitor and they made a
pretty good case for going single ultra
wide and you saw it it's is pretty
amazing yeah I mean it's all good it's
all it's pretty spectacular I'm not
gonna lie yep alright so that's it
alright so we talked about two ways that
you could possibly deal with higher cold
data and in the adjacency list and the
and I said well we're going to beginning
in them more in future episodes so you
know we hope you enjoyed this one and
see what oh no we needed to have a pole
and what should the pole be okay wait no
you go on I had an idea for the Pope me
go on yeah yeah I thought you wrote a
blog post talking about this and that's
how this all kind of came to be but now
I'm not so sure well I did write one
about a product hierarchy and cat
Asura's he and it's actually
surprisingly one of our more popular
articles on the site which is Shia
because I've given it no love since them
but oh so adamant thanks to put this in
the resources we like section but
apparently gets passed by the time or we
don't like it it's one of the 20 so yeah
that's pretty much it for that so um
what about for the PO I'll how long are
you a partner oh yeah so let's do this
on episode slut or cutting box.net /
episode 28 if you go there we're going
to have a poll on there and we're going
to ask you know how long have you been
programming what's your experience level
what's either that or another co-op
tonight happy you can see a ham sammich
phone is pull they just keep around like
whole idea there's another one that I
had to is that a shit Joe move back
there and I think I oh no I think that
we need to change is from pole to survey
oh right okay I'm feeling a little I
don't look okay yeah we'll stop that
right there and surveys filter go survey
all 2 episode 28 please that's this
guide to us on iTunes sister and more
using your favorite podcast app and be
sure to leave us a review on iTunes
stitcher more contact us with a question
or topic leave your name
and preferred method a shout out website
Twitter whatever and we'll be sure to
mention you and visit us at Cody box net
where you can find our show notes
examples discussions and more send your
feedback questions and rants to comments
at coding box.net and be sure to follow
us on twitter at cutting blocks in any
kind of corny jokes that you have we
appreciate that Simmons is late at night
yes especially late nights at coding
blocks just do it we have fun with it so
yeah that's a episode 28 is a wrap
you
hi this is James Cook of the University
of Maine at Augusta and the purpose of
this video is to demonstrate how it is
possible to work with two mode data and
put that in to the AR system where R is
a piece of research software and then
use that to generate to 1 mode networks
describing relations between groups and
relations between people the example
we'll be using involves a special kind
of two mode network one that has to do
with overlapping boards of directors so
I have here a set of membership lists
for corporations members of the boards
of directors of six particular
corporations Apple third ranked in the
fortune 500
Wells Fargo ranked 27 currently then
Nike at 91 and Prudential at 150
Facebook at 157 and Kellogg the food
company at 207 so I've selected those
from the fortune 500 list fairly
randomly but what they provide is a set
of names and that's what I have it's a
membership list for Nike for Apple for
Wells Fargo and so on how can I take
these membership lists and use them to
represent overlapping membership well
the way to do that is through an
affiliation matrix so there are a few
ways that we can enter data on
affiliation matrices in 2r the first is
to enter it directly and to do that I'm
going to describe some hypothetical data
because as we we're going to see very
quickly when you get large amounts of
data simply typing it into our isn't
feasible but for small amounts of data
it's not so bad we're going to work with
the package
and so to activate that we're going to
type in literally library I graph where
I graph is in parentheses if you haven't
installed that package you need to go to
packages and select install packages on
a drop-down menu or you could type in
our console install parentheses I graph
either way should work once you've done
that then you need to make sure that
it's running by typing library
parentheses I graphed in parentheses
then you could literally type in an
affiliation matrix and unimaginative Lee
we could call it affiliation under
square matrix so it's always good to
have your object names when you're going
to create an object like a matrix B all
chubb together no spaces and we're going
to call it a particular kind of object
what kind of object well a matrix object
not surprisingly and it's one in which
we're going to list out rows now
whenever you list in our it's going to
usually involve the I the letter C okay
and so what kind of matrix it's going to
be matrix with a parenthesis and then a
C to indicate a list and here comes the
list we're gonna have another
parenthesis and then we'll get started
and let's actually use the feature in R
which is nice that it doesn't really
care if you have one command on multiple
lines or not so that we have a single
row in each on a line one line per row
because that'll make sense to our eyes
and that's important so let's imagine
that we have nine people and they are
our members of four groups in a town so
those those those people are going to be
the rows and our groups are going to be
so if we had let's say let's let's write
this out first we had a church group and
let's make this large okay
we could have a church group and that
church group might have a membership
list Al Davis Betty Francis Clem Davis
okay and let's just shorten those two
first names just to be useful al Betty
Clem and David and Edna Fran are in the
church and that's six individuals but we
don't just have a church we have let's
come up with another kind of
organization we're going to have a
Rotary Club so the rotary is going to
have a few people in it now Betty is in
the rotary and Clem is in the rotary and
Edna is in the rotary and so is George
and Harry okay so then let's have named
a third organization that organization
might be the Elks Club and let's see we
have a lap there and owls in the Elks
Club
but the Elks Club doesn't let's say that
doesn't let women in and so it's al Clem
David George and Harry who are involved
there and let's add one more
organization Chamber of Commerce now
this one is it's led by Edna and Fran
and their friend eNOS who runs a
business in town
David and Clem are also involved so we
have chambers of commerce we have a
Chamber of Commerce and Elks Club a
Rotary Club and a church each of these
is a membership organization each has
certain number of members some groups
have more members than others but each
group has some and we want to find out
what the overlap is we could type this
information in directly into our how
would we do that well if we imagine over
here that we have a set of individuals
we could have each individual be a row
and each group be a column and we'll
want to call those the dimensions are
calls those the dimensions of a matrix
and so you have rows and columns so
we'll want to enter the names of that
and that that is we can call that dim
names that's a command to set the dim
names the dimension names of what the
affiliation matrix we're going to make
that a list and that list is going to
contain two pieces of information one
row is going to contain the rows and
one's going to contain the columns the
first row contains the the row or the
rows and the second name contains the
columns the labels that we have so we
could say alphabetically we would have
Al and Betty we're gonna put each one of
them in quotes put a comma after each
and then there's Clem and David up we're
going to use our quotes comma Edna
Fran George comma Harry and Ynez okay so
I'm putting that list see is telling you
we have a list and then I'm putting that
in parentheses and then I'm gonna put a
comma after that to indicate we're not
done yet
and that our should expect something
else because we're going to have another
C parentheses with something in it what
is it it's going to be the list of the
columns and those columns might be
church and then the second one was
rotary and the third was Elks and the
fourth was excuse me
Chamber of Commerce remembering that
every item is separated by a comma that
those commas are outside of the
quotation marks and all names are in
quotation marks so we have two lists
each it has has a C to indicate that it
is a list each has parentheses around
them and then there's a list of lists
and so to do that we have the command
list up at the top and it has its own
opening parentheses we have to make sure
that we end that parentheses to finish
that off so knowing that and having that
in our program we can then take the
information and know where each row and
each column is is going to be so we know
that the first column is going to be
about church membership and then the
second columns of giving me about the
rotary the third column is going to be
about the Elks the fourth about the
chamber of commerce and we could go
ahead and take a look at our information
and try to figure out well what does an
owl belong to because alles the first
row
so we know that al belongs to the church
does not belong to the rotary does
belong to the Elks does not belong to
the Chamber of Commerce
so using zeros to indicate no and ones
to indicate yes we would say that in
this first row of the affiliation matrix
yes al is a member of the church no not
a member of the rotary yes one a member
of the Elks but no not a member of the
Chamber of Commerce and then we're going
to continue on another row but we want
to let know R let R know that it has to
continue so we're gonna put a final
comma there and now we're gonna move on
to our second row what's our second row
well dim names dimension names tells us
that's going to be Betty so let's take a
look at Betty well we know Betty's in
the church and the rotary not in the
Elks and not in the Chamber of Commerce
so that would be a 1 for the church a 1
for the rotary a 0 for the Elks and a 0
for the Chamber of Commerce another
comma to indicate hey we're not done
we're going to another row and now who
are we talking about Clem well we know
Clem is in the church Clem is in the
rotary Clem is in the Elks and Clem is
in the Chamber of Commerce
so that's ones yeses for each of these
groups we could enter that in David what
about David let's take a look at David
well David is in the church David is not
in the rotary David is in the Elks and
David is in the Chamber of Commerce so
that would be a 1 0 1 1 to indicate that
everything but the rotary David's
involved with and then finally not
finally Edna our 5th individual is
involved in the church in the rotary
Church in the rotary what are
about the Elks no but is involved in the
Chamber of Commerce and Fran Fran is
involved in the Chamber of Commerce and
the church so we'll have 1 0 0 1 what
about George George is not involved in
the church George is involved in the
rotary and the Elks but not the Chamber
of Commerce 0 1 1 0 Harry is involved
not involved in the Chamber of Commerce
is in the Elks is in the rotary but is
not in the church so it was kind of like
george 0 1 1 &amp; 0
and let's check our rows 1 2 3 4 5 6 7 8
1 2 3 4 5 6 7 8 9 we have one more
that's Ynez so let's see what Ynez is up
to not in the church not in the rotary
not in the Elks but is in the Chamber of
Commerce 0 0 0 1 now we're not going to
put a comma at the end here because we
are done with our matrix instead we'll
just finish off the matrix with an end
parenthesis and then we need to indicate
a few things weren't okay we're not
quite done yet a few things about the
matrix although our eyes tell us what
the number of rows and columns are are
we'll just read this as in as a long
list of ones and zeros so we need to
give it the dimensions so to do that
we're going to tell it that hey the
number of rows and row and ro w okay
with a comma in front of it to indicate
hey here's another piece of information
that equals 9 because there are nine
rows right and oh hey wait there's more
and call equals three and by row equals
true which means that we want this
information to go in by row and that's
just something you need to know then
we're putting off a final end
parenthesis to match the beginning
parenthesis we notice there are two
opening parenthesis to end parenthesis
always look at that and we've got our
names super that will load in our
affiliation matrix and if we then we ask
affiliation matrix to be printed out on
the console by simply typing in
affiliation matrix we should get a
picture of it let's take a look let's
run all of these lines in our script Oh
it's telling me that there is a problem
with the dimension names because the
length is not equal to the array extent
okay so what do I need to do I've made a
mistake what's my mistake can you spot
it because I can I said the number of
columns was three but look here we have
four organizations we have four columns
so whenever you get an error message
okay it's going to give the line right
above it where the error is and you know
you have to do something to fix that up
so let's let's go through and we fix
that end column equals four
I'm going to clear the console so we can
get a nice fresh start and let's run it
again super here's our matrix and it's
that easy to actually put it in well
what happens if we want to work with it
as a two mode matrix and convert it then
into two one load matrices it's not that
hard we have to first tell our to
recognize this as a particular kind of
matrix okay it knows it's a matrix it
knows it has some labels but it doesn't
know what kind it is because R is kind
of it's not that smart you have to tell
it everything
so we're gonna tell it okay look this is
a two mode matrix
we'll give it the object name two mode
Network and then we're going to say hey
this object which we've called two mode
network you could call it anything it's
going to be what are calls an incidence
matrix okay an inch or an incidence
graph which is basically saying hey is
there an incident of Al belonging to a
church an incident of Al belonging to
the Elks Club
what about Ynez there's an incident of
her belonging to the chamber of commerce
that's what our likes to call a kind of
graph called an incidence graph and then
well what's it going to be derived from
it's going to be derived from created
from the affiliation matrix okay and the
name of that object that we created it
is put in parentheses and there's our
command there not too bad
then we could have that printed out when
we do that and we run our script I
notice I didn't put them that right name
in we'll call it two mode Network not
two mode matrix run it again and Wow
there it is okay so it's it's it's it's
given us a number of edges and those
edges are ties from al to a church Betty
to a church Clem to a church so that if
we then plotted it this two mode Network
it would indicate connections between
two different kinds of objects which is
one of the things that in a graph of a
network is
is almost always kind of forbidden on
its own because if you look at that it's
hard to tell except by knowing what the
names are whether you're talking about
an individual person or you're talking
about an organization right elq's is a
four-letter word but you know so is Edna
or Ynez it's not very neat and really a
tie between organizations or a tie
between people is not the same as a tie
between a person and an organization and
as a matter of fact there are some kinds
of ties here that are not possible we
don't measure ties directly between
people or between organizations there
only would be people can only be
connected through organizations
organizations can only be connected
through people okay we we could clean
that up a little bit by trying to do
something before we plot that - mode
Network we could we could take a look at
the type that's there and I'd like to
draw your attention when we print out -
mode Network you'll notice that there
are a couple of lines and it says one of
the attributes is type and the other is
name so it knows that because it's an
incidence a graph or an affiliation
matrix it knows the rows and the columns
aren't the same so it set out some types
to be columns and others to be rows well
we could use that information when we do
our plot that's one thing we could do so
when we do that plot we could change the
vertex color vertex dot color to be set
to an attribute of a node which in in R
is called a vertex s and therefore a V
something about the vertex something
about the V of
of the two mode Network what about it
maybe it's type okay and we could see if
that helps let's see if that helps to
differentiate between the two kinds of
things in a network and let's look for
the graph sure it does
okay so now in our our graph we have
orange being set to organizations and
white being set to people oh that's nice
as far as it goes
that's a two mode Network meaning two
kinds of objects in it but what if we
wanted to study the idea that
organization organizations are tied to
the extent that they have the same
people in common and that people are
tied to each other to the extent that
they have the same organizational
memberships that's an idea of Ronald
bragger that we've covered in the social
networks class and it's also an idea
that's mentioned by sociologist Scott
Feld the focused organization of social
ties is his classic piece of writing
that you could look up and may have read
if you're in my class well how would we
go ahead and do that how would we take
the organization's and look at their
ties where the relationship is number of
people in common how would we look at
people and their connections where it's
the number of organizational memberships
held in common to do that and then say
we don't want to plot this thing anymore
we'll just take that plot out okay we're
going to do something else we're going
to use a command called byte art partite
projection okay we're gonna create
someone mode networks okay and that's
just the name of the object you can call
it
zowie or whatever you wanted to call it
but that's what i'll call the object
here
someone node networks and we're gonna
use the command bipartite dot projection
okay
what does projection mean it means hey
we're only going to look at one one way
of looking at this information one of
the projections is only looking at
connections between people the other is
only looking at connections between
organizations those are two different
projections kind of the ideas like map
projection perhaps and then we'll want
to put in that this is a projection of
our two mode network and parentheses
what's the bipartite mean it means it's
a bipartite means that there are two
kinds of objects in it it's just a
synonym for that it's highfalutin
language and sometimes our likes to use
that incidence graphs and bipartite
projections well we could do that and
then we could actually ask or to print
them out for us one mode networks please
let's run that under edit run all and
then let's see what it came up with look
now it's created two sets of uh ties
okay and it's it's it can't it's not
trying to fit them all in there for for
for the people because there's a lot of
ties but it is able to fit them all in
for the organization's
two projections they are called if you
notice dollar sign prods one which is
the connections between people and
dollar sign prods to the connections
between the organizations why are they
called dollar sign proj one and dollar
sign proj two while dollar sign means an
attribute of an object and so the
projection is an attribute and project
one is the first projection project two
is the second projection it's just
something you need to remember a little
bit but if you print
the network it'll remind you what those
things are and then each of those
projections itself has attributes right
it has the names of the vertexes the
names of the nodes in social network
analysis parlance and then it also has a
thing called weight okay and the weight
is the information that would indicate
how many shared memberships there are or
how many shared people there are okay so
how would we then print that out as a
set of to mode excuse me - one mode
matrices ones that look like just
classic adjacency matrices the first
ones you learned about in these classes
well to do that we're gonna say use the
command get dot adjacency we've used
this command before but we're gonna get
an adjacency from what from our one mode
networks but each time we're gonna say
hey we only want one part of it which
part do we want well first let's try
proj one and we want it to be filled
with zeros where there are zeros which
means that we set that option sparse
equal to false and what would we like to
be in the cells well we'd like to use
that attribute weight so attr equals in
quotations weight and we might think
about doing the same thing for the
second projection and what I've done is
copied and pasted that command except
this time I'm just gonna look for proj
to print the second projection now when
I run this whole set of commands under
edit run all it's gonna show me all a
nice handy set of connections between
the nine individuals
there's our classic adjacency matrix
and another classic adjacency matrix
describing the connections between
groups super what could be simpler oh
and if we wanted to create then from
these we wanted to create graphs network
graphs pictures of these one mode matrix
matrices well we could simply use the
plot command and say let's plot one of
these one mode networks which one oh how
about the one between individuals okay
and we could just simply run that plot
it's not going to quite be right when we
do that let's let's see what happens
when we run that and then we look at the
graphics window there they all are
and we know that there are connections
between many of them that's that's super
however it's not quite right because it
doesn't have the weights in it so let's
include information about the tie
strength the the numbers that are in
these cells so that we would know that
Alan Betty are in one group together but
Alan clemmer and two groups go out of
their clan and David are in three groups
together we want to be able to indicate
that and we could indicate that by
adding a few options the first is that
we could simply add an edge label edge
label and we could make that equal to
okay and this is again just something
from a previous lesson that you've just
learned we need to use the syntax is the
uppercase letter E and then parentheses
1 mode networks which one the first
projection and what attribute of that
well dollar sign wait okay so that e
parenthesis 1 mode networks or
projection one dollar sign wait means
let's take the attribute of weight from
first projection the persons by person's
matrix and let's use that to label the
network let's see what happens when we
run that okay then when we look at the
graphics window we have a series of
numbers
hey that's super we could do it another
way we could say hey we could denote
high strength through edge width how
wide each line is and we could set that
equal to the same thing if we wanted to
whoops and I have two equal signs I need
to get rid of one of them and we could
run that and you'll notice that the
lines that are thicker are the ones that
also have the larger numbers so that
thickness draws our eye to them it's a
nice form of visualization and that's
that's a nice option too
finally we'll notice a lot of those
numbers are really close to each other
and sometimes it's hard to figure out
which one is associated with which line
especially right in the middle of that
graph so how could we work with that
well we know by curving lines sometimes
it's easier to follow the trend a little
bit and and to figure out okay I know
where this is going to and I know where
it's coming from different people have
different preferences about that and
this in this way it becomes a matter of
style but we could set an attribute of
the plot to be edge dot curved equals
curved equals true to say yes we do want
the these edges to be curved these ties
to be curved there's always a lot of
synonyms vertices are nodes ties our
edges depending on which brand of math
or social network analysis you're
talking about so if we run that
okay now some people may say this is
more confusing some people may say this
is less confusing but if you run it
every time you get a slightly different
picture and you can run it a few times
until you like the one you have the one
you like you can even pick a different
layout using options that we have before
but that's nice by the way once you've
created that plot command if you want to
look at the second projection all you
have to do is everywhere where it says
proj 1 we have it set now to proj to
just change the 1 to a 2 and what will
you get run it and you get a description
of the connections between the groups so
here the church in the key chamber of
commerce have four members in common the
Elks and the Chamber of Commerce only
have two in common so the church and the
Elks have three in common and so on and
so forth we can very quickly once we've
got all these commands down we could do
all sorts of things to indicate
different kinds of graphs for different
kinds of objects and that's kind of
powerful we could even go back and we
can go back and say later what if we
have a faith organization we could just
add that to the dimension names what
will we call it we'll call it the
bowling lead okay some people who get
together and go bowling and then we'd
need to change the number of columns to
five and then we might talk about who's
in the bowling league maybe al and Betty
are so we'd add that for our fourth
column clam and David don't like to go
bowling but boy Edna sure loves to go
bowling frame gets pulled along often
come on Fran let's add in a 1 there
George does not like bowling very much
open we'll put a comma there Harry
doesn't like
it very much but Ynez does okay and
remember in the last line we don't want
a comma because we're saying hey are
we're done there's no more information
so it's very easy to modify this script
and then when we run it to add new
information there's the bowling league
and if we change the plot at the end
here is our graph of the connections
between people and it's slightly
different now because there are new
connections that have been made through
the this bowling league they are
reflected again in our matrices the the
bowling league is included now you'll
notice now that we have these long
titles that it needs to go to a second
line it's okay for it for this is for
the organization's by organizations
matrix it's okay if it's on two lines it
just means it didn't have enough space
so that's one way to go about it and
that's super if you had bowling
information okay and it was just a few
people but you might see that it would
get really difficult to work with this
matrix if you had a large number of
people and a large number of
organizations you could lose your way in
just simply typing in that matrix
information and you might make mistakes
so there's a different way to go about
entering that information and let's take
a look at that and that is by starting
with a spreadsheet so now we're going to
go from hypothetical information to real
information these are real pieces of
information about boards of directors
which are governing boards for
corporations so let's start with them
and let's enter that data it's real data
and let's see what the connections
between people are and
the connections between organizations
might be so we'll start with Nike and
we're going to give every column and
then Apple and then we're going to give
every column to a corporation and then
Kellogg ogg and then we'll go to Wells
Fargo not Wells Fargo but Wells Fargo
argh oh and then finally Prudential okay
and then every row will be a different
person so if we look at Nike and we will
put these in these this is Philip night
and we're gonna put in a 1-under Nike to
indicate that yes Philip Knight is a
member of Nike let me make this a little
larger so that you can see it okay and
then we're going to take that first row
and under the view I'm gonna freeze it
to the top so that no matter what I'm
doing you can always see that first row
of heading and then let's also make
these labels a bit yes a bit wider now
you can see everything we know Philip
Knight is in Nike we don't yet know
about the other ones
we'll put zeros in there just in case
and we'll go back and fix it if we
notice Philip Knight again mark Parker
is in Nike and we'll assume for now is
not in any of these other corporations
Elizabeth Tom stock is in Nike
and John Connors Timothy Cook John dawn
Donahoe Alan Graf Travis Knight just
writing these names down John left
lighter Michelle hellooo so Jonathan
Rogers and John Thompson and Phil less
wise each of them is on the Nike Board
but we don't know anything else about
any of the other corporations they might
be on yet so we're gonna put in zeros
for all these individuals for all these
other corporations and we'll come back
and change it if we find something else
something to the contrary
so that's Nike that's it it's in what
about Apple well there's someone named
Timothy cook who's on the board of Apple
oh it is the same Timothy Cook
so we'll put a 1 there remember each
person only has one row even if they
appear in multiple memberships so
there's an instance of overlap someone
named Arthur Levinson don't see that
person there so Arthur Levinson is not
it was not in Nike but is an Apple and
we're assuming nothing is involved there
in terms of the other corporations yet
we'll go back and change it as we go
through the lists we know James Bell
this is again just from our lists is not
on Nike because it's not up listed up
there but is on Apple and Albert Gore
yes that Albert Gore former vice
president is not on Nike but is on Apple
and we don't know about those other
corporations yet Robert Iger that's a
new name not on Nike is on Apple Andrea
young not on Nike is on Apple so you can
skip ahead in this video I'm gonna
continue at a pace ronald sugar great
name but is not on the Nike board is on
the Apple board you can skip ahead until
I finish this process and just check
back in every once in a while to see how
it's coming along excusing Wagner not on
Nike is on Apple well that's it for
Apple so I worked through Nike I've
worked through Apple who's next
Kellogg is the Kellogg list so I'm
taking an actual physical list this is
actually taken off the Kellogg website
you can usually look in an investor
relations link and I'm gonna need to
start checking as I go John Bryant hmm
well we know that person is not in Apple
because I don't see them there what
about on Nike hmm no they don't appear
there I had to go back and check but
there's nobody in Apple Nike nobody
named John Bryant in Nike or Apple but
they are in Kellogg okay go back and
check again if I need to and we don't
know anything about them being in Wells
Fargo or Prudential Stephanie burns
that's another new name and John Dylan
another new name Richard dry link
another new name
Zachary gund might've remember that but
you could check it's a new name
Jim Gen s another new name is in Kellogg
we don't know about Wells Fargo and
Prudential we'll check on them according
to the list later but we know they're
not in Nike and Apple or that Jim isn't
what about Donald Mouse nope
and I could always go back and check no
Donald Mouse up in that list good so I
can continue Mary
there was another Mary I know that
because okay or a mark right but here's
a Mary lash injure okay and that person
is new Nike and Apple zeros but one for
Kellogg is a member there
Cynthia mill again let's go to the
Milligan no not on Nike or Apple but yes
is on Kellogg and here's an interesting
name Virgilio
Red Bull a though that's a new one only
on Kellogg so far as we know so far
la jeune Montgomery tebron again a
memorable name
Kellogg's the first time we've heard of
that individual as a board of directors
on the board of directors Carolyn tossed
ad that's another new person and finally
Noel Wallace
so for Kellogg we noticed that boy all
those people don't seem to be on the
Nike or Apple boards
what about when we get to Wells Fargo
okay that's our next list you can see
the list is getting really long and it's
a good thing that we've got the labels
for the columns and the rows otherwise
we'd be lost this is why a spreadsheet
is useful and we're gonna have a whole
new list of names John Baker
haven't heard that name up before not in
Kellogg and not on Apple or Nike but yes
for Wells Fargo Elaine Chao yet another
new name John Chen another new name
Lloyd Dean Elizabeth there's an
Elizabeth Comstock it tries to
automatically complete it but no we mean
Elizabeth Duke that's another new name
and Susan angle and the Ricky Hernandez
Hernandez not a new individual ok Donald
James there's a Donald Moss it tries to
automatically complete but no we mean
Donald James who is new to Wells Fargo
and not those other corporations Cynthia
Oh Cynthia Milligan let's go back up
there so it auto-completed that's a nice
feature of Excel and this person was in
Kellogg and is in Wells Fargo okay so
we've gone up there made sure his name
thing Milligan
Cynthia Milligan only gets one row what
about Frederico Pina okay a former
individual and a White House cabinet but
not in any of the others James Bell this
is only one Jane so far but note we're
looking for Quigley James Quigley is on
the Wells Fargo Board of Directors
that's a new person and Steven that was
trying to be Stephanie but note we're
looking for a Steve and this must be the
first Stephen Sanger
zero zero zero one zero the one being
for Wells Fargo
Timothy Sloane there's a Timothy cook
but now we're referring to Timothy
Sloane a different Timothy and seasoned
Swenson you can tell we're getting down
toward the end this is the new person
because we're at the esses this is an
alphabetical list and Suzanne no other
Suzanne VA UT RI and ot without your
note I think it may be a French name
okay
and finally we've got Prudential which
so far is a bunch of zeros are there any
names on this list that include
individuals up above we'll find out and
then we'll be done but you can see all
these don't fit on one page it would be
way too much for us to put in accurately
and completely just typing it right into
our so let's take a look at Thomas
Baltimore that's a new name and is a1 in
the last column for yes is in Prudential
Gilbert casteless zero zero zero zero
one
James cullin zero zero zero zero one
mark not Parker three zero zero zero
zero one Martina
hunt me Jean zero zero zero zero one
Carl
no Carl's so far right okay so this is
the first carl carl crop ik
zero zero zero zero one these are
corporate leaders remember so we're
talking about connections between
corporate boards and between corporate
leaders Peter light zero zero zero zero
one okay George
pause that's a new person
Prudential but on none of the other
boards Sandra Pianalto zero zero zero
zero one Christine no other Christine so
far
Christine poon is not on Nike or Apple
or Kellogg or Wells Fargo but is a
member of the board of directors for
Prudential what about Douglas Skov an er
no that's a new individual to John
strange out a member of the board of
Prudential but not others and finally
Michael Todman zero zero zero zero one
Wow
we're finally at the end we have a list
of how many 60 members of all these
boards across five different boards okay
and that's a that's a large number of
boards it's a good number to work with
I'm gonna ask you to work with I believe
six if you're a student of mine working
in an assignment and to see what kind of
connections occur between these
corporations and between the individuals
who run them so you might imagine that
some of these connections might be
tighter if you include more groups that
they could be members of and that might
be the case but I just want you to get a
taste of what working with real-world
Network data looks like well we need to
save this and remember the universal
format for a spreadsheet for data that
can be read by not just spreadsheets but
other kinds of spreadsheets or by
research programs called are is a format
called CSV so we're going to go up to
file
and then we're going to click save as
and I'm gonna want to save this in my
social networks our folder as a CSV and
I'm gonna call it five corporations dot
dot what not Excel workbook I'm gonna
select down under save as type and I'm
gonna look for csv comma-delimited csv
and so we'll save it as five
corporations dot csv yep i want to keep
using that format now it's done now i
need to load it in well you already know
how to load in a csv file if you've been
following the videos in this series and
it's pretty simple and actually we can
take and cannibalize this script which
maybe we'll save first always save your
scripts and every time you make a
difference or it may be a de add a
change save it under a different name so
that you can always go back to what you
had let's save this original script as
in the right folder we'll call it sample
affiliation matrix and then we're gonna
change it we're not going to type in the
affiliation matrix anymore okay and
we're not going to have to type in the
dimension names of the affiliation
matrix because they're included already
so we're going to leave that part
instead our affiliation matrix is going
to be grabbed by using the command read
at CSV which tells our to go look for a
CSV file and to do that by choosing a
file using the file choose option it
doesn't have a header yes it does a
header is
first row of in which the column names
are listed and does it have row names oh
yes and the way to say that is by
indicating that road names equals one I
believe you could also say true and it
would work as well and then the magic of
our script let's save it under a new
name which is let's call it and social
networks in the our folder let's call it
the corporate network example and our
script is saved is that all the commands
afterward after we've read this in are
going to be exactly the same we're gonna
go read it in and then once we read it
in you'll always have to say to our hey
remember what this in a kind of object
this is so we might actually call our
original data affiliation data and then
the name of the network itself as an
affiliation matrix is going to be
reading the data as matrix as a matrix
reading the affiliation data okay
because are always reads in numbers it
doesn't know what the numbers mean here
you're telling it hey it's a matrix and
then later on below you're going to be
telling it hey that matrix is the
special kind of matrix the graph
incidence and then you're going to say
hey you could do a bipartite projection
of it in 2 2 1 mode networks and so on
and so forth all those things down there
below are the same but we replaced that
complicated entry of the affiliation
matrix data with just saying hey let's
look for a CSV file let's save it and
then let's run it and see what happens
hopefully it works we'll run it
and then there's been a bit of a problem
it should have prompted us for okay it
tells us there's an error up here let's
look for it okay so let's go back up and
look for that error and let's read the
whole thing it's telling us that file
must be a character string or connection
it's possible oh I left out a little bit
of syntax
if file choose has after it a beginning
parenthesis and end parenthesis that
means you choose a file and we'll stick
it inside those parentheses why it's
just the way our works and you have to
get the syntax just right so I always
make syntax errors all the time the key
is if things don't run out as you'd
hoped you go back and you look for error
messages and you know oh you have to go
back and check and make sure that you
don't have a typo let's clear the
console up now so that it's nice and
clean and let's try running it again ah
there we are
okay so now let's go to our social
networks folder and the our subfolder
and let's look for that CSV what was it
called it was called five corporations
wasn't it five corporations and what's
the type it's a comma delimited
separated file so it's a CSV good I
think we should try it let's see what
happens okay check it out here in our
our console we've got a description of
an adjacency matrix for the corporations
so that Nike is connected to Apple and
Kellogg's is connected to Wells Fargo
we've got a set of connections Wow this
is a lot of connections here
right between all these individuals it's
such a big Jason C matrix that it's
running over again and again and again
just three columns at a time and it's
gotten a lot of ones and zeros indicated
people who are some who are tied to one
another and some who are not that's
super ok so now that we have this
information we can then look and see did
we get a graphic yeah we sure did okay
now we'd have to visualize this a little
bit but we're starting to see some
interesting things we're seeing one two
three four five clusters those clusters
are referring to in corporations where
everyone in the corporation is of course
tied to each other because they share
one membership there but then you'll
notice up here between the top four
there's an individual who stands in
between them who is a conduit between
these corporations Timothy Cook is a
conduit between Apple and Apple and Nike
I believe yes and Cynthia Milligan is a
connection between which corporations
Wells Fargo and Kellogg so individuals
are connections between corporations
cool we could change the plot again
changing proj one which is always the
rows by rows and now let's go columns by
columns which is in this case is
corporations by corporations that's
running again and see what we get as we
go look at our social networks our data
and it's called five corporations right
there it is alright and now we see that
Prudential doesn't have any corporate
leaders in common with any of these
other corporations or board members at
least Wells Fargo in Kellogg have one
board member in common Apple and Nike
have one board member
common and it's visualized to show us
that Prudential is what we would call an
isolate in this network at least what
would happen if we added another
corporation would it indicate that other
corporation indicates some connection
perhaps that corporation would be
connected to both Prudential and Wells
Fargo I don't know because I haven't
looked at the data this new data which
is current as of 2016 by the way you
could find out what I want you to do is
I want you to take corporations from the
fortune 500 find the fortune 500 website
the list of those corporations then go
to the corporate websites find the lists
of boards of directors for each
corporation they should be publicly
listed on the websites and do the same
thing see what you find
for your set of I believe six
corporations create a two-mode
affiliation matrix create some adjacency
matrices out of them create some graphs
and where you need to visualize to work
out some some oddities in presentation
go ahead and work through some
visualization options I'm really
interested to see what you find
if you're a student of mine even if
you're not a student of mine please feel
free to send on some data you get this
way to me at James M cook at maine.edu
and I'd love to see it and I'd love to
see what you're able to do our is
becoming as we can see a really powerful
platform for taking immense amounts of
data
many many rows many many columns and
summarizing it in a way that makes sense
to our eyes and a way that is organized
for us to do things with in the future
best of luck and please let me know if
you run into any problems I would be
glad to help again get in touch with me
at James M Cooke at Mimi D you
the graph data structure is not the same
as a graph you may have learned about a
math class graphs are collections of
things and the relationships or
connections between them the data in a
graph are called nodes or vertices the
connections between the nodes are called
edges one example of graphs is a social
network where the nodes are you and
other people and the edges are whether
two people are friend with each other
there are two major types of graphs
directed and undirected undirected
graphs are graphs without any direction
on the edges between nodes directed
graphs are graphs with a direction and
its edges an example of an undirected
graph could be a social network the
nodes are people and the edges are
friendships an example of a directed
graph could be the internet and web page
links the nodes are web pages and the
directed edges are links to other pages
which might not necessarily point the
other way I'm going to show you three
ways to represent a graph the first way
is called an adjacency list this
representation for a graph associates
each vertex in the graph with the
collection of its neighboring vertices
or edges in this image a is connected to
B B is connected to a and C and C is
connected to B this is how you could
show a relationship with texts and here
is how you could show this adjacency
list with JavaScript this is an
undirected graph because it does not
show the direction of the edges this can
also be more simply represented as an
array where the nodes just have numbers
rather than string labels another way to
represent a graph is to put it in an
adjacency matrix an adjacency matrix is
a two-dimensional array where each
nested array has the same number of
elements as the outer array so it's
basically a matrix of numbers where the
numbers represent the edges zeroes means
there is no edge or relationship and one
means there is a relationship this table
shows an adjacency matrix to represent
the image you can see that the labels
for the nodes are on the top and left
now here's a JavaScript representation
of the same thing unlike an adjacency
list each row of the matrix has to have
the same number of elements as nodes in
the graph here we have a 3 by 3 matrix
which means we have 3 nodes our graph
and adjacency matrix can be used to
represent a directed graph here's a
graph where the second node has an edge
pointing toward the first node and then
the third node has an edge pointing to
the first node notice how the numbers in
the array change there are only ones
where a node is pointing toward another
node and since there are only two points
there are only two nodes the final way I
will show to represent a graph is an
incidence matrix like the adjacency
matrix and incidence matrix is a
two-dimensional array however the rows
and columns means something else here
the adjacency matrix use both rows and
columns to represent nodes and incidence
matrix uses roads rose to represent
nodes and the columns to represent edges
this means that we can have an uneven
number of rows and columns each column
will represent a unique edge also each
edge connects two nodes to show that
there is edge between two nodes you will
put a 1 in the two rows of a particular
column as you can see in the diagram
edge 1 is connected to nodes a and B now
look at the column for edge 1 in the
incidence matrix table you will see a 1
in both the a row and the B row this
shows the edge 1 connects the nodes a
and B here is a directed graph for a
directed graph use negative 1 for an
edge leaving a particular node and 1 for
an edge entering a node and here is a
JavaScript implementation of the
incidence matrix graphs can also have
weights on their edges so far we have
unweighted edges where just the presence
and lack
of edges binary zero one you can have
different weights depending on your
application a different way is
represented as a number greater than one
well now you know about different types
of graphs and how to represent them in
JavaScript in my next video about graphs
I will cover graph traversal algorithms
thanks for watching my name is Bo Carnes
don't forget to subscribe and remember
use your code for good
we are going to look at using adjacency
lists in graph theory so let G be a
simple graph at the vertex set v1 v2 v3
v4 v5 so void for 5 vertices and that is
the adjacency list there v1 is a
neighbor of is adjacent to v2 v3 v4 v2
is adjacent to v1 v3 v4 v5 and so on
what we have to do here is answer the
two following questions first off list
the degree sequence of G so let's see
that one first so v1 is connected to
three vertices so 3 and v2 is connected
to 4 so there's four three three and one
so how do we write at the degree
sequence we write it out as follows for
in descending order there you have it
there in descending order four three
three three and one so now let's look at
drawing the graph here so I'm going to
sort of set it up here as follows
so we have five vertices this is v1 v2
v3 v4 and V 5 and let's see how they
connect up to one another so v1 is
connected to v2 v3 and v4 so that
connects there there and down there v2
is connected to all of the other four
vertices so it's already connected to
one there so it's connected to be three
it's connected to be five and it
connects to vie for v3 and v4 so we've
already connected it to v1 and v2 so all
that remains is just connected to be
four down there just going to color the
vertices back in here plus a v4 is
connected to v1 v2 and v3 so we've
actually have taken care of all of those
already lastly v5 is connected to v2 and
again that has also been connected
already 2v2 so that there is the graph G
and that ends our presentation thank you
so in our previous lesson we talked
about adjacency matrix as a way to store
and represent graph and as we discussed
and analyzed this data structure we saw
that it's very efficient in terms of
time cost of operations with this data
structure it costs Big O of 1 that is
constant time to find if two nodes are
connected or not and it costs Big O of V
where V is number of vertices to find
all nodes adjacent to a given node but
we also saw that adjacency matrix is not
very efficient when it comes to space
consumption we consume space in order of
square of number of vertices in
adjacency matrix representation as you
know we store edges in a two-dimensional
array or matrix of size V cross V where
V is number of vertices in my example
graph here we have eight vertices that's
why I have an 8 cross 8 matrix here we
are consuming 8 square that is 64 units
of space here now what's basically
happening is that for each vertex for
each node we have a row in this matrix
where we are storing information about
all its connections this is the row for
the zeroth node that is a this is the
row for the one at node that is B this
is for C and we can go on like this so
each node has got a row and a row is
basically a one dimensional array of
size equal to number of vertices that is
V and what exactly are we storing in a
row let's just look at this first row in
which we are storing connections of node
a this two-dimensional matrix or array
that we have here is basically an array
of one-dimensional arrays so each row
has to be one dimensional array so how
are we storing the connections of node a
in these eight cells
this one-dimensional array of size 8/0
in the zeroeth position means that there
is no edge starting a and ending at zero
at node which again is a an edge
starting and ending at itself is called
a self loop and there is no self loop on
a of 1 in 1 its position here means that
there is an edge from a to 1 at node
that is B the way via storing
information here is that index or
position in this one-dimensional array
is being used to represent endpoint of
an edge for this complete row for this
complete one-dimensional array start is
always the same it's always the zero at
node that is a in general in the
adjacency matrix row index represents
the start point and column index
represents the end point now here when
we are looking only at the first row
start is always a and the indices 0 1 2
and so on are representing the endpoints
and the value at a particular index or
position tells us whether we have an
edge ending at that node or not one here
means that the edge exists 0 would have
meant that the edge does not exist now
when we are storing information like
this if you can see we are not just
storing that b c and d are connected to
a we are also storing the knot of it we
are also storing the information that a
e f g and h are not connected to a if we
are storing what all nodes are connected
through that we can also deduce what all
nodes are not connected these zeros in
my opinion are redundant information
causing extra consumption of memory most
real-world graphs are sparse that is
number of connections is really small
compared to total number of possible
connections so
so often there would be too many zeroes
and very few ones think about it let's
say we are trying to store connections
in a social network like Facebook in an
HSN C matrix which would be the most
impractical thing to do in my opinion
but anyway for the sake of argument
let's say we are trying to do it just to
store connections of one user I would
have a row or one dimensional matrix of
size 10 to the power 9 on an average in
a social network you would not have more
than thousand friends if I have thousand
friends then in the row used to store my
connections I would only have thousand
ones and rest that is 10 to the power 9
- thousand would be zeros and I'm not
trying to force you to agree but just
like me if you also think that these
zeros are storing redundant information
and our extra consumption of memory then
even if we are storing these ones and
zeros in just one byte as boolean values
these many zeros here is almost one
gigabyte of memory once are just 1
kilobyte so given this problem let's try
to do something different here let's
just try to keep the information that
these nodes are connected and get rid of
the information that these nodes are not
connected because it can be inferred it
can be deduced and there are a couple of
ways in which we can do this here to
store connections of a instead of using
an array such that index represents
endpoint of an edge and value at that
particular index represents whether we
have an edge ending there or not we can
simply keep a list of all the nodes to
which we are connected this is the list
or set of nodes to which a is connected
we can represent this list either using
the indices or
using the actual names for the nodes
let's just use indices because names can
be long and may consume more memory you
can always look at the vertex list and
find out the name in constant time now
in a machine we can store this set of
nodes which basically is a set of
integers in something as simple as an
array and this array as you can see is a
different arrangement from our previous
array in our earlier arrangement index
was representing index of a node in the
graph and value was representing whether
there was a connection to that node or
not here index does not represent
anything and the values are the actual
indices of the nodes to which we are
connected now instead of using an array
here to store this set of integers we
can also use a linked list and widest
array or linked list I would argue that
we can also use a true here in fact a
binary search tree is a good way to
store a set of values there are ways to
keep a binary search tree balanced and
if you always keep a binary search tree
balanced you can perform search
insertion and deletion all three
operations in order of log of number of
nodes we will discus cost of operations
for any of these possible ways in some
time right now all I want to say is that
there are a bunch of ways in which we
can store connections of a node for our
example graph that we started with
instead of an adjacency matrix we can
try to do something like this we are
still storing the same information we
are still saying that zero at node is
connected to one at two it and three at
node 1 at node is connected to 0 at 4th
and 5th node to ethno disconnected to 0
at and sixth node and so on but we are
consuming a lot less memory here
programmatically this adjacency matrix
here
is just a two-dimensional array of size
8 cross 8 so we are consuming 64 units
of space in total but this structure in
right does not have all the rules of
same size how do you think we can create
such a structure programmatically well
it depends in c or c++ if you understand
pointers then we can create an array of
pointers of size 8 and each pointer can
point to a 1 dimensional array of
different size 0 8 pointer can point to
an array of size 3 because 0 8th node
has 3 connections and we need an array
of size 3 one at pointer can point to an
array of size 3 because one it's node
also has 3 connections to it node
however has only 2 connections so 2 its
pointer should point to an array of size
2 and we can go on like this the 7th
node has four connections so 7th pointer
should should point to an array of size
4 if you do not understand any of this
point to think that I am doing right now
you can refer to my code schools lesson
titled pointers and arrays the link to
which you can find in the description of
this video but think about it the basic
idea is that each row can be a
one-dimensional array of different size
and you can implement this with whatever
tools you have in your favorite
programming language now let's quickly
see what are the pros and cons of this
structure in the write in comparison to
the matrix in the left
we are definitely consuming less memory
with the structure in right with
adjacency matrix our space consumption
is proportional to square of number of
vertices while
the second structure space consumption
is proportional to number of edges and
we know that most real-world graphs are
sparse that is the number of edges is
really small in comparison to square of
number of vertices square of number of
vertices is basically total number of
possible edges and for us to reach this
number every node should be connected to
every other node in most graphs a node
is connected to few other nodes and not
all other nodes in the second structure
we are avoiding this typical problem of
too much space consumption in an
adjacency matrix by only keeping the
ones and getting rid of the redundant
zeros here for an undirected graph like
this one we would consume exactly two
into number of edges units of memory and
for a directed graph we would consume
exactly ethat is number of edges units
of memory but all in all space
consumption will be proportional to
number of edges or in other words space
complexity would be Big O of e so the
second structure is definitely better in
terms of space consumption but let's now
also try to compare these two structures
for time cost of operations what do you
think would be the time cost of finding
if two nodes are connected or not we
know that it's constant time or Big O of
1 for an adjacency matrix because if we
know the start and end point we know the
cell in which to look for 0 or 1 but in
the second structure we cannot do this
we will have to scan through a row so if
I ask you something like can you tell me
if there is a connection from node 0 to
7 then you will have to scan this zero
at row you will have to perform a linear
search on this zero eighth row to find
seven right now all the rules in this
structure are sorted you can argue that
I can keep all the rules sorted and then
I can perform a binary search which
would be a lot less costlier that's fine
but if you just perform a linear search
then in worst case we can have exactly V
that is number of vertices cells in a
row so if we perform a linear search in
worst case we will take time
proportional to number of vertices and
of course the time cost would be big-oh
of log V if we would perform a binary
search logarithmic runtimes are really
good but to get this here we always need
to keep our rows sorted keeping an array
always sorted is costly in other ways
and I'll come back to it later for now
let's just say that this would cost us
big o of V now what do you think would
be the time cost of finding all nodes
adjacent to a given node that is finding
all neighbors of a node well even in
case of adjacency matrix we now have to
scan a complete row so it would be Big O
of V for the matrix as well as this
second structure here because here also
in worst case we can have V cells in a
row equivalent to having all ones in a
row in an adjacency matrix when we try
to see the time cost of an operation and
we mostly analyze the worst case so for
this operation we are Big O of V for
both so this is the picture that we are
getting looks like we are saving some
space with the second structure but we
are not saving much on time well I would
still argue that it's not true when we
analyze time
complexity we mostly analyze it for the
worst case but what if we already know
that we are not going to hit the worst
case if we can go back to our previous
assumption that we are dealing with a
sparse graph that we are dealing with a
graph in which a node would be connected
to few other nodes and not all other
nodes then the second structure will
definitely save us time things would
look better once again if we would
analyze them in context of a social
network I'll set some assumptions let's
say we have a billion users in our
social network and the maximum number of
friends that anybody has is 10,000 and
let's also assume computational power of
our machine let's say our machine or
system can scan or read 10 to the power
6 cells in a second and this is a
reasonable assumption because machines
often execute a couple of millions
instructions per second now what would
be the actual cost of finding all nodes
adjacent to a given node in adjacency
matrix well we will have to scan a
complete row in the matrix that would be
10 to the power 9 cells because in a
matrix we would always have cells equal
to number of vertices and if we would
divide this by a million we would get
the time in seconds to scan a row of 10
to the power 9 cells we would take
thousand seconds which is also sixteen
point six six minutes this is
unreasonably high but with the second
structure maximum number of cells in a
row would be 10,000 because the number
of cells would exactly be equal to
number of connections and this is the
maximum number of friends or connections
a person in the network has so here we
would take 10 to the power 4
10 to the power 6 that is 10 to the
power minus 2 seconds which is equal to
10 milliseconds 10 milliseconds is not
unreasonable now let's try to deduce the
cost for the second operation finding if
two nodes are connected or not
in case of adjacency matrix we would
know exactly what cell to read we would
know the memory location of that
specific cell and reading that one cell
would cost us 1 upon 10 to the power 6
seconds which is 1 microsecond in the
second structure we would not know the
exact cell we will have to scan a row so
once again maximum time taken would be
10 milliseconds just like finding
adjacent nodes so now given this
analysis if you would have to design a
social network
what structure would you choose
no-brainer
isn't it machine cannot make a user wait
for 16 minutes would you ever use such a
system milliseconds is fine but minutes
it's just too much so now we know that
for most real-world graphs this second
structure is better because it saves us
space as well as time remember I am
saying most and not all because for this
logic to be true for my reasoning to be
valid graph has to be sparse number of
edges has to be significantly lesser
than square of number of vertices so now
having analyzed space consumption and
time cost of at least two most
frequently performed operations looks
like this second structure would be
better for most graphs well there can be
a bunch of operations in a graph and we
should account for all kind of
operations so before making up my mind I
would analyze cost of few more
operations what if after us two
during this example graph in computer's
memory in any of these structures we
decide to add a new edge let's say we
got a new connection in the graph from A
to G then how do you think we can store
this new information this new edge in
both these structures the idea here is
to assess that once the structures are
created in computer's memory how would
we do if the graph changes how would we
do if a node or edge is inserted or
deleted if a new edge is inserted in
case of an adjacency matrix we just need
to go to a specific cell and flip the
zero at that cell to 1 in this case we
would go to 0-8 row and sixth column and
override it with value 1 and if it was a
deletion then we would go to a specific
cell and make the 1 0 now how about this
second structure how would you do it
here we need to add a 6 in the first row
and if you have followed this series on
data structures then you know that it's
not possible to dynamically increase
size of an existing array this would not
be so straightforward we will have to
create a new array of size 4 for the
zeroth row then we will have to copy
content off the old array write the new
value and then wipe off the old one from
the memory it's tricky implementing a
dynamic or changing list using arrays
this creation of new array and copying
of old data is costly and this is the
precise reason why we often use another
data structure to store dynamic or
changing
and this another data structure is
linked list so why not use a linked list
why can't eat Robi a linked list
something like this logically we still
have a list here but concrete
implementation wise we are no more using
an array that we need to change
dynamically we are using a linked list
it's a lot easier to do insertions and
deletions in a linked list now
programmatically to create this kind of
structure in computer's memory we need
to create a linked list for each node to
store its neighbors so what we can do is
we can create an array of pointers just
like what we had done when we were using
arrays the only difference would be that
this time each of these pointers would
point to head of a linked list that
would be a node I have defined node of a
linked list here node of a linked list
would have two fields one to store data
and another to store address of the next
node a zero would be a pointer to head
our first node of linked list for a a
one would be a pointer to head of linked
list for B and we will go on like a to
foresee a three for D and so on actually
I have drawn the linked lists here in
the left but I have not drawn the array
of pointers let's say this is my array
of pointers now a zero here this one is
a pointer to node and it points to the
head of linked list containing the
neighbors of a let's assume that head of
linked list for a has address 400 so in
a 0 we would have 400 it's really
important to understand what is what
here in this structure this one a zero
is a pointer to node and all up
winter does is store an address or
reference this one is a node and it has
two fields one to store data and another
a pointer to node to store the address
off next node let's assume that the
address of next node in this first
linked list is 450 then we should have
450 here and if the next one is at let's
say 500 then we should have 500 in
address part of the second node the
address and last one would be zero or
null now this kind of structure in which
we store information about neighbors of
a node in a linked list is what we
typically call an adjacency list what I
have here is an adjacency list for an
undirected unweighted graph to store a
weighted graph in an adjacency list I
would have one more field in node to
store weight I have written some random
weights next to the edges in this graph
and to store this extra information I
have added one extra field in node both
in logical structure and the code all
right now finally with this particular
structure that we are calling adjacency
list we should be fine with space
consumption space consumed will be
proportional to number of edges and not
to square of number of vertices most
graphs are sparse and number of edges in
most cases is significantly lesser than
square of number of vertices ideally for
space complexity I should say Big O of
number of edges plus number of vertices
because storing vertices will also
consume some memory but if we can assume
that number of vertices will be
significantly lesser in comparison to
number of edges then we can simply say
Big O of number of edges but it's always
good if we do the
right now for time cost of operations
the argument that we were earlier making
using a sparse graph like social network
is still true adjacency list would
overall be better than adjacency matrix
finally let's come back to the question
how flexible are we with this structure
if we need to add a new connection or
delete an existing connection and is
there any way we can improve upon it
well I leave this for you to think but
I'll give you a hint what if instead of
using a linked list to store information
about all the neighbors we use a binary
search tree do you think we would do
better for some of these operations I
think we would do better because the
time cost for searching inserting and
deleting a neighbor would reduce with
this part I'll sign off this is it for
this lesson thanks for watching
hello friends in this lecture we will
look at graph representation using
adjacency lists and we will use C++
STL's to do accomplish this task so we
will just look at a very simple graph
here
and let's see that this one is the graph
0 1 2 3 so we have 4 nodes in our graph
and this is how they are connected with
the edges so now what we want is we want
the adjacency list representation and
what does adjacency list do is that for
each node the case of we have node 0
node 1 node 2 and node 3 ok so we have
these in a vector okay so we have them
like this so this is a vector where we
store all the nodes and we also have
what is known as a list for all these
nodes okay
so node 0 it is connected to node 1 2
okay so we will have here node 1 and
node 2 ok so these are the nodes that
are connected to node 0 then for node 1
we again see 0 and 2 are the nodes that
are connected to node 1 for node 2 we
see that node 0 node 1 and node 3 are
connected and for node 3 it's just
connected to node 2 so this is the
adjacency list representation and what
happens is that it saves storage for us
okay it saves memory and how because
each now if there are mod e number of
edges so all these nodes just we have
the list of nodes for each node which
are connected to it ok so this
is the basic idea but here the important
another important thing is how to
represent it in C++ so in C++ our most
important thing that we need to know is
that we have what we have set of nodes
okay our set of vertices and each
vertices each vertex is connected to a
set of other nodes through edges okay
and this is what we have to represent so
how we do that thing so we will use what
is known as so a vector we will use for
all the nodes we have vector where we
will store all the nodes but each node
now has a list so we have vector or a
list of int okay so this is what we will
have so if you see here so we have and
if there are n nodes okay so what it
becomes is that we have a vector of list
of nodes okay and which we will call it
adjacency list and what happens in the
vector you have each node okay and in
each node you have a list which tells
you that which other nodes it that
particular node is connected to so now
we will look at the C++ code that
implements this graph representation
using adjacency matrix so of course the
first most important thing here is so we
are using STL where we use vector and
list okay so these are the two
representations the data structures that
we use and the most important thing is
here so this piece of code so standard
vectors we have a vector of what the
vector is also upset basically indexed
set and in that what we have in each
vector item we have a list okay so we
have a list
of all the nodes it is connected to so
this is the basic idea and now what
happens let's see how we have done so we
have a simple graph here and what that
graph looks like is we have four nodes
okay so 0 1 2 &amp; 3 and let's see how are
they connected so we do because this is
a vector so it is like an array very
much similar to an array where we can
indexed items we can use to adjacency
list 0 that is the first node dot push
back 1 ok so now let's try to see this
thing so when we do adjacency list 0 dot
push back 1 it means that our graph is
basically 0 is connected to 1 so let us
first draw the graph then 1 is connected
to 2 and 0 2 is connected to 0 1 and 3
so this is our graph and now let's look
so this is an unweighted graph so and
what happens and undirected ok so here
what happens is this is adjacency list 0
means the node 0 and when we do dot push
backs of this item adjacent see list 0
this represents in list ok list and a
list for basically or you should remove
list for node 0 similarly adjacency list
1 is the list of nodes that are
connected to 1 so this is basically of
type standard list ok this is the type
of the adjacency list I now what happens
is so we have a if napi okay push
underscore
back where we just pushed the note
number which it is connected to so
adjacency list 0 dot push back 1
adjacency list 0 dot push back to so we
push in this creates for us now we have
here 1 &amp; 2 similarly what happens
adjacency list 1 so for node 1 the
vector and this is the list so we have 2
and 0 here for - we have a list 0 1 &amp; 3
so this is the list and for 3 we have
just got two so this is the your
adjacent see list and your graph is here
and this is how you create the graph
okay now the thing is we want to print
the graph okay how the nodes are
connected and so on and which is a
little bit complicated because of STL
that we are using and in fact STL makes
your life very simple because you don't
need to have your linked list maintain
your own linked list it's and resize
everything will be done by your vector
and list STL classes okay so this is the
part where we construct our graph now we
would look at how we Traverse so how we
will Traverse so let's see so for
traversing we have this piece of code
okay and let's try to see how it is done
so we have what we have one is vector so
if let's say I want to print for all the
vertices I want to print their neighbors
so first thing is I need a kind of for
loop which will iterate through all the
nodes so for all the nodes and a nested
for again for
each of its neighbor so print their name
so these are the two things that you
need to do so how we do so there is a
concept of iterator in C++ STL where
what happens when we want to I trait
through some STL class so if we have a
vector so we are making a vector I
traitor so you need to have the same
kind of hydrator through the type of
class you want to I take I trait through
so we have standard vector and that
vector is of what so it consists of
vector of standard list of ends so it's
I traitor by scope resolution I gave I
traitor I we have a see count is zero
initially we start so standard vector
standard list int i traitor i so i
traitor now it starts at adjacency list
dot begin and till it goes till
adjacency list dot end and i plus plus
happens okay so what happens it's just
like a for loop okay where i is equal to
0 to some maximum size so here we are
going because we don't know the size of
the the list or the vector so we keep on
iterating and this adjacency list dot
begins show me the beginning of the
vector and adjacency list dot n j--
shows me the end of the vector okay so i
is your eye traitor that is ight rating
through your vector of 0 1 2 3 those
objects so this is the vertical i
traitor i am going through
i but each time i also need to traverse
the list for each of the nodes ok so
this is again one i traitor so when i am
traversing here so this vector gives me
what inside the each vector object there
is a list of int okay and that list of
int vivant so what happens so we do
so in this a traitor I we will always
have a pointer to the list
okay so standard list of int okay so we
have in star I we get the list so let's
see so we have now the pointer to the
list for that particular vector item so
for standard list I traitor ITER Li dot
begin I traitor so now we are iterating
through this list using this for loop so
a standard list int so we have no I
traitor of type list of integers
it starts with Li dot begin so this is
the from here we take for this first
node what is the list I get from here
get the list for this node so we get it
here Li dot big ni traitor is not equal
to Li dot n plus plus ITER we do and we
what we do print the neighbors okay we
print which are the neighbors of this
particular node so what is has connected
to node C which is here and then we just
give one end line and C++ so that we are
printing the nodes okay which we are
traversing so this is the simple idea
where we are creating up for undirected
graph and with novated edges so this is
how we represent it using a vector of
list of int okay so the main thing is
how you implement this the concept of
adjacency list is simple but how you
implement using STL is a bit tricky and
I hope you understand this now so thanks
a lot
okay so one thing I forgot is that I
need to show you that it runs really
okay so that is important which I did
not do so let's try to see so vertices
connected to node 0 or 1 &amp; 2 vertices
connected to node 1 or 2 and 0 vertices
connected to node 2 are 0 1 &amp; 3 vertices
connected to node 3 are 2 just one node
that it is connected to so this brings
for us that how wonderfully in a compact
way we are representing a graph using
adjacency lists okay
so I hope you understand this thanks a
lot
surprise so are you can hole into
lecture how many people understood
lecture oh my god me so unsatisfied with
the rubik's cube thing yeah wait well I
was like really simple how long do you
Tucker roots sucker for on Rubik's cubes
so we left a little bit about Rubik's
Cube and then we talked about graphs and
breadth first search which you can use
to solve Rubik's cubes is that where you
passed out by the time we got two graphs
okay okay all right well so I want to
talk about two things maybe depending on
the level of interest we can talk a
little bit about peace at five and the
things that I think are weird in the
coding part of peace at five and whether
how many people started peace at five
hmm maybe we're not going to talk about
peace at five you guys need to start
early you did either yeah yeah I guess I
can punish you for everyone else so
peace at five and I can talk about
graphs I can talk about whatever didn't
make sense in class and I can talk about
background stuff for graphs so how do
people feel who wants to talk about the
piece of that we haven't read he wants
to talk about grass
yeah if you took 60 4 to nothing here is
new I mean nothing in the restoration is
due we're going to take it to new
heights of graft knowledge and you'll be
able to do many more cool things that
you're able to do before okay so P set
for people who started early what what
was the gist of the coding assignment so
you just view of something the what I
ran the tests do I say what I got is my
results I mean the time isn't on the
pieces they can say what they got the
department the time isn't on the pset so
you can say what you got is a time yet
also the slowest thing was look at okay
well you should look to see that is a
valid answer look at the questions and
see if that is a valid answer okay all
right wait the quiz it's not like what's
this loss function right there's more
text there so you should read the rest
of the text and see if that makes sense
as a valid answer sure okay okay so what
you're doing big picture is you have
some processor that's not the real
processor and it can do arithmetic with
bites and 16-bit words and will give you
the basic operations and then we give
you a library for large number automatic
because guess what 16 bytes addition
subtraction not going to cut it for I
don't know science applications or for
cryptography what we want you to play
with so let's see what are the basics of
basic operations that that processor can
do front of the pset so even if you
didn't get to the coding assignment you
can still tell me
okay so plus minus multiply divide and
mod let's talk to these so you have two
primitives in that process all right you
have bites which are basically a bit
digits so there's 200 the range is 0 2
256 and words and the word is 16-bit
from 0 to 2 thus to the 16-1 if you care
to know this is 65535 okay so if you
take two bites and dad them together
what do you get
not
it's a trick question you get a word so
the processor cannot do simple math on
bytes it it converts them up two words
and all the math happens on words now if
you get two words and add them up
together what do you get you do it we're
not that nice
sorry you just get a word at least at
least nobody set up item I was like
please don't say bye please don't say
bite so you said Carrie bit why do why
do we care about the carib it was the
problem if you do addition this way
you're going the yep so suppose we're
trying to add 2 to the 16 minus 1 plus 2
to the 16-1 whether it does anyone
remember hex notation hexadecimal ok
people who started the pset remember
that's good so it will be easy to write
things in heck for the pset so if you
try to add these numbers you're going to
get one f FF II and you can use the map
here to see that this is more than a
word so you would like to know that this
thing overflows right you'd like to know
that there's well we don't give you that
so all you get is this so addition
happens modulo 2 to the 16 if you want
to be able to detect overflow what do
you have to do
that's okay that's one way of doing it
let's take quite a few instructions
though so if you want to do overflow
detection the easiest way I think of
doing it is to use this form so suppose
you have two bites this is the maximum
value in a bite right 255 2 to the 8
minus 1 if you have two bites and you
add them all together you're going to
get one FP right so it's just just like
the case here except you have fewer f's
okay where's the carry here yeah
so this guy here's the Carrie and this
guy is the result okay does anyone know
how these are called if you have a word
and you have two bites what's the first
bite was the second bite all right so
most significant byte MSD and least
significant byte lsv so if you want to
figure out your carries then you should
do your math this way you're going to
have white 1 plus x 2 to add them
together and then you call LSB to get
the bite result and then you call ms be
together carry so this is addition
everyone with me so far by the way are
these numbers signed or unsigned
no negative numbers right so now support
for negative numbers everything is going
to be positive and we're going to build
everything we need off of positive
numbers because they're easier to deal
with what if I have two words and i
subtract them what do i get
okay what if I have zero minus one why
do I get not quite if you're not using
sine 0 you get 0 y 0 1 0 ones okay so
all ones would be this F F that's a
really big number okay so fancy cs2
compliments for people who think in math
mode what is this it's minus 1 not 2 to
the 16 so remember when we're doing
modular arithmetic before to figure out
the number its multiplicative inverse
and when we're doing rolling hashes
within one negative numbers we made them
positive so minus 1 mod to the 16 is 2
to the 16 minus 1 and it comes out to
this value so you get minus 1 it's just
that you have to know your basis okay so
we got addition and subtraction let's
talk about multiplication what do you do
for multiplication what can you multiply
two bites very good just to rights
what do you get a word thank you so you
multiply to buy to get a word what if
there's overflow
no it's a trick question there's no
there is no air flow so two bites 2 to
the 8 minus 1 times 2 to the 8 minus 1
is 2 to the 16 minus 2 to the 8 minus 2
to the 8 plus 1 so this is smaller than
you can say this safely without doing
the arithmetic right so this is how much
you can hold in a word this is how much
you can hold in a bite so yeah minus 1
well there's a minus 1 here there's some
minus 1 here but I can find it here so
roughly this but there is an overflow
where do you get that so this is how
much you can hold in a bike so by ties
eight bits right from 00 to FF so this
is 2 to the 8 minus 1 okay so
multiplication there is an overflow I
don't have to deal with that you guys
have to figure out how to deal with it
how about division what can you divide
almost a word / do we have what do you
get out of it
that would be nice nope sorry you get a
bite and if you do módulo you also get
a bite what if there's overflow in the
division what happens what would you
expect to happen
how about 22 the 16 minus 1 divided by 1
so what do you get will this fit in the
bite okay yeah you don't get the word I
I promise you get a bite so what does
that by be no that's that's reasonable
right module 2 56 because that's what it
can carry okay what if what about the
modulo what happens there if you get
overflow
No
so if you do a modulo this is going to
be at most 255 right if you do módulo
255 the remainder is going to be between
0 and 254 will depth ever overflow bite
so no overflow no need to worry about it
so a date word edition can overflow
subtraction can overflow multiplication
doesn't overflow division overflows
modulo doesn't yes it exceeds the space
of the result because here if you're
adding towards the resulting season the
space of a word which is working it yep
pretty much exactly so the reason you
have to deal with this weird system is
this is pretty much how Intel does their
arithmetic so if you look at old school
16-bit Intel processors you have
registers and you have exactly these
operations for newer processors there
are 32 bits but then it's just you write
more s on the board and you get the same
thing most significant byte on a real
processor you have registers that are
the size of a word and then you can pull
out the bytes in constant time so what
constants do we have these are the these
are the operations what constants do we
have
only two constants 0 and 1 what if you
want to get something bigger what if you
wanna get to how do you get to yep what
if you want to get this number
several times kind of painful to type
even if you copy paste so there's a
method on word called from bites and it
takes 1 m-sb and then LSB and it gives
you a word so what would I give it let's
give you the one and let's give it a
zero so this will get 100 and then minus
1 yes
okay so Intel is pretty nice about
Constance but some other processors
aren't so I figured why not let's get
you acquainted to these kind of tricks
too let's make the pset more interesting
alright so any question on this fake
processor that you have to call for here
so word from bites who are these two
bites one next to the other give it the
first bite give it a second bite in this
case the first bite is one the second
bite is 0 right so two bites 1 and 0 how
do you write this in hex 100 one bite
second bite and then i subtract one look
at this okay so while I raise the board
I want you guys to think of graph
questions because this is the other
topic we're looking at today so what was
unclear about the lecture what is
unclear about graphs in general do you
guys remember the handshaking lemma what
does it mean how do you prove it things
of that sort
so why do you guys want to cover today
we're bunch of nodes and they're all
connected oh I mean like throwing crap
crap that the number of edges to
vertices ok quietly number of vertices
the number of him now that our grade are
twice and other edges you said the
number of vertices well yeah no word
Bernice's and ledges are not related
yeah think of a triangle right that's
three edges three vertices yeah which is
like not to x which is what you said oh
it's a number of degrees is twice the
number of edges oh that's all right so
let's start with simple stuff what's a
graph all right fancy word for nodes
verdicts vertices and edges how do I
draw vertices out by George's circles
and lines possibly arrows I like that
you want to get fancy all right so when
do i've drawn edges align when do I draw
it as an arrow which ones which
well let's draw this graph here
yeah it looks like a pretty boring draft
so
is this graph connected or not okay
what's a connected graph there's a path
from any node to any other node okay so
how do I make this on connected using
the least amount of effort it's a bit of
a trick question so guess any guess is
fine how do I make this unconnected
using the least amount of effort on my
behalf okay I heard remove a jizz I
don't like you racing because I don't
like the yep so I like that answer out
of the toy so now it's not a connected
graph how many components how many
connected components does it have two
and five okay what's a connected
component
thank you
saying that part of the drop is the
night follows the media gets there like
two parts and good stuff
so connected component is a bunch of
vertices such that you can get from one
vertex to all the other vertices and
that's true for if the graph is
undirected that's true for any vertex in
the set and we also want that sets to be
maximal because if we say this is a
connected component it's not very useful
noticing that this whole thing is a
connected component useful so this is
one component this is the other
component make sense so we have the
world we have CDs you can bike from a
city to another city and that's it no
other route of transportation how many
connected components okay roughly seven
why okay so what are these seven okay
let's say roughly seven so this is what
I wanted I wanted some thinking so if
you try to get from a continent to
another continent presumably you would
go through some patch of sea because
otherwise where are they calling them
continents okay does anyone want to give
out another answer as this in the
previous section and some people there
give me some very precise answers that
are not countenance this is what I had
in mind by the way so as far as I'm
concerned this is a good answer come on
guys world so two things Islands
and Europe and Asia are connected so you
can go from one to the other rather
weird why are they separate continents
no idea the geography people might okay
so it would be a pain to bite through
that but presumably you can if you have
a robot that doesn't get tired or
something you can bike okay so the
answer depending on how my geography you
know is somewhere between seven and ten
thousands I guess or whatever the number
of violence is there a lot of tiny
island somewhere right anyways between
seven and a big number so this these are
connected components in the world what's
the degree of a two what's the degree of
d
very good let's make this the degrees of
age fgh to to to the degree of c230
agree of be thank you and the degree of
e okay if you add up all these numbers
together what do you get
18 I can't do math so I couldn't
possibly have added all these numbers
together right I used something else
what how many edges do I have in the
graph 123456789 see a connection here so
this is the end shaking lemma that's all
there's to it so if you look at the
degrees of a node each edge adds one to
two degrees for instance this edge adds
one to CS degree and adds 1 2 d's degree
if you're a math person and you write
this up you have to write the sums and
you have big sam's of intimidating using
intimidating notation so it's not as
obvious but this is really all there's
to it each edge contributes one to two
nodes degrees so if you add up all the
degrees you're going to get two times
the number of edges so far so good okay
what if we have directed graphs what if
I had this other than dramas
a b c d e f what is the degree of a
man not quite sorry that was a trick
question it doesn't have a degree so if
you have if you have directed graphs you
don't have degrees you have in degrees
and our degrees so now that I've said
that to know what they are right what's
the out degree of a sometimes this is
known as the degree of edges so this is
true and what's the indegree away all
right so a has two edges going out 0i
just going in how about d what's out
degree of d come on guys don't scare me
and what's the in degree of d2 very good
so what's the equivalent of the
handshaking lemma on oriented graphs
okay what about them nothing quite their
equal to you had eighty percent of the
answer so the sum of the indegree and
the sum of the out degrees but if you if
you add them up you will get two times
the number of edges that is correct but
I want something for yep that's a bit
yeah this is cooler right so why is that
does anyone see why that's the case each
edge
come on guys so what does it judge do
all right so if i look at this edge here
this edge is going to contribute 1 2 b's
out degree and 1 2 d's in degree so each
edge contributes one to an out degree
and want to an indegree so that means
that total sum of our degrees equals the
total sum of in degrees and both of them
are eat and then combined to II sorry I
I don't know why that didn't click to me
right away ok so the intuition behind
this is that for every node if you take
on edge you're going to get somewhere
else if if you're if the sum of the out
degrees was bigger than you have a black
hole somewhere you go on an edge you
don't come back same for in degrees okay
how do we represent graphs
so sure if you're drawing them on the
board that's what to do but if you're in
Python what do you do each node having
its neighbors okay so I have one big
linked list or how does this work well I
used to have like having a starting
point I'm sorry starting node and then
from that note you can have its
neighbors to it as like okay I guess so
I wasn't precise that that is not
trivial to build by the time we built
that we're done with this recitation so
what you get is the vertices and the
edges and we want an easy representation
that just looks at the vertices built
something looks at the edges build
something
values like a has you savers okay
dictionary let's go for that so we have
a dictionary and for each node you have
the list each vertex you have the list
of vertices that are connected to it so
what's the list for eight okay what's
the list for be
alright so in Python this is would be a
dictionary right so how much total space
does the stick number of ok so if I had
if I had if these were actual slots in
an array so this would be an array I
would have the number of nodes you're
giving away the answer to my next
question so I have these slots here so
if this would be an array its order V
just to store this the thing in python
is that you have these dictionaries that
are fancy hashes where they grow as you
need them so if for example you have
10,000 vertices but you don't have any
edge your dictionary size is going to be
order one because it only grows as you
add edges to it so so this is assuming
that I don't store empty lists so if i
have a strain out here if i have a node
I say this is I if I don't store
anything I don't have to pay for it if I
store an empty list here then I have to
pay for it and there's an order V
component that you might shit
since that then in that case it would be
it order V restoring p lists for the
knows that don't have edges yeah on the
other hand if I don't store anything for
the note that don't have edges it's
order one ok so no edges to be depends
on what you want so if we starting to
lists you're going to have an order V
cost here but your code is going to be
simpler presumably because you don't
have to check your something is or isn't
in the dictionary okay how about this
stuff what's the total size of this
stuff here
ok order e how many elements do I have
been hearing follow in this thing here
so what some of the length of the lists
let's go for something else all right
that's what I wanted to hear so a list
is neighbors right the number of
neighbors that a has is the degree of a
b-list its neighbors so this is the
degree of B so if you sum up over all of
them what's the sum of all the degrees
in the graph to e we learned about the
threads and checking lemma 2 e so what
is the total cost for storing this data
structure so v + e assuming empty lists
okay let's look at another data
structure for storing things in a graph
so instead of using lists let's use a
matrix a b c d e on top a b c d e on the
left let's pretend our graph is just
that component over there because
otherwise it just gets big and there is
no extra insight so does anyone know how
this is called if I put numbers here
does anyone know what this is called
there's there's no fancy name for it it
ends with matrix okay I don't think we
thought it too so don't worry the fancy
name is Jason maybe it's misspelled but
something that looks and sounds like
this adjacency matrix misspelled
okay I hope someone will healthy okay so
if this is an adjacency matrix what
should this element tell me between
beginning yep if it's an adjacency
matrix it would better tell me if
they're adjacent and they're adjacent if
they have an edge between them so for a
and B what does it happen to be okay and
a what do we do what's easier for the
algorithm that you're trying to
implement so it doesn't really matter we
use one most of the time but it's
sometimes it's easier to user 0 then use
a 0 yeah so that's why you'd use the one
sometimes though you don't want to in
code so between a and C so someone
dictate this to me or everyone dictate
this to me so I know it makes sense so
antsy is there an edge between them what
I write a and D and E
be a PC BD be okay SI ay SI b c d see
all right now i'm going to use the bit
to give me to come to get this do it
correctly and d i'm not looking at the
graph by the way i'm trusting yourself
better give me the right answer d &amp; D D
1 ok how many ones do i have in this
to see if you guys are thinking
so each edge contributes to to one's
right and that accounts for most of the
ones so this is how many ones I have how
many zeros do I have
so this is a non boring way of asking
how many elements i have in this matrix
this is what i was looking for so V
Collins right vero's v squares total
elements so how much memory do I need to
store this V squared what if I want to
store it as compactly as possible so I
want to pack these as tight as I can
yeah so what do I store v squared what
oh yeah what's the unit all right so V
squared sits where as this is v + e
words because you have to store pointers
everywhere here so sometimes if your
graph is really dense you might prefer
this representation let me see how much
time we have oh when you have time who
remembers bread for a search yes
alright so breadth first search we have
a graph
so suppose this is our graph and I do a
breadth-first search starting at a how
does that work so I started to the list
of the notes that I'm going to visit i
initialize it with a because this is the
only know that I know about what happens
next all right so I take out of the list
the first thing that I can this is my
current node you said I visit VNC
because there are the neighbors right so
i took a out of the list so a was
definitely visited and i'm visiting b
and c what do i do when i visit them put
them in a list so this sorry this means
i discovered them and i'm going to visit
them later so i discovered them i know
of their existence what happens next
okay so be gets out of the list and what
do I do discoveries all right so his
neighbors are a D&amp;E what now okay it was
already visited dnd weren't so d and e
then what happens
any neighbors that I haven't seen nope
then e and ok and then so a is the first
node i started with a because i said i'm
doing a breadth-first search starting
from a so BFS starts from somewhere a
BFS as a source and you'll see why that
matters in a bit so do I ever get to see
f nope so if I started a what are the
notes that I visit and what are the
notes that I don't visit all right in
the connected component so the whole
graph can be connected or not connected
so the note that i visit are the nodes
in a connected component because by
definition those are the note that i can
reach from a so if i have many connected
components and i use BFS starting from
one node i might not visit the entire
graph how do i keep track of what node
I've discovered and I haven't discovered
so what did a structure do I use for
these smiley faces
but so far the smiley faces for this
thing I probably want a cube we teach
you something simpler but most of the
time when you write the code you
actually use a queue but whether i want
for the smiley faces so when I pull a
load out say I pulled out be and I see a
de and I want to know that I visited a
and I didn't visit dnd you guys remember
that we didn't visit the any right by
the time we got to ok so I want to be
able to check whether i visited another
not really fast so what data structure
should i use for the smileys a hash
table cool what I are stable in Python
dictionary
alright so this is going to be a scene
which is a dictionary and it maps
vertices to may be true
yep yeah Python has a set right so you
can use that okay so this needs the
smileys need to be some sort of smiley
it needs to be some sort of dictionary
so given that and assuming that this is
a cue that we can extract and insert
from in constant time what's the running
time of BFF let's make life easy let's
assume the graph is connected so let's
assume this doesn't exist so BFS was the
running time so you visit every node one
so it's at least v that's a start now
what do you do when you visit the node
all the neighbors right so given the
node you have to go to the data
structure that you have that either this
or this and you have to get a list of
neighbors if I have this data structure
how fast do I get to the stuff neighbors
for a note yep order of the degree of
the node that's good how about this data
structure
yep so in this data structure for
example see only has three edges coming
true edges coming out of it sorry
because this is off but I have to go
through the entire line in the matrix to
see where I have my zeros and where I
have my ones so in order to list the
neighbors here this is straight-up order
V whereas this is order of the degree of
the node degree of the note that I'm
looking for so for this where it's nice
and simple order V was the total running
time so for each node I have to ok so
we're up to be squared already and what
else do we need to do
anything that we need to do on a no
disorder V so V squared is going to be
the total running time that's it so if
you use adjacency this an adjacency
matrix sorry we get order of V squared
as the total running time what about if
we useless what's the running time I'll
give you a hint you have to use
amortized analysis she wears anyone so
we know it's order V because we're going
to visit every node and you guys didn't
see what I was kind of right here okay
so for every node I go through the
neighbors and I do something to them
right I check if they're in scene and if
not I Adam and I add them to the list so
so for every note the work is yep so if
i look at all the nodes yep so for every
node I have to look at its neighbors and
I have to see which neighbors are in
scene and for the neighbors that are not
in scene i have to add them to my queue
so checking if a neighbor is in scene or
not order 1 adding it to the queue order
1 so the total work for no disorder of
neighbors because of the adjacency list
not matrix if I look at the entire graph
here I can't do a local analysis like I
did before if I look at the entire graph
and I look at all the notes / vertices
then the total work is the sum of their
degrees for each now this degree to work
some of the degrees and I have that nice
handshaking lemma that says that the sum
of the degrees is to eat so order e
sotto running time the posse okay can I
say the running time is order II movies
be careful to go without less than mu na
not have it
then
possibly more
okay so it's possible that i have more
vertices and edges i agree with that but
do i do anything to the vertices that I
haven't seen
so this is subtle the difference between
this and this is the matter of how you
implement everything in CLRS they assume
that the sea is an array so all their
nodes have numbers from 1 to V so then
they initialize an array everything is
false and then they set the true element
in Python we can use a dictionary and
not initialize it with anything so if
you do it that way in Python if you code
carefully you can get to order it
because you don't get the parts of the
graph that you don't discover you don't
have to pay for them if you look at CLRS
code it's definitely v + e so the end
the difference between this and this it
depends on the code what's the point of
VFS by the way why why do we care what
does it give us from shortest path from
point ok so it gives you the shortest
path from the note that I'm starting the
BFS wrong so only from this node so it's
going to give me if I start my BFS at a
it's going to give me the length of the
shortest path from A to which node
all the notes all the nodes that are
visited by BFS are reachable and we have
a path from them how do we how do i
compute this distance let's see so
what's the distance from A to A zero
when I start from a and I see that its
neighbors RB and see what's the distance
from A to B and from A to C ok now i
look at be what's the distance between a
and a Hayes beast neighbor yeah so I
have three neighbors and B has three
neighbors a D and E so I care about the
distances between a and a de distance a
a distance ad distance AE so this 10 how
about the distance is between a and D
and A&amp;E that's it
so the way I would compute is this these
distances is I start with a being 0 the
distance from HOA is 0 and then when I
look at the note when I discover the
neighbors all the neighbors that don't
have smiley faces on them get the note
distance plus 1 because you can get to
them by getting at the current node and
then traversing an edge when you do that
it's important that you don't update the
distances of the nodes that have smiley
faces because if you do you're going to
say that the distance from a to H 2 and
all hell breaks loose from there if I
don't if I forget the fact that it has a
smiley face so if i go through all of
these neighbors and i say the distance
from A to B is 1 so the distance from A
to all of these neighbors has to be too
that would be wrong these neighbors
these neighbors yeah so the smileys tell
me which which vertices I've already
seen and I've already presumably
computed distances for them so we don't
update those ok this is VFS in essence
one question facebook and twitter which
ones directed which ones undirected ok
facebook and directed which why is it
fun director okay so okay so this is
Twitter right Twitter directed because
of follows as I don't use Facebook
recently did you guys see there is a new
option lets subscribers then ok so how
the subscribers work ok directed or
undirected if I subscribe to you do you
have to subscribe to me
so which one is it is it so Facebook has
two graphs in it they happen to have the
same vertices the people are the
vertices in both graphs but the friends
relationship defines an undirected graph
the subscribers relationship defines a
directed graph the graphs are completely
different and there are two graphs
that's the right way to reason about
them that's that's why it was slightly
tricky okay can someone think of a cool
way to use BFS on facebook okay linkedin
also does that right so how many people
are your friends how many people are
your friends friends so and so forth
okay now suppose you want to get to
someone in facebook and you don't know
them directly they're not your friends
presumably you want to get to them
through the minimum amount of effort so
you want to see what the do you have a
friend that knows them if not do you
have a friend that knows a friend that
knows them do you have a friend that
knows a friend that knows a friend that
knows them so on so forth so BFS will
give you that minimum path okay the
grass makes sense so by the way BFS on
Facebook is just the beginning of a ton
of cool things you can do with graph
algorithms okay I was hoping it would
get people excited but I think you guys
are kind of looking forward to partying
for the weekend so any questions before
that okay enjoy the peace of then
so now I get to tell you about the very
cool randomized contraction algorithm
for computing the minimum cut of a graph
let's just recall what the minimum cut
problem is we're given as input an
undirected graph and parallel edges are
allowed and in fact they will arise
naturally throughout the course of the
algorithm that is for a given pair of
vertices we allow multiple edges to have
that pair as influenced now I do sort of
assume you've watched the other video
and how graphs are actually represented
although that's not gonna play a major
role in the description of this
particular algorithm and again the goal
is to compute the cut so a cut is a
partition of the graph vertices into two
groups a and B the number of edges
crossing the cut is simply those that
have one endpoint on each side and
amongst all of the exponentially
possible cuts we want to identify one
that has the fewest number of crossing
edges for a min cuts so here's the
random contraction algorithm so this
algorithm was devised by David Carter
back when he was an early PhD student
here at Stanford and this was in the
early 90s so like I said quote-unquote
only about 20 years ago and the basic
idea is to use random sampling now we've
known forever right ever ever since
quicksort that random sampling could be
a good idea in certain context and
particularly when doing sorting and
searching and one of the things that was
such a breakthrough about Carter's
contraction algorithm as it showed that
random sampling could be extremely
effective for fundamental graph problems
so here's how it works we're just gonna
have one main loop each iteration of
this while loop is going to decrease the
number of vertices in the graph by one
and we're going to terminate when we get
down to just two vertices remaining now
in a given iteration here's the random
sampling amongst all of the edges that
remain in the graph to this point we're
going to choose one of those edges
uniformly at random each edge is equally
likely once you've chosen an edge that's
when we do the contraction so we take
the two endpoints of the edge call them
the vertex U and the vertex V and we
fuse them into a single vertex that
represents both of them this may become
more clear when I go through a couple
examples on the next couple of slides
this merging may creates parallel edges
even if you didn't have them before
that's okay we're going to leave the
parallel edges and it may create a
self-loop edge we're now both of the
endpoints is the same and self loops are
stupid so we're just going to
leet them as they arise each iteration
decreases the number of vertices that
remain we start with n vertices we end
up with 2 so after n minus 2 iterations
that's when we stop and at that point we
return the cuts represented by those two
final vertices you might well be
wondering what I mean by the cut
represented by the final two vertices
but I think that will become clear the
examples which I'll proceed to now so
suppose the input graph is the following
four node five edge graph there's a
square plus one diagonal so how would
the contraction algorithm work on this
graph well of course it's a randomized
algorithm so it would work in different
ways and so we're gonna look at two
different trajectories and the first
iteration each of these five edges is
equally likely each is chosen for
contraction with 20% probability for a
concluding that's let's say that the
algorithm happens to choose this edge to
contract to fuse the two endpoints after
the fusion these two vertices on the
Left have become one whereas the two
vertices on the right are still hanging
around like they always were so the edge
between the two original vertices is
unchanged the contracted edge between
the two vertices on the Left has gotten
sucked up so that's gone and so what
remains are these two edges here the
edge on top and the diagonal and those
are now parallel edges between the fused
node and the upper right node and then I
also shouldn't forget the bottom edge
which is edge from the lower right node
to the super node so that's what we mean
by taking a pair of vertices and
contracting above the edge that was
previously connecting them vanishes and
then all the other edges just get pulled
into the fusion so that's the first
iteration of cargas algorithm or one
possible execution so now I proceed to
the second iteration of the contraction
algorithm and the same thing happens all
over again we pick an edge uniformly at
random now there's only four edges that
remain each of which is equally likely
to be chosen so with 25% probability for
concreteness let's say that in the
second iteration we wind up choosing one
of the two parallel edges say this one
here so what happens well now instead of
three vertices we go
- - we have the original bottom right
vertex that hasn't participated in any
contractions at all so that's as it was
and then we have the second vertex which
actually represents the fusion of all of
the other three vertices so two of them
were fused the left must versus refused
in iteration one and now the upper right
vertex got fused in with them to create
this super node representing three
original vertices so what happens to the
four edges well the contracted one
disappears that just gets sucked into
the super node and we never see it again
and then the other three go in where
this would go it is supposed to go
so there's the edge that used to be the
rightmost edge that has no hash mark
there's the edge with two hash marks
that goes between the same team knows
that it did before just the super node
is now an even bigger node representing
three nodes and then the edge which was
parallel to the one that we contracted
the other one with a hash mark becomes a
self-loop and remember what the
algorithm does is once ever self loops
like this appear they get deleted
automatically and now that we've done
our n minus two iterations we're not
just two nodes we returned the
corresponding cut by corresponding cut
what I mean is one group of the cut is
the vertices that got fused into each
other and wound up corresponding to the
super node in this case everything but
the bottom-right node and then the other
group is the original nodes
corresponding to the other super node of
the contracted graph so which in this
case is just the bottom-right node by
itself so they said a is going to be
these three nodes here which all got
fused into each other contracted and to
each other and B is going to be this
node over here which never participated
in any contractions at all and what's
cool is you'll notice this doesn't facts
define a min cut there are two edges
crossing this cut this one the rightmost
one on the bottom most one and I'll
leave it for you to check that there is
no cut in this graph with fewer than two
crossing edges so this is in fact I mean
cuts
of course this is a randomized algorithm
and randomized algorithms can behave
differently on different executions so
let's look at a second possible
execution of the contraction algorithm
on this exact same input let's even
suppose the first iteration goes about
in exactly the same way so in particular
this leftmost edge is going to get
chosen in the first iteration but
instead of choosing one of the two
parallel edges let's suppose that we
choose the rightmost edge to contract in
the second iteration totally possible
25% chance that's going to happen now
what happens after the contraction well
again we're going to be left with two
nodes no surprise there the contracted
node gets sucked into oblivion and
vanishes but the other three edges the
ones with the hash marks all stick
around and become parallel edges between
these two final nodes this again
corresponds to a cut a and B where a is
the left two vertices and B is the right
two vertices now this cut you'll notice
has three crossing edges and we've
already seen that there is a cut with
two crossing edges therefore this is not
I mean cuts so what have we learned
we've learned that the contraction
algorithm sometimes identifies the min
cut and sometimes it does not it depends
on the random choices that it makes
depends on which right edges it chooses
to randomly contract so the obvious
question is you know is this a useful
algorithm so in particular what is the
probability that it gets the right
answer and then we know it's bigger than
zero and we know it's less than one is
it close to one or is it close to zero
so we find ourselves in a familiar
position we have what seems like a quite
sweet algorithm this random contraction
algorithm and we don't really know if
it's good or not we don't really know
how often it works and we need to do a
little bit of math to answer that
question so in particular we'll need
some conditional probability so for
those of you who need a refresher you
would go to your favorite source or you
can watch the probability review part
two to get a refresher on conditional
probability and independence once you
have that in your mathematical toolbox
we'll be able to totally it nail this
question get a very precise answer to
exactly how frequently you
action algorithm successfully computes
the minimum cut
hi this is sesh we're on again for
another lesson in data structures and
algorithms in this lesson we're going to
see how we can efficiently store graphs
using what's called the adjacency linked
list scheme this is a follow-up to a
previous video that described the
adjacency matrix storage structure for
graphs if you didn't see that yet you
probably want to do it now before
continuing with this lesson the title of
that video is graphs types and
representation here is a sample
friendship / Facebook graph I used in
the earlier video what storage for the
vertex names in an array and storage for
the edges in the adjacency matrix where
the truth stand for the edges between
the vertices the problem is that there
are too few truths relative to the total
amount of space used by the matrix the
space utilization is only 8% in case you
jump right in and I'm wondering why it's
8% instead of 16% it's because half the
true values are really redundant since
the matrix is symmetric about the main
diagonal it is sufficient to look only
at the upper triangle or the lower
triangle so effectively we only need
half of the 16 true values it's pretty
clear that we need a much more space
efficient alternative than the adjacency
matrix and the clue to what that might
be is in the empty or false valued cells
in the matrix we don't need these cells
because they don't tell us anything
about the graph we don't already know
from the true values so really this is
what we want now that the cells and the
rows are not contiguous anymore we need
to stitch them together the numbers at
the top can function as column indices
since there isn't an array anymore but
we can get rid of them because they are
vertex numbers so we can bring them down
to replace the truth
next let's bring in the vertex names
array into the picture then we can get
the
row and column indices out of the
picture and have the Rowling's
originated from an additional field in
each of the vertex array cells it is
apparent now that we have linked lists
for each vertex holding the numbers of
all the vertices that are adjacent to it
for instance in the very first row for
Sara the vertex number is the linked
list 1 and 3 are those for Sam and AJ
which are adjacent to Sara in the graph
observe that again as in the adjacency
matrix each edge appears twice take the
edge between Sam and Mira
for example the vertex numbers for Sam
and Mira are 1 and 4 respectively
so 4 appears in one's linked list and 1
appears in forest linked list let's
clean up the pictures so the linked
lists look more like what we're used to
seeing this is the standard adjacency
linked list story scheme each vertex
stores a linked list of vertices
adjacent to it resulting in an array of
linked lists
notice that the neighbors of a vertex
appear in increasing vertex number order
in the lists but that's not a
requirement neighbors can appear in any
order the adjacency link lists
data structure can be coded like this
the neighbor class implements the linked
list nodes the vertex class gathers
together the vertex name and the pointer
to the first node in its adjacency
linked list and lastly the adj lists
variable is the array of vertex objects
which is the collection of names and
addition see linked lists of all the
vertices since each edge appears twice
the space needed for all the adjacency
link lists is twice the number of edges
times the space for a linked list node
now each linked list node has two fields
so let's say this is to you mister space
this is in contrast the single unit of
space for each cell of the matrix
in addition there are as many units of
pointer space in the vertex array as
other vertices so leaving aside the
space for the names of vertices which is
the same for the matrix as well for this
example the number of units of space for
the adjacency linked lists is 8 edges
times two notes per edge times 2 units
per node plus 10 units for the vertices
which adds up to 42 units of space and
all compare this with the space of the
matrix which is 10 times 10 or 100 units
in general if the number of vertices is
N and the number of edges is e then for
an undirected graph the space usage for
the adjacency linked lists is n plus e
times 2 times 2 or n plus 4 times e
while that for the matrix is N squared
for comparison here are the adjacency
link lists for the website graph without
edge weights since this is a directed
graph each edge contributes only one
link list node for a space usage of 8
edges times 2 units per node plus 6
units for the vertices adding up to 22
units while the matrix uses up 6 squared
or 36 units
if the graph is weighted then in
addition to the vertex number of the
neighbor the weight of the connecting
edge must be stored as well here is the
storage for the weighted version of the
website graph with the linked list nodes
modified to hold edge weights the
original data structure code can be
modified to include edge weights by just
changing the neighbor class like this
the space utilization now increases by
eight units one unit per edge for the
weight field for a new total of 22 plus
eight or 30 while the matrix is still 36
units because the same array cells now
hold weight numbers or negative ones
instead of boolean's here's a table that
compares the space requirement for the
linked list storage and the matrix for
the four kinds of graphs we are studying
the size of the graphs are generalized
to n vertices and E edges Spacek part of
the matrix is unchanging and only
depends on the number of vertices not on
the edges space acquired for the link
lists varies according to whether the
graph is undirected or directed whether
it has weights and how many edges that
are in the graph just around the soft
with a realistic example suppose we had
a weighted undirected graph with 10,000
vertices say on average each vertex has
100 connections to other vertices 10,000
times 100 is 1 million but remember that
each connection is counted twice so the
number of edges is half 1 million which
is 500,000 edges each edge node would
have 3 fields for the vertex number 2
the edge weight and the next node and
each edge would be represented twice so
two nodes / which means 6 units per edge
so the total space used would be 10,000
plus 500,000 times 6
which is over three million units of
space while the matrix would use up ten
thousand squared or 100 million units of
space to compare the linkless scheme
needs only three percent of the space
that is needed by the matrix okay let's
pull together everything we've learned
so far about the different kinds of
graphs and the adjacency linked list
storage into a simple program this
program will read an undirected
unweighted graph from a text file and
populate the adjacency linked lists here
we are in Eclipse the program is in a
file called graph the Java in a package
called graphs we call the data structure
definition for the adjacency link lists
that we saw earlier for the friendship
graph that's pretty much copied as is
here right before the graph class itself
the graph class starts out by defining a
field called adj lists or edge lists for
the array of adjacency link lists the
constructor does all the heavy lifting
reading the graph from a file whose name
is passed as a parameter in two edge
lists let's take a look at the graph
file friendship dot txt here so we can
get acquainted with the input format
there isn't a standard format that
everyone uses but this one works pretty
well the first line has the number of
vertices in the graph which is 10 in
this gray case the following ten lines
lists the vertex names one per line
subsequently each line lists one edge by
writing out the two end point vertices
alright back in the graph class the
construction starts by reading by
setting up a scanner to read from the
graph file the first line of the file
gives the number of vertices which is
used as the length of the adjacency
linked lists array which is created the
vertex names are then read in this for
loop one at a time each time a vertex
object is created with the name and null
for the neighbor list just to refresh
our memory
here's the word vertex class again okay
time to read the edges this is a little
more involved there are two vertex names
on each line but in order to add each to
the linked list of the other we need to
know the corresponding vertex numbers
this functionality is implemented in the
index for name method which cancer
vertex objects in the edge lists array
comparing the name field of the object
against the target name if a match is
found it returns the current index in
the array outside the loop which means a
match was not found it returns negative
one this should not happen if the graph
file has correct data back in the code
where the edges are being read
after getting the vertex numbers v1 and
v2 for the two end point where disease
v2 is added as a neighbor to the front
of v1 slist and v1 to v2 s list two
nodes for the same edge since the graph
is undirected recall that neighbor is a
linked list node
with vertex number and next fields since
the neighbors don't need to be in any
particular order it is fastest to keep
adding to the front of the lists that's
it for the constructor to make sure we
have read and store the graph correctly
there is a print method we can use that
runs through the edge lists array and
for each vertex prints its name and the
list of all its neighbors okay
let's run the program to make sure it
works as advertised
although the main method does is to ask
and get a file name create a graph
object by passing the file name to the
constructor which will end up populating
the adjacency link lists and then print
the graph so here goes let's run this on
our friendship graph let's stretch the
view to get everything in one go you can
verify that the output matches the
picture of the friendship graph now you
might be thinking what if the graph is
directed all the same code with just one
small change can handle the writer
graphs as well so take for example the
website graph without edge weights every
edge only goes one way from the first
vertex to the second vertex so when the
graph is read going back to the
constructor here
vitu should be added to V ones list but
not the other way so all we need to do
is to comment out the second line save
it and we can run it on the website
graph now to make sure it works
correctly so website dot txt again let's
just increase the view and there you go
now this is good but we can go even one
better the way it works now we need to
change the code every time we switch
between directed and undirected graphs
but if we change the graph format to
include a line up front as to whether
the graph is directed or undirected then
we can read that line in and use that
information to act accordingly so let's
go ahead and go to the website graph
file and add a line up front says
directed and save this and likewise for
friendship txt up before the number of
vertices will add a line that says
undirected now in the graph class
constructor just before we read the
vertices we're going to add the
statement string graph type is scanner
next and what we'll do is set up a
variable a boolean variable called
undirected initialize to true and if
graph type equals directed then we can
change that variable to false
and here instead of commenting this line
we'll make it conditional on the graph
being undirected
so if undirected then do this
okay now let's run our program for both
kinds of graphs and if yours website dot
txt well that doesn't look good and I
think I know what I did here we actually
read the first line right up here so I
need to move this before that statement
so the very first read will be the graph
type and then we get the next int and
then we can do the rest of the stuff
okay let's do this again run the program
website txt looking good let's do it for
friendship XD and that looks good as
well
okay that's about it for graph
representation and storage in summary
adjacency linked lists is the way to go
except for a few niche applications
where the matrix might be better see you
later
it is the gift students through the goal and
left raul and space but in language
Single first class and 15 in
space is needed between the number of
cm from crisis to crisis, but
album shields her face tri
German and hits is one of the names
dengue between good but old fans
both adhesive UN ban ki-moon tube
poet or colon Apps
ciro the gluing 2011 the old and
They compose sing in natori school love
loving between bella and make the school
10 lumbar name old old is impact
this colombia x noir old and looked
coleman name to go the old anvisa
They can have both at school in December
must be the old name
the rhythm is growing and space t
meters that good performance links to it
drogba newspaper and saw the English language
the new presentation always had so
linda bustani fish no one will call
rules ihg boasts around tennis
reminded frustrated broza come is not
will use force if to go the
sex fas'm almost half an hour does it all
what is left on marimba rose and Luol
deng long to run the who still went Not Made
the may have the colo colo - raising
so the handle and the game puts decide
stealing drugs
he puts all sewage
now on the staff also speak
médola method pelé he who does
colo colo not tell the technician wanted
that foot war recalled that the valley
is my thou said tri
the scheme can be understood - even if
not lose the guilt of the law as its
colleague would decide whether old pointer I
I told you who read still in school -
it is the drug that it intends to go on your
Guerrón place and even at the time as
you glue is not the clothes my colon
leak that point until my
makes promises on behalf of nilton and puts
Old Harbor this will go to school he
puts all school or work
this is their 8 lap 20 his mother's lap
old this must be between the point
squeaky old old tri four
the languages Inglês team saw clijsters
champion of the 1st Mobile forum use rate
that still does not think of the interview
tek tank
okay let's talk about graph
representation before we can talk about
exploring and graph we need to know what
we're given as input and there's
basically one standard representation
and a bunch of variations of it and
they're called adjacency lists so the
idea with an adjacency list is you have
an array called a DJ for adjacency of
size v each element in the array is a
pointer to a linked list and the idea is
that this array is indexed by a vertex
so we're imagining a world where we can
index array is by vertices so maybe you
just label your vertices 0 through V
minus 1 then that's regular array or if
you want to get fancy you can think of a
vertex as an arbitrary hashable thing
and a DJ is actually a hash table and
that's how you probably do it in Python
maybe your vertices are objects and this
is just hashing based on the address the
object but we're not going to worry
about that just going to write a DJ if
you assume that somehow you can get the
linked list corresponding with that
vertex
and the idea is for every vertex we just
store its neighbors namely the vertices
you could reach by one step from you so
i'm going to define that a little more
formally adj of you is going to be the
set of all vertices V such that UV is an
edge okay so if you have a vertex
where's where my graphs here so if I
have a vertex like be a j.o.b is going
to be both a and C because in one step
there are outgoing edges from B to a and
B to C so a DJ abhi is AC right then in
that graph should label diversity
something different adj of a is going to
be just see because you can't get from
one with one step from A to B there's a
the edges in the wrong direction okay an
Ag JFC is be okay I think that
definition is pretty clear for
undirected graphs you just put braces
here which means you store I mean the
same thing for here adj of c is going to
be a B and D as you can get in one step
from C to a from C to B from C to D this
for pretty much every at least for graph
exploration problems this is the
representation you want because you're
at some vertex you want to know where
can I go next an adj of that vertex
tells you exactly where you can go next
so this is what you want
sighs welcome to this tutorial and this
video is about graphs and its
representation using edges in G lists
let's quickly have a look what a graph
is really is so graph is basically a
collection of nodes and edges between
those nodes so zero connects to one one
connects to two and three and four zero
connects to four fourth and X to 0 1 and
three graphs could be of two types one
is the undirected graph and one is the
director graph that undirected graph
basically means if one to two is the
neighbor then to the one is also enable
directed graphs on the other hand if one
to do is a neighbor two to one is not
enabled so if two to one had had been a
neighbor then there would have been an
arrow pointing from two to one now that
we know what a graph basically is we can
get to putting this in Eclipse we
quickly over hand create a new Java
project
let's call this graph wait for it to
build path let Kelso's create a new
class and we call this graph graph hsn.c
list pretty cool name big one though
okay first let's import java.util u2
tour so then we create a private
instance of a map at a list and list and
in teacher so this air LS it should be
array list it's provided was by Java dot
util and it lists and let's call this
adjacency list map
alright now we create the constructor
for this class it's called public graph
HSMC
list and it will take an input and
square this is so we give an input as
the number of vertices then we create
and a big off with those vertices and
edges and see list map is basically a
new hash map which will take input as an
integer and then add a list of type
integer so it should be captive I okay
then we say for the number of vertices
start the user input we create an empty
graph with it so and I equals 1 I less
than equal to the number of vertices I
plus plus we create an array list of
integers in teacher and let us call this
as neighbors this will be a new
ArrayList of integer
Edge's until s map is now we just put
four ayat element we put in the
neighbors so what we just did was for
supports a node zero we created an
ArrayList which will which we are
calling as neighbors so for zero there's
a list for one this list for two and so
on for the number of what it is that the
user input we have created an empty list
of neighbors now we basically need a
function to add n8 so let's call this
public void add edge and this will take
as input the voltage and the neighbors
that we want to add the neighboring word
is that we want to add first we check if
the world is start with input that the
user input is actually a part of the
nodes that we initially defined so
suppose our graph is for node 0 1 &amp; 2
but the user wants to access the node
say 7 so that is not in the range in the
scope and so we need to check that case
and W belongs is greater than adjacency
list list map node size then we simply
return so this should be W create a pan
ok and if that is not the case then we
use the inbuilt function it's in C list
map dot get B first get the word test V
and then we basically add W as its
neighbor we should put brackets over
here to make clear
we get the list but we get vertex we and
then we add W as its neighbor so this if
we add only this line that means that
graph we are talking about is an
undirected graph is a directed graph
sorry and if we add this line as well
adjacent c-list map dot get W and then
dot add we so now the graph we're
talking about becomes an undirected
graph so what we basically mean over
here is that we get V and add W of its
neighbor and then we get W and add V as
its neighbor okay
now we need to add neighbors as well so
we create a new function which we call
as let's call it get neighbors so this
function basically returns us the list
of neighbors to a particular node that
they input
okay so what seems to be there okay so
okay let's say let's again check our
base case which is if we is actually a
part of a cross
in this case we simply return a null as
we return an ArrayList of integer should
be capital I of individual which will be
agency list math dot get we so this
returns us the list of neighbors to the
vertex we all right now we write down
the main code public static void main
string argument let's create an integer
and count and get initiated to one and
then we need the source vertex and we
need a destination vertex then we can
create a line on that synthesis enter
the number of vertices and edges
and we use scanner to get the input and
we call some dot n then we create a new
variable let's call it number of
vertices number of vertices and we take
input from the user
next int then we take input as the
number of edges and we take input again
from the user extent okay now what we
need we create a new we need to enter
semicolon over here then we take we
create a new instance of the class graph
adjacency list it sealers and let's call
this adjacency list new graph hsn.c it
sends C in C list and the input will be
the number of vertices that we just took
input from the user seems fine till now
then we need the user to enter the edges
so like zero to one is an edge we need
the user to develop start so again we
tell the user one here we told a friend
in line
say enter edges in format source space
edge toast space destination alright now
we create a loop and we say while count
is less than equal to number of edges we
just simply take input source is scan
dot next int destination is scan dot mix
end and we add the edge edge SNC list
dot add edge between source and
destination and we done and now we just
increment count consciousness okay now
let's tell the user that the given
adjacency list for the graph and then
[Music]
let's give a line after this and then we
simply create an Impala we say int I
equals 1 I less than equal to the number
of vertices i plus plus system dot out
dot print print how do we print so
there's a node followed by the neighbors
so let's do it like this I and then you
say plus followed by an arrow this
should be double bracket okay now let's
say let's create an array list of type
which is integer let's call it edge list
jason see list dot should be a jason
seed yes so we're talking about this
edges in serious adjacency list or gate
neighbors so we created get neighbors
function over here now we're just using
it to get the list of neighbors and the
input to this will be our vertex I and
now we simply need to print this in J
equals 1 semicolon semicolon j + s we do
this ok now we say if J not equals edge
list dot size
then we output turns out dot print edge
list dot get J minus one plus again we
give an air over here else let's do this
system dot out dot print edge list H
list dot get J minus one and and then
break so this this statement is just to
take whether the node whether the
neighbor we are talking about it's the
last neighbor or it's an end with me
neighbor so if it's the last neighbor
then we simply do this if it's not the
last neighbor then we do this because we
want to keep like putting arrows after
each neighbor so let's just give this
space over here like this okay seems
pretty nice till now now just give a new
line over here system dot out dot print
line just to make it look up a little
better think we done over here we can
run this enter the number of vertices
and edges so number of vertices is say
four and edges are five five and of the
edges in format source and destination
so we say one
has an edge with to one has an edge with
three to as an edge with or with three
and let's say one is an edge with four
and one okay - as an edge with four
pretty cool so one as neighbors two
three and four to have neighbors one
three and four three has neighbors one
and two and four s neighbors one and two
seems to be working fine
hey guys welcome to this video in this
video we are coding agency lists and
Python very quickly let's look at the
path that we want to plot so we got six
vertices 0 1 2 3 4 5 0 if connected to
neighbor as 1 &amp; 2 2 is connected to
neighbor 4 1 is connected to 2 &amp; 3 and
so on so we can actually use 2 ways to
implement this infighting so the first
way for list of list methods so what we
want to do is we want to create a list
let's call it edge until this and this
will basically be a list of list
so the 0th index will contain all the
neighbors of vertex 0 so we got 1 &amp; 2 1
&amp; 2 so we done we just implemented the
neighbors of vertex 0 now we want to put
in the neighbors of vertex 1 which are 2
&amp; 3 so we create another list we say 2 &amp;
3 and similarly the neighbor 4 3 which
is 4 neighbor 4 2 which is 4 then
neighbor 4 3 is 4 &amp; 5 and the neighbor 4
5 so this would be 5 and then we or non
point 5 so this will be an empty list
all right so we just specified what are
the neighbors of each vertex 1 &amp; 2 for
vertex 0 2 &amp; 3 for vertex 1 and so on
now we we just created the structure we
can simply loop through the structure
and print the neighbors of each so what
we'll say is we created on your variable
n which is basically the length of this
so edges until s and now we want to
implement a for loop and we say for we
end range the 0 to n 0 comma N and
now we just want a friend so friend and
this should be V space in and we want to
print and we should give a space between
this and then we say HSN seal is base we
actually let's do it do it like this so
this should be a space okay so let me
open the terminal and try to run this is
a item which is in say list or py okay
very neat
so one into neighbors of zero two and
three neighbors of one and so on so this
was a list of lists method the other
method that we want to use the
dictionary method so let me write down
dictionary okay so what we want to do is
a dictionary will basically cut there a
contain a pair of vertex and list so
great a dictionary let's call it agency
list for system is collected and
implemented as an empty dictionary now
we simply can insert the nodes so
adjacent village dip and for 0 we'd
specify the neighbors and this will
basically be a list so this would be 1 M
2 and similarly you can you can copy
this but we'll see we now we can go 1 2
3 4 4 5 so this will be an empty list
for has neighbors 5 3 has neighbor 4
comma 5 2 as neighbors for and this
court neighbor 20 okay so we just
specify the gradient structure we
specified what are the neighbors of each
four days and now we can again create a
loop like this so we copy this again and
we say for be in range at this time this
should be and let's create another
variable let's call it and two and this
should be length of edges and he left
stick and should be Co like this it
should be picked and pretty cool we can
try to run this so go over there again
run my code I should probably give a
line over here so let's just write this
print mm backslash in okay now we run
this
okay pretty cool we can see the code is
working fine we got neighbors for all
the six vertices so that's how we
implement adjacency list in Python or
using these two methods if you got any
queries you cannot ask me in the comment
section I'll be posting this code in the
description and if you liked the video
to it the like button and thanks for
watching
in this presentation we are going to
look at using adjacency lists in graph
theory so let G be a simple graph at the
vertex set v1 v2 v3 v4 v5 so value for
five vertices and that is the adjacency
list there v1 is a neighbor of is
adjacent to v2 v3 v4 v2 is adjacent to
v1 v3 v4 v5 and so on what we have to do
here is answer the two following
questions first off list the degree
sequence of G so let's see that one
first so v1 is connected to three
vertices so three and v2 is connected to
four so there's four three three and one
so how do we write at the degree
sequence we write it out as follows for
in descending order there you have it
there and descending order at four three
three three and one so now let's look at
drawing the graph here so I'm going to
sort of set it up here as follows
so we have five vertices this is v1 v2
v3 v4 and v 5 and let's see how they
connect up to one another so v1 is
connected to v2 v3 and v4 so that
connects there there and down there v2
is connected to all of the other four
vertices so it's already connected to
one there so it's connected to be three
let's connect it to be five and it
connects to vie for v3 and v4 so we've
already connected to v1 and v2 so all
that remains is just connected to be
four down there just going to color the
vertices back in here plus a v4 is
connected to v1 v2 and v3 so we've
actually have taken care of all of those
already lastly v5 is connected to v2 and
again that has also been connected
already 2v2 so that there is the graph G
and that ends our presentation thank you
hello everyone so far in this series on
data structures we have talked about
some of the linear data structures like
array linked lists stack and queue in
all these structures data is arranged in
a linear or sequential manner so we can
call them linear data structures and
we've also talked about tree which is a
nonlinear data structure tree is a
hierarchical structure now as we
understand data structures are ways to
store and organize theta and for
different kinds of data we use different
kinds of data structures in this lesson
we are going to introduce you to another
nonlinear data structure and that has
got its application in a wide number of
scenarios in computer science it is used
to model and represent a variety of
systems and this data structure is graph
when we study data structures we often
first study them as mathematical or
logical models here also we will first
study graph as a mathematical or logical
model and we will go into implementation
details later okay so let's get started
a graph just like a tree is a collection
of objects or entities that we call
nodes or vertices connected to each
other through a set of edges but in a
tree connections are bound to be in a
certain way in a tree there are rules
dictating the connection among the nodes
in a tree with n nodes we must have
exactly n minus 1 edges one edge for
each parent-child relationship as we
know an edge in a tree is for a
parent-child relationship and all nodes
in a tree except the root node would
have a parent would have exactly one
parent and that's why if there are n
nodes there must be exactly n minus 1
edges in a tree all nodes must be
reachable from the root and there must
be exactly one possible path from root
to a node now in a graph there are no
rules dictating the connection among the
nodes a graph contains a set of nodes
and a set of edges and edges can be
connecting nodes in any possible way
tree is only a special
kind of graph now graph as a concept has
been studied extensively in mathematics
if you have taken a course on discrete
mathematics then you must be knowing
about crafts already in computer science
we basically study and implement the
same concept of graph from mathematics
the study of graphs is often referred to
as craft theory in pure mathematical
terms we can define graph something like
this a graph G is an ordered pair of a
set V of vertices and a set of edges now
I'm using some mathematical jargon here
an ordered pair is just a pair of
mathematical objects in which the order
of objects in the pair matters this is
how we write and represent an ordered
pair objects separated by comma put
within parentheses now because the order
here matters we can say that V is the
first object in the pair and E is the
second object an ordered pair a B is not
equal to B a unless a and B are equal in
our definition of graph here first
object in the pair must always be a set
of vertices and the second object must
be a set of edges that's why we are
calling the pair an ordered pair we also
have concept of an ordered pair an
unordered pair is simply a set of two
elements order is not important here we
write an unordered pair using curly
brackets or braces because the order is
not important here an ordered pair a B
is equal to B a it doesn't matter which
object is first and which object is
second okay coming back so a graph is an
ordered pair of a set of vertices and a
set of edges and G equal V E is a formal
mathematical notation that we use to
define a graph now I have a craft drawn
here in the write this graph has 8
vertices and 10 edges what I want to do
is I want to give some names to these
vertices because each node in a graph
must have some identification it can be
a name or it can be an
index I'm naming these vertices as V 1 V
2 V 3 V 4 V 5 and so on and this naming
is not indicative of any order there is
no first second and third node here I
could give any name to any node so my
set of what he sees here is this we have
eight elements in the set v1 v2 v3 v4 v5
v6 v7 and v8 so this is my set of
vertices for this graph now what's my
set of edges to answer this we first
need to know how to represent an edge an
edge is uniquely identified by its two
endpoints so we can just write the names
of the two endpoints of an edge as a
pair and it can be a representation for
the edge but edges can be of two types
we can have a directed edge in which
connection is one way or we can have an
undirected edge in which connection is
two way in this example graph that I'm
showing here edges are undirected but if
you remember the tree that I had shown
earlier then we have directed edges in
that free with this directed edge that
I'm showing you here we are saying that
there is a link or path from vertex u to
V but we cannot assume a path from V to
u this connection is one way for a
directed edge one of the endpoints would
be the origin and the other endpoint
would be the destination and we draw the
edge with an arrowhead pointing towards
the destination for our edge here origin
is U and destination is V a directed
edge can be represented as an ordered
pair first element in the pair can be
the origin and second element can be the
destination so with this directed edge
represented as ordered pair UV we have a
path from u to V if we want a path from
V to u we need to draw another directed
edge here with V as origin and u as
destination and this edge can be
represented as ordered pair V you
the upper one here is UV and the below
one is vu and they are not same
now if the edge is undirected the
connection is two-way an undirected edge
can be represented as an unordered pair
here because the edge is bi-directional
origin and destination are not fixed we
only need to know what two endpoints are
being connected by the edge so now that
we know how to represent edges we can
write the set of edges for this example
graph here we have an undirected edge
between v1 and v2 then we have one
between v1 and v3 and then we have v1 v4
this is really simple I'll just go ahead
and write all of them so this is my set
of edges typically in a graph all edges
would either be directed or undirected
it's possible for a graph to have both
directed and undirected edges but we are
not going to study such graphs we are
only going to study graphs in which all
edges would either be directed or
undirected a graph with all directed
edges is called a directed graph or
digraph and a graph with all undirected
edges is called an undirected graph
there is no special name for an
undirected graph usually if the graph is
directed we explicitly say that it's a
directed graph or digraph so these are
two types of graph directed graph or
digraph in which edges are
unidirectional or ordered pairs and
undirected graph in which edges are
bi-directional or unordered pairs now
many real-world systems and problems can
be modeled using a graph graphs can be
used to represent any collection of
objects having some kind of pairwise
relationship let's have a look at some
of the interesting examples a social
network like Facebook can be represented
as an undirected graph a user would be a
node in the graph and if two users are
French there would be an edge connecting
them a real social network would have
millions and billions of nodes I can
show only few in my diagram here because
I am short of space
now social network is an undirected
graph because friendship is a mutual
relationship if I am your friend you are
my friend too so connections have to be
two-way now once a system is modeled as
a graph a lot of problems can easily be
solved by applying standard algorithms
in graph theory like here in this social
network let's say we want to do
something like suggest friends to a user
let's say we want to suggest some
connections to Rama one possible
approach to do so can be suggesting
friends of friends who are not connected
already Rama has three friends Ella Bob
and Katie and Friends of these three
that are not connected to Rama already
can be suggested there is no friend of
Allah which is not connected to Rama
already Bob however has three friends
storm Sam and Lea that are not friends
with Rama so they can be suggested and
Katie has two friends Lee and Swati that
are not connected to Rama we have
counted Li already so in all we can
suggest these four users to Rama
now even though we described this
problem in context of a social network
this is a standard crafts problem the
problem here in pure graph terms is
finding all nodes having length of
shortest path from a given node equal to
two standard algorithms can be applied
to solve this problem we'll talk about
concepts like path in a graph in some
time for now just know that the problem
that we just described in context of a
social network is a standard crafts
problem okay so a social network like
Facebook is an undirected graph now
let's have a look at another example
interlinked web pages on the internet or
the world wide web can be represented as
a directed graph of web page that would
have a unique address or URL would be a
node in the graph and we can have a
directed edge if a page contains link to
another page now once again there are
billions of pages on the web but I can
show only few here the edges in this
graph are directed because
relationship is not mutual this time if
page a has a link to page B then it's
not necessary that page B will also have
a link to page a let's say one of the
pages on my code school comm has a
tutorial on craft and on this page I
have put a link to Wikipedia article on
graph let's assume that in this example
graph that I'm showing you here page B
is my my code school tutorial on graph
with this address or URL my code school
comm / videos / graph and let's say page
Q is the Wikipedia article on graph with
this URL wikipedia.org
/ wiki / graph now on my page that is
page P I have put a link to Wikipedia
page and graph if you are on page P you
can click on this link and go to page Q
but wikipedia has not reciprocated to my
favor by putting a link back to my page
so if you are on page Q you cannot click
on a link and come to page P connection
here is one way and that's why we have
drawn a directed edge here okay now once
again if we are able to represent web as
a directed graph we can apply standard
graph theory algorithms to solve
problems and perform tasks one of the
tasks that search engines like Google
perform very regularly is web crawling
search engines use a program called web
crawler that systematically browses the
worldwide web to collect and store data
about web pages search engines can then
use this data to provide quick and
accurate results against search queries
now even though in this context we are
using a nice and heavy term like web
crawling web crawling is basically draft
traversal or in simpler words act of
visiting all nodes in a graph and no
prizes for guessing that there are
standard algorithms for craft traversal
and we'll be studying graph traversal
algorithms in later lessons okay now the
next thing that I want to talk about is
concept of a weighted graph sometimes in
a graph all connections cannot be
treated as equal some connections can be
preferable to others like for example we
can represent intercity through a
network that is the network of highways
and freeways between cities as an
undirected graph I am assuming that all
highways would be bi-directional
intra-city road network that is road
network within a city would definitely
have one-way roads and so intra-city
road network must be represented as a
directed graph but intercity road
network in my opinion can be represented
as an undirected graph now clearly we
cannot treat all connections as equal
here roads would be of different lengths
and to perform a lot of tasks to solve a
lot of problems we need to take lengths
of roads into account in such cases we
associate some weight or cost with every
edge we label the edges with their
weights in this case weight can be
lengths off the roads so what I'll do
here is I'll just label these edges with
some values for their length and let's
say these values are in kilometers and
now edges in this graph are weighted and
this graph can be called a weighted
graph let's say in this graph we want to
pick the best route from City a to city
D have a look at these 4 possible routes
I'm showing them in different colors now
if I would treat all edges as equal then
I would say that the green route through
B and C and the red route through E and
F are equally good both these paths have
3 edges and this yellow route through E
is the best because we have only two
edges in this path but with different
weights assigned to the connections I
need to add up weights of edges in a
path to calculate total cost when I'm
taking weight into account
shortest route is through B and C
connections have different weights and
this is really important here in this
graph actually we can look at all the
graphs as weighted graphs and unweighted
graph can basically be seen as a
weighted graph in which weight of all
the edges is same and typically we
assume the weight as 1
okay so we have represented inter-cities
road network as a weighted undirected
graph social network was an unweighted
undirected graph and World Wide Web was
an unweighted directed graph and this
one is a weighted undirected graph now
this was anticipated what I think
intra-city road network that is road
network within a city can be modeled as
a weighted directed graph because in a
city there would be some one-ways
intersections in intra-city road network
would be nodes and Road segments would
be our edges and by the way we can also
draw an undirected graph as directed
it's just that for each undirected edge
we'll have two directed edges we may not
be able to redraw our directed graph as
undirected but we can always redraw an
undirected graph as directed okay I'll
stop here now this much is good for an
introductory lesson in next lesson we
will talk about some more properties of
graph this is it for this lesson thanks
for watching
the following content is provided under
a Creative Commons license your support
will help MIT OpenCourseWare continue to
offer high quality educational resources
for free
to make a donation or view additional
materials from hundreds of MIT courses
visit MIT opencourseware at ocw.mit.edu
today we're going to sort of introduce
graph search in general and talk about
one algorithm which is breadth-first
search and understand how in principle
you could solve a puzzle like the
Rubik's Cube so before I get to rubik's
cubes let me remind you of some some
basic stuff about graphs or I can tell
you start out with graph search is about
exploring a graph and there's many
different notions of exploring a graph
maybe I give you some note on a graph s
and some other node in a graph T and I'd
like to find a path that's going to
represent a problem like I give you a
particular state of a Rubik's Cube and I
want to know is there some path that
gets me into a solve state I really want
to solve this on stage what the hell we
started all right so this is a
particularly easy state to solve which I
set it up this way alright so there you
go seven by seven by seven rubik's cube
solves in 10 seconds amazing new world
record so that you're given some initial
can state of the rubik's cube you given
the target state you know what solve
looks like you want to find this path
maybe you want to find all paths from s
maybe you just want to explore all the
nodes in a graph that you can reach from
s maybe you want to explore all the
nodes in a graph or maybe all the edges
in the graph these are all exploration
problems they're all going to be solved
by algorithms from this class and next
class so before we go further though I
should remind you what a graph is and
sort of basic features of graphs that
we're going to be using this is all 6 of
14 material so you should know it very
well
if you don't there's an appendix in the
textbook about it we have a set of
vertices we have a set of edges
okay edges are either unordered pairs so
sets of two items or ordered pairs in
this case we call the graph undirected
in this case we call the graph directed
usually there's only one type either all
the edges are directed or all the edges
are undirected there is a study of
graphs that have both but we are not
doing that here so some simple examples
here's a graph this is an undirected
graph
this is a directed graph okay set of
vertices here is ABCD set of verses here
is ABC set of edges here is so e is
going to be things like a b c c c d i
think you get the idea
just for completeness V is ABCD just so
you remember of notation and so on one
of the issues we're going to talk about
in this class is how do you represent a
graph like this for an algorithm so it's
all fine to say oh this is a set of
things this is a set of things an
obvious representation is you have a
list or an array of vertices you have an
array of edges each edge knows as two
endpoints that would be a horrible
representation for graph because if
you're I don't know you're at vertex a
and you want to know what are the
neighbors of a B and C you have to go
through the entire edge list to figure
out the neighbors of a so it's been
linear time just to know where you can
go from a so we're not going to use that
representation we're going to use some
better representations something called
adjacency lists cool okay over here
you've got things like AC BC and CB so
you can have edges in both directions
what am I missing
ba that's e in that case there whole lot
of applications of graph search I make
you a little list talk about a few of
them so we've got web crawling your
Google you want to find all the pages on
the web most people don't just tell you
hey I've got a new page please Index it
you have to just keep following links in
the early days of the web this is a big
deal following links finding everything
it's out there it's a little bit of an
issue because if you define it wrong the
Internet is infinite because of all this
dynamically generated pages but to deal
with that google goes sort of
breadth-first for the most parts to
prioritize but you from you want to see
all the things you can reach from pages
you already have and keep going at some
point you give up and you run out of
time social networking and Facebook use
friend finder it tries to find the
friends that are nearest to you or
friends of friends is sort of a level to
search that's essentially a graph search
problem you want to know what's two
levels or three levels of separation
from you and then you go you look loop
over those and look for other signs that
you might be good friends you're on a
network like the internet or some
intranet you want to broadcast a message
so here's you you want to send data out
that's essentially a graph exploration
problem that message that packet is
going to explore the graph garbage
collection I hope you all know that
modern languages have garbage collection
this is why you don't have to worry
about freeing things even in Python even
in C Python I learned there is a garbage
collector as a version two but also in
pi PI and Jai thon and in Java and like
pretty much every fairly modern language
you have garbage collection meaning if
there's some data that's unreachable
from so you have your variables whatever
is actively in variables that can be
accessed by the program everything is
reachable from there you have to keep
but if some data structure becomes no
longer reachable you need to you can
throw it away and regain memory and so
that's happening behind the scenes all
the time and the way it's being done is
with the breadth-first search which is
what we're going to talk about
today another one model checking model
checking is you have some finite model
of either a piece of code or a circuit
chip whatever you want to prove that it
actually does what you think it does
and so you've drawn a graph which is the
graph is all the possible states that
your circuit or your computer program
could reach or that it could possibly
have you started some initial state and
you want to know among all the states
that you can reach does it have some
property and so you want need to visit
all the vertices that are reachable from
a particular place to do that and
usually people do that using
breadth-first search I use breadth-first
search a lot myself to check
mathematical conjectures so if you're a
mathematician and you want you think
something is true like maybe well it's
hard to give an example of that but you
have you can imagine some graph of all
the possible sort of inputs to that
theorem and you will need to check them
for every possible input this is true
typical way to do that is breadth-first
searching through that entire graph of
states usually we're testing finite
special cases of a general conjecture
but if we find a counter example we're
done don't have to work on it anymore
if we don't find a counter example
usually then we have to do the
mathematics so it's not doesn't solve
everything but it's helpful
and then the fun thing we're going to
talk about a little bit today is if you
want to solve something like a 2x2 2x2
Rubik's Cube optimally you can do that
using breadth-first search and you're
going to do that on your problem set do
it solving this one optimally using
breadth-first search would probably what
would definitely take more than the
lifetime of the universe so don't try 7
by 7 by 7 leave that to the cubing
experts I guess no I think no one will
ever solve a 7 by 7 by 7 Rubik's Cube
optimally but there are ways to find a
solution just not the best one okay so
let me tell you just for fun as an
example this pocket cube which is 2 by 2
by 2 rubik's cube what we have in mind
is it's called the configuration graph
or sometimes configuration space but
it's a graph so graph this graph has a
vertex for each possible state of the
cube so this is a state little quickie
here this is a state this is a state
this is a state now I'm hopelessly lost
ok
anyone want to work on this board no one
all right leave it I'm so thin ok so all
those are vertices there's actually a
lot of vertices there are 264 million
vertices or so if you want on the side
here number of vertices is something
like 8 factorial times 3 to the eighth
and one way to see that
try to vet to vet your Rubik's Cube so
these are these guys are yeah these are
what you might call cubelets or cubes i
think is standard term in rubik's cube
land and so the how there's eight of
them and a two by two by two two cubed
you can essentially permute those cubies
within the cube however you like that's
eight factorial and then each of them
has three possible twists it could be
like this it could be like this or it
could be like this okay so you've got
three for each and this is actually an
accurate count you're not over counting
the number of configurations all of
those are at least in principle
conceivable if you take apart the cube
you can reassemble it in each of those
states and that number is about 264
million okay which is not so bad for
computers you could search that life is
a little bit easier you get 2 divided by
24 because there's 24 symmetries of the
cube 8 times 3 you can divide by 3 also
because only 1/3 of the configuration
space is actually reachable if you're
not allowed to take the parts apart you
have to get there by emotion you can
only get to 1/3 of the 2 2 by 2 by 2 so
it's a little bit smaller than that if
you're actually doing a breadth-first
search which is what you're going to be
doing on your problem set but in any
case it's feasible
okay that's vertices should talk about
edges
for every move every move takes you from
one configuration to another you could
traverse it in one direction I'll make
that move you could also undo that move
because every move is undoable in a
rubik's cube this graph is undirected or
you can think of it as every edge works
in both directions so so this is a move
is called a quarter twist sum it's a
controversy if you will some people
allow whole half twists as a single move
whether you define that as a single move
or a double move not that big a deal
just changes some of the answers but
you're still exploring essentially the
same graph so that's the graph and you'd
like to know some properties about it so
let me draw a picture of the graph I'm
not going to draw all 264 million
vertices but in particular there's the
solved state we kind of care about that
one
where all the colors are aligned then
there's all of the configurations you
could reach by one move so these are the
possible moves from solve state and then
from those configurations there's more
places you can go maybe there's multiple
ways to get to the same node ok but
these would be all of the configurations
you can reach in two moves
okay and so on and at some point you run
out of graph so there might be some ways
to get there might be a few things she
nodes out here these are kind of the way
I'm drawing this this is everything you
can reach in one move and two moves and
three moves at the end this would be 11
moves if you if you allow half twists
and I guess as puzzlers we're
particularly interested in this number
which you would call as a graph theorist
the diameter of the graph puzzlers call
it God's number if you were God or some
money something being you have the
optimal algorithm for solving the
Rubik's Cube how many moves do you need
if you always follow the best path and
the answer is in the worst case 11 so
we're interested in the worst case of
the best algorithm for 2 by 2 by 2 the
answer is 11 for 3 by 3 by 3 the answer
is 20 that was just proved last summer
with a couple years of computer time for
4 by 4 by 4 I don't have one here I
think we'll never know the answer for 5
by 5 by 5 we'll never know the answer
for 6 4 7
same deal but 4 2 by 2 by 2 you can
compute it you will compute it on your
problem set and it's kind of nice to
know because it says whatever
configuration I'm in I can solve it in
11 moves but the best known way to
compute it is basically to construct
this graph one layer at a time until
you're done and then you know what the
diameter is the trouble is in between
here this grows exponentially at some
point it decreases a little bit but
getting over that exponential hump is
really hard and for 3 by 3 by 3 they
used a lot of tricks to speed up the
algorithm but in the end it's
essentially breadth-first search
what's a breadth-first search this going
layer by layer so we're going to
formalize that in a moment
but that is the problem
so just for fun any guesses what the
right answer is for an N by n by n
rubik's cube what's the diameter not an
exact answer because i think we'll never
know the exact answer but if i want data
something what do you think that
something is how many people here solved
a Rubik's Cube ever okay so you know
what we're talking about here
most people have worked on you think
about an N by n by n rubik's cube each
side has area N squared so total areas
surface area is 6n squared so it's
roughly Stata N squared little cubes
here
so what do you think the red asymptotics
is for n by n by n now guesses
and cubes reasonable guess but wrong
it's an upper-bound yn cubes
oh you're guessing based on the numbers
yes the numbers are misleading
unfortunately it's love love small
numbers I guess doesn't really look
right I know the answer I know the
answer because we just wrote a paper
with the answer this is a new result
from this summer but I'm curious to me
the obvious answer is N squared because
there's about N squared Q B's and it's
not so hard to show in a constant number
of moves you can solve a constant number
of cubies if you think about the general
algorithms like if you've ever looked up
professor's cube how to solve it you're
doing like 10 moves and then you saw
maybe swap two cubes which you can use
to solve a couple cubes in a constant
number of moves so N squared would be
the standard answer if you're following
standard algorithms but it turns out you
can do a little bit better the right
answer is N squared divided by log in I
think it's cool
hopefully you guys can appreciate that
not a lot of people can appreciate N
squared divided by log n but here in
algorithms we're all about and squared
over log in
so if you're interested papers on my
website things called algorithms for
solving Rubik's cubes there's a constant
their current constant is not so good
let's say it's in the millions but hey
you got to start somewhere
there's the next work the next open
problem would be to improve that
constant to something reasonable that
maybe is close to 20 but we're far from
that okay let's talk about graph
representation before we can talk about
exploring a graph we need to know what
we're given as input and there's
basically one standard representation
and a bunch of variations of it and
they're called adjacency lists so the
idea with an adjacency list is you have
an array called a DJ for adjacency of
size V each element in the array is a
pointer to a linked list and the idea is
that this array is indexed by a vertex
so we're imagining a world where we can
index arrays by vertices so maybe you
just label your vertices 0 through V
minus 1 then that's regular array or if
you want to get fancy you can think of a
vertex as an arbitrary hashable thing
and adj is actually a hash table and
that's how you probably do it in Python
maybe your vertices are objects and this
is just hashing based on the address the
object but we're not going to worry
about that just going to write adj if
you assume that somehow you can get the
linked list corresponding with that
vertex
and the idea is for every vertex we just
store its neighbors namely the vertices
you can reach by one step from you so
I'm going to define that a little more
formally adj of U is going to be the set
of all vertices V such that UV is an
edge
okay so if you have a vertex where's
where my graphs here so if I have a
vertex like B a G of B is going to be
both a and C because in one step there
are outgoing edges from B to a and B to
C so a GJ of B is a see in that graph
should label the vertices something
different
adj of a is going to be just C because
you can't get from once with one step
from A to B there's a the edges in the
wrong direction okay an Ag G of C is B
okay I think that definition is pretty
clear for undirected graphs you just put
braces here which means you store I mean
it's the same thing for here adj of C is
going to be a B and D as you can get in
one step from C to a from C to B from C
to B this for pretty much every at least
for graph exploration problems this is
the representation you want because
you're at some vertex you want to know
where can I go next and adj of that
vertex tells you exactly where you can
go next so this is what you want there's
a lot of different ways to actually
implement adjacency lists
I've talked about two of them you could
have the vertices labeled zero to V
minus one and then this is literally an
array and you have I guess I should draw
in this picture adj is an array so
you've got a B and C each one of them is
a pointer to a linked list this one's
actually going to be a C and we're done
this one in oh sorry that was B B who
said it had to be alphabetical order a
is pointer to C C is a pointer to be
okay that's explicitly how you might
represent it this might be a hash table
instead of an array if you have weirder
vertices you can also do it in a more
object-oriented fashion you could for
every vertex V you can make V the
vertices objects and V dot neighbors
could store what we're defining over
there to be a DJ of V okay this would be
the more object-oriented way to do it
I've thought a lot about this and that I
like this and usually want to implement
graphs this is what I do but it is
actually it's convenient to have this
representation there's a reason the
textbook uses this representation
because if you've already got some
vertices lying around and you want to
have multiple graphs on those vertices
this lets you do that if you can define
multiple adj arrays one for graph one
one for graph two one for graph three
they could all talk about the same
vertices whereas here if vertex can only
sort of belong to one graph it can only
have one neighbor structure that says
what happens if you're only dealing with
one graph this is probably cleaner but
with multiple graphs which will happen
even in this class Jason see lists are
kind of the way to go you can also do
implicitly represented graphs
which would be to say a DJ of you is a
function or V Nabors is a method of the
vertex class okay meaning it's not just
stored there explicitly whenever you
need it you call this function and it
computes what you want this is useful
because it uses less space you could say
this uses zero space or maybe V space
for one for each vertex depends maybe
you don't even need to explicitly
represent all the vertices you start
with some vertex and given a vertex
somehow you know how to compute let's
say in constant time or linear time or
something
the neighbors of that vertex and then
from there you could keep keep search
and keep computing neighbors until you
find what you want maybe you don't have
to build the whole graph you just need
to be able to build enough of it till
you find your answer whatever answer
you're searching for
you think of a situation where that
might be the case where implicit
representation would be good idea yeah
Rubik's cubes you're really good I never
want to build this space it has a
bajillion States bajillion vertices it
would take forever there's more
configurations of this cube than there
are particles in the known universe yeah
just computed that in my head I have
done this computation recently for five
by five by five it's like 10 to the 40
States
or 10 to the somewhere 10 to the 40 10
to the 60 there's about 10 to the 80
particles in the known universe 10 to 83
or something so this is probably I don't
- 10 to the 200 or so it's a lot you
never want to build that but it's very
easy to represent this state just store
where all the cubes are and it's very
easy to see what are all the
configurations you can reach in one move
just try this move
this move try this move put it back and
try the next move and so on so in you
know time for an N by n by n cube in
order n time you can list all the order
n next States you can list all the order
and neighbors and so you could keep
exploring searching for your state now
you don't want to explore too far for
that cube but at least you're not you're
not hosed just from the problem of
representing the graph so it for even
for 2 by 2 by 2 it's useful to do this
mostly to save space you're not really
saving time but you don't you'd like to
not have to store all 264 million states
because it's going to be several
gigabytes and it's annoying speaking of
space ignoring the implicit
representation how much space does this
representation require
v+ e it's going to be our the bread and
butter of our graph algorithms most of
the things we're going to talk about a
TV plus e time this is essentially
optimal it's linear in the size of your
graph we've got V vertices edges
technically if in case you're curious
this is really the size of V plus the
size of E but in the textbook and I
guess in the world we just omit those
sizes of whenever they're in a theta
notation or Big O notation so a number
of vertices plus number of edges that's
sort of the bare minimum you need if you
want an explicit representation of the
graph and we achieve that because we've
got V space just to store the vertices
in an array and then if you add up all
each of these is an edge to be a little
careful in undirected graphs each of
these is a half edge so there's actually
two times e nodes over here but Stata e
so theta V + e the amount of space for
need and ideally all our algorithms will
run in this much time is that that's
what all you that's what you need just
to look at the graph okay
so let's do an actual algorithm is
breadth-first search so - the simplest
algorithm you can think of graphs I've
already outlined it several times you
start at some node you look at all the
nodes you can get to from there you look
at all the nodes you can get you from
there
keep going until you're done so this is
going to explore all of the vertices
that are reachable from a node the
challenge the one annoying thing about
breadth-first search and why this is not
trivial is that there can be some edges
that go sort of backwards like that to
some previous layer actually that's not
true is it this can't happen see why
because if that if that edge existed and
from this node you'd be able to get here
so in an undirected graph that can't
happen in a directed graph you could
conceivably have a back edge like that
you have to realize oh that's the vertex
I've already seen I don't want to put it
here even though it's something I can
reach from this node because I've
already been there you've got to worry
about things like that yeah that's I
guess the main thing to worry about
so our goal is to visit all the nodes
vertices reachable from given a s we
want to achieve V Plus E time and the
idea is to look at the nodes that are
reachable first in 0 moves 0 moves
that's s then in one move well that's
everything you can reach from s in one
step that's adjacency of s and then 2
moves and 3 moves and so on until we run
out of graph ok but we need to be
careful to avoid duplicates we want to
avoid revisiting vertices for a couple
reasons one is if we didn't we would
spend infinite time because we just go
there and come back and go there and
come back as long as there's at least
one cycle you're going to keep going
around the cycle forever and ever if you
don't try to avoid duplicates all right
so let me write down some code for this
algorithm it's pretty straightforward
but so straightforward we can be
completely explicit and write code
a few different ways to implement this
algorithm I'll show you my favorite
textbook has a different favorite I'm
going to write in pure Python I believe
almost done
okay got that right so this is at the
end of the while loop
and at that point we should be done we
could do an actual example maybe
I'm going to do it on a direct us or an
undirected graph but this algorithm
works just as well on directed and
undirected graphs okay there's an
undirected graph we're given some start
vertex s and we're given the graph by
being given the adjacency lists so you
could iterate over the vertices of that
thing given a vertex you can list all
the edges you can reach in one step and
then the top of the algorithm is just
some initialization the basic structure
we have this thing called the frontier
which is what we just reached on the
previous level I think that's going to
be level I minus 1 just I want to make
an index error these are going to be all
the things you can reach using exactly I
minus 1 moves and then next is going to
be all the things you can reach in I
moves okay so to get started what we
know is s S is what you can reach in 0
moves so we set the level of s to be 0
that's the first line of the code
there's this other thing called the
parent we'll worry about that later it's
optional just it gives us some other fun
structure we sent I to be 1 because we
just finished level 0 frontier of what
you can reach in level 0 is just s
itself so we're going to put that on the
list that is level 0 I equals 1 so 1
minus 1 is 0 all good and then we're
going to iterate and this is going to be
looking at that the end of the iteration
is to increment I so you could also call
this a for loop except we don't know
when it's going to end so it's easier to
think of I incrementing each step
not knowing when we're going to stop
we're going to stop whenever we run out
of nodes so whenever frontier is a
non-empty list and the bulk of the work
here is computing what the next level is
that's called next it's going to be
level I we do some computation
eventually we have what's on the next
level that we set frontier next so
because that's our new level we
increment I and that invariant of
frontier being level I minus one is
preserved right after here and then we
just keep going till we run out of notes
how do we compute next well we look at
every node on the frontier and we look
at all the nodes you can reach from
those nodes so every node you and the
frontier and then we look at so this
means there's an edge from u to V or the
picture we look at all the edges from
all the frontier nodes where you can go
and then the key thing is we check for
duplicates we see have we seen this node
before if we have we would have set its
level to be something if we haven't seen
it it will not be in the level hash
table the level dictionary and so if
it's not in there we'll put it in there
and add it to the next layer so that's
how you avoid duplicates we set its
level to make sure you will never visit
it again you add it to the next frontier
you iterate you're done okay this is one
version of what you might call
breadth-first search and it achieves
this goal visiting all the nodes
reachable from s in linear time let's
see how it works on a real example
so first frontier is this thing frontier
just has the node s so we just look at s
and we look at all the edges from s we
get a and X so those get added to the
next frontier maybe before I go too far
let me switch colors
Multimedia here oh so here's level 1 all
of these guys have we're going to set
their level to 1 they can be reached in
one step that's pretty clear so now
frontier is a and X will go to that's
what next becomes then frontier becomes
next and so we look at all the edges
from a that's going to be s and z s
we've already looked at it already has a
level set so we ignore that so we look
at Z Z does not have a level indicated
here so we're going to set it to AI
which happens to be 2 at this point then
we look at X it has neighbors s D and C
we look at s again we say oh we've
already seen that yet again
so we're worried about this taking a lot
of time because we look at s 3 times in
total then we look at D D hasn't been
set so we set it to 2 C hasn't been set
so we set it to two so the frontier at
level two is that ok then we look at all
the neighbors of Z there's a A's already
been set look at all the neighbors of D
there's X or C those have been set
there's F this one gets added then we
look at C there's X that's been done DS
been done F's been done V has not been
done so this becomes a frontier at level
three then we look at level three F
these been done C's been done B's been
done that we look at V C's been done s
been done nothing to add to next next
becomes empty frontier becomes empty the
while loop finishes
tada we've computed we visited all the
vertices questioned
yeah
what this is Python notation you may
have heard of Python this is a
dictionary whose which has one key value
s and has one value zero so you could
you could yeah that's shorthand in
Python for usually you have a comma
separated list the colon is specifying
key value pairs okay I didn't talk about
parent we can do that a little bit so
parent we're initializing to say parent
of s is nobody and then whenever we
visit a new vertex V we said its parent
to be the vertex that we came from so we
had this vertex V we had an edge to V
from some vertex u we set the parent of
V to be u so let me add in what that
becomes will change colors yet again
although it gets hard to see any color
but red let's see so we have s when we
visited a then the parent of a would
become s when we visited Z the parent of
Z would be a parent of X is going to be
s kind of D is going to be X pan of C is
going to be X parent of F it could have
been either way but the way I did it D
went first and so that became its parent
and I think the C was its parent okay so
that's what the parent pointers will
look like they always follow edges they
actually follow edges backwards if this
was a directed graph graph might be
directed that way but the parent
pointers go back along the edges so it's
a way to return it's a way to return to
s if you follow these pointers all roads
lead to s ok because we started at s
that's the property we have in fact
these pointers always form a tree and
the root of the tree is s in fact these
pointers form what are called shortest
paths let me write down a little bit
about
this shortest-path properties
if you take a node and you take its
parent and take the parent of the parent
and so on eventually you get to s and if
you read it backwards that will actually
be a path in the graph and it will be a
shortest path in the graph from s to V
meaning if you look at all paths in the
graph that go from s to V so say we're
going from s to V how about that we
compute this shortest we compute this
path out of BFS which is follow a parent
of V is C prime of C is X parent of X is
s read it backwards that gives us a path
from s to V the claim is that is the
shortest way to get from s to V might
not be the only one like if you're going
from s to F there's two short paths
there's this one of length three there's
this one of length three just three
edges same length and in the parent
pointers we can only afford to encode
one of those paths because in general
there might be exponentially many ways
to get from one node to another we find
a shortest path not necessarily the only
one and the length of that path so
shortest here means that you use the
fewest edges and the length will be
level of V that's what we're keeping
track of the level 0 you can get there
with 0 steps if the level is 1 you can
get there with 1 steps because we're
visiting everything you can possibly get
in K steps the level is telling you what
that shortest path distance is and the
parent pointers are actually giving you
the shortest path that's the cool thing
about BFS yeah BFS explores of vertices
sometimes that's all you care about but
in some sense what really matters is it
finds the shortest way to get from
anywhere to anywhere for a rubik's cube
that's nice because you run the shortest
path
you run BFS from the start state rubik's
cube then you say oh I'm in this state
you look up this state you look at its
level it says oh you can get there in 9
steps that's I think the average so I'm
guessing I don't know how to do this in
10 steps
and then great so now you know how to
solve it you just look at the parent
pointer the parent pointer gives you
another configuration Co what move was
that and then you do that move
I'm not going to solve it then you look
at the parent pointer that you do that
move look at the parent pointer that you
do that move eventually you will get to
the solved state and you will do it
using the fewest possible moves so if
you can afford to put the whole graph in
memory which you can't for big Rubik's
Cube but you can for a small one then
this will give you the a strategy the
optimal strategy God's algorithm if you
will for every configuration it solves
all of them is great what is the running
time of this algorithm I claim that's
order V + E but it looked a little
wasteful because it was checking
vertices over and over and over but if
you think about it carefully you're only
looking it's the right way to say this
you only check every edge once or in
undirected graphs you check them twice
once from each side when I visit a
vertex enters the frontier only once
because once it's in the frontier it
gets a level set and once it has a level
set it'll never go in again it'll never
get added to next so you know s gets
added once then we check all the
neighbors of s a gets added once then we
check all the neighbors of a X each of
these guys gets added once we check all
the neighbors so the total running time
is going to be the sum over all vertices
of the size of the adjacency list of B
so this is the number of neighbors that
V has and this is going to be answer
twice the number of edges for undirected
graphs it's going to be the number of
edges for directed graphs this is the
handshaking lemma if you don't remember
the handshaking lemma you should read
the textbook just double o6o for two
stuff because you basically visit every
edge twice for directed graphs you visit
every edge once but it's order e we also
spend order V because we touch every
vertex so total running time is order V
+ e in fact the way this is going you
can be a little tighter and say it's
order e I just want to mention in
reality sometimes you don't care about
just what you can reach from s you
really want to visit every vertex then
you need another outer loop that's
iterating over all the vertices as
potential choices for s and you then can
visit all the vertices in the entire
graph even if it's disconnected we'll
talk more about that next class that's
it for BFS
all right in this video I just want to
talk a little bit about some graph
theory and just some basic terminology
and ideas they get used so definitely
not going to be a you know a complete
version of everything you need to know
but definitely some basic ideas so graph
theory got started by really kind of I
think really came about by Leonardo and
what he did is he solved a problem the
famous bridge of coningsburgh problem
and that kind of a put graph theory sort
of out there for people to start
thinking about and for a while graph
theories kind of kind of poo-pooed on it
was kind of considered I think sort of a
recreational branch of math not really a
ton of uses but uh definitely with the
advent here of computer science that's
changed all that graph theory gets used
all the time in computer science lots of
other places as well
definitely become a very hot area to
research and I like it just because the
problems are easy to understand you can
draw pictures and visualize I definitely
enjoy it but let's see so the definition
of a graph that we're going to use and
these vary again from person to person
things still aren't really set in stone
a lot of the notation and definitions
but for us a graph is going to be a
non-empty finite set of vertices some
people will let it be infinite with a
set of two elements subsets of V we call
the elements of V vertices and the
elements of a are called edges so that
sounds may be a little more confusing
that it is all a graph is it's just dots
and lines connecting that's all a graph
is okay so we talked about graph theory
we're not talking about y equals x
squared
just just points and lines connecting
them so we would say the vertex set V
for this
graphs maybe we'll call it G are just v1
v2 v3 v4 v5 and v6 and you can think
really you know maybe these are just six
people at a party and v1 knows v2 v3 v4
you can see that v5 only knows person v4
and v6 maybe that's what an edge
represents is if they know each other
okay you know and you can make the edges
represent whatever you want to so maybe
we'll just think about the edges as
meaning there's a connection between
them and they know each other so the
edge set that's just going to be all two
elements subsets and basically we just
list all the vertices that have an edge
between them so v1 and v2 v1 and v3 v1
and v4
let's see v4 is connected to V 5 and
then vertex V 5 is connected to V 6 and
I think that's everything we need you
know we don't need to list V 6 is
connected to V 5 for example it's just
redundant already so if I had you know
again basically just this set in this
set e again it's just basically telling
me all the information in this original
graph so I still know that a couple
things the cardinality the cardinality
of a graph just represents the number of
vertices
the notation I've seen is they'll put an
absolute value so the absolute value of
G the cardinality of G is just the
number of vertices which in this case is
six
let's see another thing that we often
talk about is the degree of a vertex so
for example the degree of vertex v1
which will abbreviate little deg v1 all
that tells you is the number of edges
coming out from vertex v1 so there's one
two three edges leaving v1 so we would
say the degree of vertex v1 is three
again so vertex v1 knows three other
people is all that says another kind of
convention for a typical graph we don't
let a vertex have a loop back to itself
okay I mean definitely that certainly
happens in a lot of applications but
when we lao graphs to have loops back to
themselves typically people will call
those multi graphs so multi grass have
loops regular graphs don't have loops so
pretend that loops not there and we just
got the original the original matrix
that we are the original graph we
started with a couple other things to
the way that you draw the graph is
irrelevant
so here's V one here's V two here's V
three here's V 4 V 5 down there I want
to make it too crazy v 6 you know they
don't have to be straight lines they can
be whatever they want so okay so V 1 is
still connected to V 2 V 1 should still
be connected to V 3 V 1 is still
connected to V 4
we'll have v4 still connected to v5 and
hey v5 is still connected to vertex v6
so all the original connections are
still preserved and there's sort of no
new connections in there that weren't
there before
so when you have a graph where basically
all the original information is
preserved the original connections
there's no new connections there's
nothing missing and again this is very
kind of loose definition but we would
say that the original graph and this new
graph are isomorphic and all that means
is from a graph theory point of view
they're one in the same they're exactly
the same graph okay so typically tribuna
will try to draw them as a you know in
the least confusing manner as possible
but definitely an important idea the way
that you draw the graph in general
doesn't matter let's talk about a couple
other ideas just a way to describe a
graph one way is with what's called an
adjacency list and I don't know how
useful these are I never really saw them
much but again I didn't take a
tremendous amount of graph theory so
that doesn't mean that they don't get
used all the time and I just haven't ran
into it but all an adjacency list is
exactly what you think so all we do is
just list vertex that our vertices that
are adjacent so for v1 it's adjacent to
v1
excuse me fee one's adjacent to v2 v3
and v4
so we'll list those v2 v3 v4 vertex V 2
is only adjacent to v1 v3 is only
connected to v1 v4 is connected to V 1
and V 5
v5 is connected to v4 and v6 and v6 is
connected to v5 and again it's just
another way of summarizing you know so
this is Jason C list this set V in the
set E and this graph again are telling
me all the exact same information
another way that I know gets used all
the time is instead of doing an
adjacency list we'll make what's called
an adjacency matrix okay so I'm going to
imagine v1 v2 v3 typically people won't
even write these but you know this is
what makes sense to me so a lot of times
I used to always stick them in there v1
v2 v3 v4 v5 v6 all we do is if there's a
loop if there's a connection from a
vertex to another vertex we'll put a 1
and if there's not we'll put a 0 so
since there's not a loop from v1 to v1
we'll put a 0 there but v1 is connected
to v2 v3 and v4 so V once connected to
v2 v3 and v4 but it's not connected to
v5 or v6 there's not an edge present
likewise v2 is only connected to v1 so
we'll put a 1 there and then we'll put
zeros everywhere else
let's see v3 is also only connected to V
ones we'll put a 1 there and zeros
everywhere else v4 is connected to v1
and also to v5 so we'll put ones there
zeros everywhere else v5 is connected to
v4 and v6 so put ones there zeroes
everywhere else
lastly v6 is only connected to v5 so
we'll put a one there
and zeros everywhere else so this is
nice because you can do math of major
Z's ok so definitely there's a lot of
study done with you know matrix
representations of graphs you can do
stuff with them two less things just
maybe two last ideas notice for any
vertex here if you you know so imagine
maybe these are islands now and there's
a little bridge connecting the islands
notice in this this graph if you ever
were to leave an island suppose I was at
Island v1 and I went to Island v4 the
only way I can get back to Island v1 is
the sort of backtrack you know I could
go all the way to v5 and v6 but
eventually to get back I have to take
you know the bridges back so there's no
loops or what are called circuits if
there are no loops or circuits we say
that this is an example of a what's
called a tree and the idea with trees is
you can always sort of rewrite them and
the reason why we call them trees is we
sort of can rewrite them you know so
here's v1 it's connected to V 2 V 3 V 4
V 4 is connected to V 5 and V five is
connected to V 6 so again these would be
isomorphic graphs but now it's kind of
if you flip it over and maybe it had
some more branches the idea that starts
to look like a tree trees get used all
the time for example you know imagine a
chess algorithm you know it's the first
move you know maybe you've got one two
three reasonable reasonable moves that
you're disposable at your disposal not
disposable at your disposal
you know and then maybe you know once
you consider this move maybe there's
only one logical move from that and then
from that there's only one logical move
so trees can help sort of represent sort
of searches you know a computer search
so definitely one place I know for sure
that they get studied again if a graph
so maybe this is a whole separate little
graph over here this graph we would say
has a circuit and the idea is a circuit
you know for example if I met this
vertex I can leave that vertex and still
manage to get back to it without really
ever backtracking through through an
edge or a vertice I don't have to visit
the same place twice as all it says ok
so this would be an example of a graph
that does have a circuit so graph theory
I think is really interesting you know
there's tons of open problems if you're
a budding math person out there and what
some challenging problems
there's definitely tons of open graph
theory problems that are very simple to
understand you know definitely you've
got to learn some of the techniques to
be able to attack things but a lot of it
is very sort of intuitive and I think
open you know sort of it's very user
friendly because what I'm trying to say
there's still some reasonable open
problems out there for people to tackle
for sure so if you are interested in
kind of getting your hands wet and doing
some harder problems
I say graph theory is a great place to
start maybe I can even post some open
questions so all right I hope this
little introduction makes some sense you
get nothing too heavy I definitely plan
on doing some more you know detailed
stuff but again hopefully this is a good
little warm-up and just a good little
intro to some of the ideas
