welcome to our 27th video with data
structures and algorithms we're going to
continue with graphs probably should
have done this one before the last two
videos but that's okay let's do it now
we're going to do a jason see lists and
adjacency matrices so we let's start off
with an adjacency list we're going to
kind of go in a different direction here
now this is what this is a
representation of our graph so let's do
some practice with converting this into
an adjacency matrix so firstly with the
adjacency matrix what we're going to
write a 1 if there's an edge between the
two right and we're going to write zeros
otherwise right so we're going to start
from a left right this will be the nodes
that are in the actual array here and
these will be its adjacency list this is
top the columns ok you'll see what I
mean in a second so for a in its
adjacency list we have C D and G so
along this row we are going to write
ones at C oh let's say at C D and G now
everything else is going to be zeroes
we're going to write in zeroes later so
that we can kind of visualize this a
little better let's keep going so with B
it has a jason Siletz with e all right
so E is in its adjacency list it's
connected to visit there's an edge from
B to e C has an edge right it has a
self-loop D also has a self-loop it also
has an edge from D to E and there's also
an edge from D to F with e U has an edge
to G all right has a direct path to G F
has a path to B right an edge between F
and B and another edge there's another
edge between G are from G to B ok so
that's kind of what our matrix
looks like now this is a directed graph
and we know that because this is not
symmetrical okay that means there's not
an edge you can see this is an edge from
A to C but there is not an edge from C
to a okay so this is this is a directed
graph so now let me just pick a
different color and we're going to put
in zeros okay for the rest of this just
to be a little bit more complete okay
that's a lot of zeros I know just hang
with me for a second
zero zero all these zeros fun times
there we go here we go zero zero zero
zero okay and there we go so that's what
our adjacency matrix looks like for this
graph now let's do a little something
else let's translate this into the graph
like a visual representation that we are
used to so I'm kind of running out of
space here so we're going to have to
kind of go back and forth that's okay so
let's start with node a so we have a
node a here let's put it like this okay
and we know that there's an edge from A
to C so I'm going to put C up here okay
there's that there's also an edge from A
to D so let's draw a D node and we'll do
an edge there and then another one to G
so we're going to put G down here okay
there we go that's our first one you did
the same looking at this right so
looking at this we're going to show
another one but we'll do it from this
side so let's do B from this side so B
has an edge there's an edge from B to e
right here so let's do that
so let's do be down here and there's
another ed right there's a edge from B
to e so we're going to put e right here
okay
make that a little better well that's
not better at all that's okay
so next one is C right C has a self loop
you can see that right here if you'd
like to look at this one instead right
there's a one at C C so there is a self
loop on C for D D has an edge from D to
D so this also has a self loop there's
an edge from D to e okay so let's do
that here I've horrible arrows all right
let's just clean that one up a bit it's
a little better and there's also an edge
from D to F so f is not on here so let's
draw our F node okay so there's that he
has an edge to G so let's scroll down so
we can make a little loop here so we
have a edge from E to G and from F we
have an edge to be you know what I'm
going to redraw this to come over here
and F has an edge to be there we go you
don't have to cross lines and then G
also has an edge to be able to go that
works out good stuff okay so there is
our graph right now let's do some more
exercise while we're here and let's do
on line just a second here let's grab my
color I'll have the right color I lost
it so let's do this
okay let's do depth-first search on this
depth-first search just for some
practice and let's start from here
actually we can signify starting with
just this one oh wow that was not right
so we start here right have one now
we're going to take this we're going to
do this in this order the order of our
list so C is going to be the first place
that we go all right so let's go along
see we've discovered this at time two
and now let's do C right C has a
self-loop so it's already been
discovered so we're done with this one
three now back to a right so the next
one in a is d now you can see that here
so let's go that path okay and time for
this was discovered so let's look at D
the first one D is a self-loop so that's
already been discovered already gray he
is the next one so let's take that path
so time five so e down here has a path
from E to G alright so let's take this
path and it's been discovered at times
six G has a path to be right it has an
edge from G to B so now B has been
discovered at time seven let's go up to
B let's take the path to e except E has
already been discovered so we're done
with this one so it's been discovered a
time eight back to G this is done at
time nine there's nothing left and it's
list back to e
there's nothing left in its list right
so that's done at time 10 back to D the
next one in these lists is f so let's
take a path over to F and this has been
discovered at time 11 so f has be right
in its
adjacency list bees already been
discovered so we're done with this one
at time 12 and that means that we are
done with D at time 13 and then we are
done with a because G has already been
discovered so we were done with this at
time 14 all right that was kind of fun
let's do breadth-first search on this on
the same one let's just redraw this
alright let's just get some practice in
might as well so we got C over here
we've got G we put F over here whoops
it's kind of messed up
but F over here B is down here and E is
over here so we've got this kind of
crazy lines here okay there's a path
here so path here here and here I think
that's all of them yep okay
and let's do breadth-first search over
here breadth-first search now we have a
queue remember so here's our Q first
it's empty we're going to start at a
alright start here its distance is zero
so we put a right in the queue we take a
out of the queue and we put its
adjacency list on all right
all the distance of one so we have C D
and G we take C off right see points to
itself so we have we don't put anything
else on the queue next we take D off and
we put E and F on right who comes
first he comes first in the adjacency
list so that's we're going to put on
first so we've got G E and F all right
these are distance of two so next we
take G off and we put B on here all
right so now our cue looks like this
e F B okay next in the queue is e so you
take a off G has already been discovered
so we don't put anything else on so I'm
going to write this over here so f and B
are now on the queue we take F off the
cube B has already been discovered it's
already in the queue so we don't put
anything in there right B we would put
we take B off the queue now that would
be e right except E has already been
discovered so we don't put anything on
the queue and there's no nodes left
that's we've gone through all the nodes
and that's it so there's our depth-first
search or breadth-first search and our
adjacency matrix in our adjacency list
so there you have it
hello everyone in our previous lessons
we introduced you to graphs and we also
looked at and talked about some of the
properties of graph but so far we have
not discussed how we can implement graph
how we can create a logical structure
like graph in computer's memory so let
us try to discuss this a graph as we
know contains a set of vertices and a
set of edges and this is how we define
graph in pure mathematical terms a graph
G is defined as an ordered pair of a set
V of vertices and a set of edges now to
create and store a graph in computer's
memory the simplest thing that we
probably can do is that we can create
two lists one to store all the vertices
and another to store all the edges for a
list we can use an array of appropriate
size or we can use an implementation of
a dynamic list in fact we can use a
dynamic list available to us in language
libraries something like vector in C++
or ArrayList in Java now a vertex is
identified by its name so the first list
the list of vertices would simply be a
list of names or strings I just filled
in names of all the vertices for this
example graph here now what should we
fill in this edge list here an edge is
identified by its two endpoints so what
we can do is we can create an edge as an
object with two fields we can define
edge as a structure or class with two
fields one to store the start vertex and
another to store the end vertex edge
list would basically be an array or list
of this type struct edge in these two
definitions of edge that I have written
here in the first one I have used
character pointers because in C we
typically use character pointers to
store or refer to strings we could use
character array
also in C++ or Java where we can create
classes we have string available to us
as a datatype so we can use tattles so
we can use any of these for the fields
we can use character pointer or
character array or string datatype if
it's available depends on how you want
to design your implementation now let's
fill this edge list here for this
example graph each row now here has two
boxes let's say the first one is to
store the start vertex and the second
one is to store the end vertex the graph
that we have here is an undirected graph
so any vertex can be called start vertex
and any vertex can be called end vertex
order of the vertices is not important
here we have 9 edges here 1 between a
and B another between a and C another
between a and D and then we have B E and
B F instead of having B F as an entry we
could also have F B but we just need one
of them and then we have CG D H E H and
F H actually there's one more we also
have G H we have 10 edges in total here
and not 9 now once again because this is
an undirected graph if we are saying
that there is an edge from F to H we are
also saying that there is an edge from H
to F there is no need to have another
entry as HF we will unnecessarily be
using extra memory if this was a
directed graph F H and H F would have
meant two different connections which is
the start vertex and which is the end
vertex would have mattered maybe in case
of undirected graphs we should name the
fields as first vertex and second vertex
and in case of directed graphs we should
name the fields as start vertex and end
vertex now our graph here could also be
a weighted graph we could have some cost
or weight associated with the edges as
you know in an unweighted graph
cost of all the connections is equal but
in a weighted craft different
connections would have different weight
or different cost now in this example
graph here I have associated some
weights to these edges now how do you
think we should store this data the
weight of edges well if the graph is
weighted we can have one more field in
the edge object to store the weight now
when entering my edge list has three
fields one to store the start vertex one
to store the end vertex and one more to
store the weight so this is one possible
way of storing the graph we can simply
create two lists one to store the
vertices and another to store the edges
but this is not very efficient for any
possible way of storing and organizing
data we must also see its cost and when
we say cost we mean two things time cost
of various operations and the memory
usage typically we measure the rate of
growth of time taken with size of input
or data what we also call time
complexity and we measure the rate of
growth of memory consumed with size of
input or data what we also call space
complexity time and space complexities
are most commonly expressed in terms of
what we call Big O notation for this
lesson I am assuming that you already
know about time and space complexity
analysis and Big O notation if you want
to revise some of these concepts then
you can check the description of this
video for link to some lessons we always
want to minimize the time cost of most
frequently performed operations and we
always want to make sure that we do not
consume unreasonably high memory okay so
let's now analyze this particular
structure that we are trying to use to
store our graph let's first discuss the
memory usage for the first list the
vertex list least number of rows needed
or consumed would be equal to number of
vertices now each row here in this water
list is a name or string and string can
be of any length right now all strings
have just one character because I simply
named the nodes a B C and so on but we
could have names with multiple
characters and because strings can be of
different lengths all rows may not be
consuming the same amount of memory like
here Here I am showing an intra-city
road network as a weighted graph cities
are my nodes and Road distances are my
weights now for this graph as you can
see names are of different lengths so
all rows in vertex list are all rows in
edge list would not cost the same more
characters will cost us more bytes but
we can safely assume that the names will
not be too long we can safely assume
that in almost all practical scenarios
average length of strings will be a
really small value if we assume it to be
always lesser than some constant then
the total space consumed in this vertex
list will be proportional to the number
of rows consumed that is the number of
vertices or in other words we can say
that space complexity here is Big O of
number of vertices this is how we write
number of vertices with two vertical
bars what we basically mean here is
number of elements in set V now for the
edge list once again we are storing
strings in first two fields of the edged
object so once again each row here will
not consume same amount of memory but if
we are just storing the reference or
pointer to a string like here in the
first row instead of having values
filled in these two fields we could have
references or pointers to the names in
the vertex list if we will design things
like this each row will consume same
memory this in fact is better because
references in most cases would cost us a
lot lesser than a copy of the name and
as reference we can have the actual
address of the string and that's what we
are doing when you are saying that start
and end vertex can be character pointers
or maybe a better design would be simply
having the index of the name word string
in vertex list let's say a is at index
zero in the vertex list and B is at
index 1 and C is at index 2 and I'll go
on like this now for start what X hand
end vertex we can have two integer
fields as you can see in both my
definitions of edge start vertex and end
vertex are of type int now and in each
row of edge list first and second field
are filled with integer values I have
filled in appropriate values of indices
this definitely is a better design and
if you can see now each row in edge list
would cost us the same amount of memory
so overall space consumed in edge list
would be proportional to number of edges
or in other words space complexity here
is Big O of number of edges okay so this
is analysis of our memory usage overall
space complexity of this design would be
Big O of number of vertices plus number
of edges is this memory usage
unreasonably high well we cannot do a
lot better than this if we want to store
a graph in computer's memory so we are
alright in terms of memory usage
now let's discuss time cost of
operations what do you think can be most
frequently performed operations while
working with graph one of the most
frequently performed operations while
working with graph would be finding all
nodes adjacent to a given node that is
finding all nodes directly connected to
a given node what do you think would be
time cost of finding all nodes directly
connected to a given node well we will
have to scan the whole edge list we will
have to perform a linear search we will
have to go through all the entries in
the list and see if the start or end
node in the entry is our given node for
a directed graph we would see
if the start node in the entry is our
given node or not and for an undirected
graph we would see both the start as
well as the end node running time would
be proportional to number of edges or in
other words time complexity of this
operation would be Big O of number of
edges okay now another frequently
performed operation can be finding if
two given nodes are connected or not in
this case also we will have to perform a
linear search on the edge list in worst
case we will have to look at all the
entries in the edge list so worst-case
running time would be proportional to
number of edges so for this operation to
time complexity is Big O of number of
edges now let's try to see how good or
bad this running time Big O of number of
edges is if you remember this discussion
from our previous lesson in a simple
graph in a graph with no self loop or
multi edge if number of vertices that is
the number of elements in set V is equal
to n then maximum number of edges would
be n into n minus 1 if the graph is
directed each node will be connected to
every other node and of course minimum
number of edges can be 0 we can have a
graph with no edge maximum number of
edges would be n into n minus 1 by 2 if
the graph is undirected but all in all
if you can see number of edges can go
almost up to square of number of
vertices number of edges can be of the
order of square of number of vertices
let's denote number of vertices here as
small V so number of edges can be of the
order of v square in a graph typically
any operation running in order of number
of edges would be considered very costly
we try to keep things in order of number
of vertices when we are comparing the
two running times this is very obvious
Big O of V is a lot better than Big O of
v square
all in all this what X list and edge
list kind of representation is not very
efficient in terms of time cost of
operations we should think of some other
efficient design we should think of
something better we will talk about
another possible way of storing and
representing graph in next lesson this
is it for this lesson thanks for
watching
you're listening to coding box episode
28 subscribe to us and leave us a review
on iTunes stitcher and more using your
favorite podcast app and visit us at
coding buckstein net we can find show
notes examples discussion and more and
send your feedback questions and rants 2
comments at coding blocks net and follow
us on twitter at coding blocks or head
to cutting blocks net and find our other
social links there at the top of the
page and with that welcome to coding
blocks I'm Alan Underwood I'm Joe Zack
and I'm micro outlaw and this is our
first remote recording so we'll see how
well this works out yeah pseudo so so me
and outlaw in the same room and then Joe
zach is somewhere in sunny Florida we're
sending smoke signals to him it's ready
see that now it's dark now oh yeah this
isn't going to go over well alright so
let's kick it off with our news this
week or this week I say it like that I
mean it's been a while since we record
have been busy so too long oh yeah it
has been too long we were all kind of
chomping at the bit to get back to this
so yeah it's been too long yeah the
first thing we want to talk about our
the poll results so first off thank you
for all of you that went up there and
told us how often you wanted to hear us
and if you haven't now is your chance
you go to slash pole or slash episode 27
you know coding box.net / episode 27 or
cutting box.net / poll and you know let
your voice be heard yeah so right now we
got a pretty tight race between the way
that we do it right now to where we
release once every 12 weeks yeah wait
White once every 12 weeks whatever get
out of here you know what though you
know what though I like I still want to
go through the results yet so i'm not
sure if we wanted to say that but was
also were but i will say this though
about some of these like especially for
those that like took the time to to
write your own you know result there it
will definitely make it harder to
tabulate all of that but there were some
awesome little gems in there and i'm
pretty sure one of you guys i'm talking
to you
on in you Jeff set some of these up that
because like for example someone said
yeah their quote was a tee time I can
hear Michael's voice would be awesome
yeah we did not do that but it was fun I
don't bleed he then I'll believe you and
I thought there was another one that was
similar along that same vein it was like
but it said sweet voice or something no
my absolute favorite was what a week one
hour long sweet Jesus oh yeah right yeah
now they're there were some really good
ones in there they were like that so you
know I really do appreciate the time
where we appreciate you taking the time
to go up there and vote and like I said
if you haven't now is your chance and I
think we're going to make this a regular
thing you know we'll have some different
polls and see see what happens try to
put some interesting questions out to
you guys and give you guys an
opportunity to you know let your voices
be heard yep so definitely appreciate
the time taken to do that and speaking
of appreciation wanted to give a big
shout out and thanks to give up Sam
Gordon web guy at be cry corn to Kenneth
glish Olli 724 and there's two names
yeah I'm gonna need some help from
outlaw pronouncing Oh ed be I got that
one and Gordon web guy hey note I did
those man are gonna use the hard ones
well I guess this first one is mr.
Furley that one's not so bad right I
thought you're gonna say ruefully not I
think I got that one right and then I
mean why would you do this to me um em
go fast M umber mang may I am Berman PGA
right yeah maybe that's it yeah in Bern
ma'am pukka ok I actually um that
reminds me I was watching a tosh point-o
the other night and by the way he's from
right around here and there wasn't a
half have you got I want to know if you
guys heard of this is called speech
jammer know and what you do is you plug
your headphones into this thing and
you you know kind of hit play and then
you try to talk and it kind of sends
this a little like feedback loop of your
own voice back to you that's supposed to
kind of mess with your speech centers in
your brain so it's actually really hard
to talk while you're kind of hearing
this stuff so I thought it was kind of
funny there might be a fun little gag
like you know get your wife on there and
ask her to tell you a story something
and you just end up sounding ridiculous
I thought he was trying to give us like
some kind of hint about this remote
recording setup he was like having a
hard time because he was hearing himself
apparently no I think he's making
excuses already we're five minutes in
he's already like dropping an excuse
bucket the but yeah we drop into the
sleep bucket in it yeah but seriously
some of these reviews are absolutely
fantastic we got several that said hey
this is a must add to your podcast
collection or you know quickly becoming
one of my favorites so hey guys
seriously thank you very much we haven't
gotten enough of them it's not like the
one where I mr. Furley and he says that
we're funny we try to be sometimes and
sometimes it just comes across that way
anyways but but yeah keep them coming we
absolutely love and appreciate that you
guys take the time to do that so thank
you super super appreciated the next
thing we want to talk about was built
Atlanta yeah man that was awesome
outlaws even wearing the shirt right now
yeah coincidentally um that was a so
outlaw and myself went to this to this
all day event that Microsoft hosted here
at the atlanta aquarium and it was very
well done first off like I mean it was
this is like the the on the road version
of build yeah right yeah so we didn't
actually get to see the hololens man
they did well I mean we got to see
pictures of it get a nice touch one or
see an actual I think everybody there
wanted to see it right like I think
that's how I have two people showed up
to it but is this thing real though I'm
now is this really going to hit the
market man personally I think it's
vaporware I don't think he's ever going
to happen I don't ones the hardware
equivalent of vapor wear whatever that
is that's what that is
no glass well see Google glass actually
felt like to me like it that really was
vaporware but this thing looking but
that actually made it in the market and
people could buy it yeah now is it in
the market anymore well no not now but
well yeah whatever but but what I mean
though it was actually a name that
people could buy it was just a
ridiculously expensive thing like I'm
curious to see if this ever even gets
that far though where is this going to
be like the the surface table that you
only hear rumors about I feel like
anything at CES like if you see it at
CES it's just an we're going to happen
like but you know what here's the thing
though from my perspective just looking
at this like what they've shown of it if
they can bring the price of this thing
down into within reason let's say within
an xbox one type price range you know
500 ish dollars if they can get in there
google glass was 1500 1500 this thing's
going to be less so so think about it
like this Microsoft has been known to
take a hit on hardware knowing that
they'll make it up on the back end the
xbox 360 sol de los the xbox hold a lot
that's just how game consoles are done
now not not always but but the thing is
is think about this if they can get this
in the hands of people and they can and
they can monetize a market because
they're going use case for thing is so
small I don't know it the thing is i
can't imagine building software for it
like that would be incredible ears a
problem here's the problem in in in it
would doesn't suffer these the exact
same fate is 3d tvs but a similar one
and that is that for people in glasses
like myself I'm automatically like me is
probably going to be uncomfortable to
wear on top of my glasses or not you
know comfortable or not like look
correct or something do you need
contacts yeah that's not me yeah I don't
let me down as gosh I don't know man
like it looks really cool to me like
some of the things that I saw that they
could do with it now how well it
actually works in real interaction who
knows like you can't even see the thing
anywhere but I just can't imagine
writing software for it could you
imagine actually trying to do an
augmented reality type thing to wear
it's you know it's not like something
your phone where you point your phone in
a direction it shows you the windies as
the closest right maybe this should be
the next poll is hololens real because
it it's real no I mean I this thing
could actually be like a Michael Bay
production right just making you think
like like you Optimus Prime looked
pretty convincing in those movies right
this could be another one of this yeah I
don't know I'm excited about it i hope
it i hope it is real but i mean we
haven't seen one yet but anyway I guess
back to the show on the on the Atlanta
build it was really like it was a day
full of information that i thought was
really cool like the approach that
Microsoft is now taking to software is
you it's almost like responsive web
design like but what I got out of the
day's worth of stuff where they have
what was called WP oh no not WPF uh it
was the oh god what can I not remember
what it was right now but basically
they're bringing the entire platform all
together so you'll be able to write a
piece of software that we could run on
something from a raspberry pi to a
windows phone to a windows tablet to the
desktop like they're trying to they're
trying to unify the experience I mean
they've been touting that for years that
they have but now they're actually
forcing it all through the same
programming model which is which is a
cool thing um you know back in the day
see had this grand vision that you could
write your C code on you know one time
and run in anywhere to well javale's and
Java came along with a similar promise
and Microsoft's been saying a similar
thing with a write your universal app I
mean I get it it's cool there's some
stuff out there I'm not trying to be a
debbie downer but there you can tell
that they're definitely feeling pressure
from you know Apple and Google
especially in the mobile market but yeah
and I reason really there was some
really cool stuff there but you know one
thing to just like the expense of it
though oh god that that whole day was
covered yeah I mean we didn't we didn't
pay for parking we didn't pay for food
and dude they rented out the entire
ballroom of the Atlanta query
so it was not a cheap event and I mean
they want people to get excited about
what they've got going on and and I will
say this as a dot net developer it is
exciting but it would be way more
exciting if they had you know a ton of
mobile users or you know something along
that line because right now still like
if you're going to write an application
you're writing it for windows right
you're not you're not really going to be
writing it for the windows phone now the
the one cool part is if you're our
mobile app you're going to write it for
iOS first that's what I'm saying but
here's the cool part right like if let's
just say if this this thing happens and
this is what they're saying windows 10
is going to be a part of this universal
platform that they're doing if you can
write it for windows and then for
essentially free it will scale down to a
phone and a tablet and the Internet of
Things devices that could be cool right
like now you have buy into a platform
and you didn't really have to work at it
because like a surfer you're not going
to any application you're going to write
for a Raspberry Pi isn't gonna be
something that you're going to be
interested in on your phone no no no
what I'm saying is you write a core for
your desktop app and now let's say it's
a business layer or something like that
or you you layer your application
properly that now becomes available
across all devices yet you're not going
to write a desktop application that's
going to translate perfectly to a phone
but it is cool that you could have that
same core be a part of it right I got
two words for you and they came out of
that event was a data lake that was cool
yannick what's that he was it I you know
honestly I don't even know there was
there was some you know as your
announcements that were I made thereto
and like one of them was this new data
like service for dealing with with gobs
of data but I couldn't help but like
laughs when I heard the name because it
just sounded kind of humorous and then
yeah there's the the image of the dump
truck spill and trash everywhere and I
just kind of thought of that as like you
know here comes the the data truck
coming to get your your data to take it
to the data link
yeah man the result in code was the most
most disappointing part of it for me
like the massive text editor that is
code so so at the original build event
they announce code and then I guess I
misunderstood its purpose because i was
thinking like hey this is a cool you ide
that they're creating that to be
cross-platform but at the build event in
atlanta they were very careful every
time they mentioned it they referred to
it as an editor yeah they never once
talked to it because because even in my
own experience like as soon as it was
talked about I was like oh let me go
download this thing and start playing
with it see if i can write some code you
know like let me just write a simple
hello world app and compile it and watch
it run or debug it or whatever and you
know you try to bring up a task okay do
a build and it's like okay yeah I can
figure that you're like no you should
already know how to do the build it's
like it Sublime competitor nope no bad
plus plus well well yeah maybe but and
they at one point during the
presentation in Atlanta they mentioned
that you could do compiles for what was
it it had to be a mono specific project
in order to compile only on linux and OS
10 so I you know I've been playing
around with this on Windows 8 bucks and
that explains why I couldn't do any kind
of compile with it well it does say like
on their site code visual studio com
that it has an integrated debugging
experience yes for JavaScript oh yeah so
if you wanted to write C sharp on it
right and then compile it you have to a
be on something other than windows which
means be it's a mono project because at
the moment they haven't released their
own their own core yeah non-microsoft
form
I run hot that's really hmm that's
interesting I mean it okay so i will say
this if you throw it into this into the
camp of sublime that is still pretty
cool right I mean but then was it buying
you though that that's very
disappointing part it's free oh my god
so so you can download sublime and use
it for ever for free and it'll let you
in notepad or I'm not saying I'm not
saying that you should I mean you know
you know give them a few bucks right but
but I believe if I'm cremy from Rama I'm
fairly certain that this is based on
Adam which is another free editor yeah
Adam is I don't know is it based on adam
i really don't know fairly certain it is
uh well in which way i mean they did
they did talk about it but it wasn't a
huge it wasn't a huge part of build I
mean build they definitely they showed
some stuff with Azure that was really
cool like some of the analytics you get
if you're hooked up into their services
I mean they were they were walking
through like I mean if you were in love
with statistics and you like to analyze
every bit of everything that happens
like you can see all kinds of cool stuff
on their dashboards and Azure um I mean
the the unified platform was one other
big selling points and that was mostly
using WPF and zamel right i was at WPF
or was a jizz amal i know that they were
talking about things but but it was
seriously it was similar to responsive
design because you had things like
saying hey if the if the screen with is
you know 1024 or less than then switched
to this mode so that's pretty exciting
you know like for a while there we were
kind of afraid that maybe they're going
to be getting away from zamel because
they kind of killed off silverlight and
we're promoting HTML Javascript but
looks like it's still still in there
actually not only is it still in there
it seems to be the focus for yeah it's
definitely if there's a marine question
that's how like what was the future for
Sam oh it seems like it's a not going
away yeah it's it's pretty much the
predominant for creating your UI stuff
um so that that was really cool um but
let's go back to the day too late though
to give you a more like definition of it
it Microsoft's touted as a hyperscale
repository for big data analytic
workloads
so now you know what it means clear as
mud um no fixed size on file limits or
account size it's based on a Hadoop
distributed file system blah blah blah
blah yeah they they also said some
ridiculous statistic there that didn't
make much sense like some some massive
percentage of Linux running in the cloud
it was those do you remember what that
in my battery of my laptop was dying
because I mean oh I don't have the notes
with me yes they made some ridiculous
claim about well I say ridiculous like
some obscene percentage of all the Linux
greater than web servers who I want to
say it was like that they said something
like that I don't mean I wish I could I
wish I had my net with me on from the
show but they said that they were all
running on Azure like cloud-based
versions were running on Azure and all I
could think was there's no way with AWS
being there I mean you got google
compute yeah AWS ec2 instance is out
there like a digital ocean really you
have let's take all the small guys let's
just talk about just focus on the two
big wises yeah there's no way AWS is
definitely leading the way I actually
found that stat it's um over seventy
percent of all links boxes running on
azure are running on Azure I believe
that nice oh well done there she did uh
yeah yeah there were something else is
on the tim @aa ya when it was said
they're like literally both me and Mike
looked at each other like no way the.net
native uh that was another cool feature
cuz I where you could just simply
recompile your app to be a dotnet native
app and it would you would gain it was a
huge performance boost yeah the numbers
were like 20 40 60 so I'm trying to
murder like which was which though you
got you got a smaller file size in a
smaller memory footprint and oh so you
know I know what it was I know what it
was it was
it was something like a dang no I don't
one of them was the one of them was the
start time a cold start time and then
the other one was the warm start time
for the app and then the other one was
the memory footprint yeah yeah I can't
so here's what he's talking about with
dot net native thing is basically what
happens is right now when you compile a
dotnet application it you know it
compiles it into the what is the CIL or
whatever um hey hell are all right now
yeah so then that gets run but the first
time you take a big hit because it has
to basically load it all up and and get
it ready to run when you do it this way
it actually compiles it down to sea
level code right wasn't that what it was
no this was it compiles it down to
native machine code that machine like
C++ ahead but this is taking you know
like your your Universal apps you see
sharp app and compiling it down to
native here we go it performs it you
know their app will start from a fresh
start sixty percent faster than it did
and all you had to do which is recompile
it and it would use anywhere from
fifteen to twenty percent less memory
than it did and again you're just
recompiling the app yeah and another
thing that they were talking about a lot
is they spent a lot of time in their run
time making sure that applications now
are easier on the processor because
they're more concerned than ever about
doing things on the mobile platforms and
tablets and that kind of thing so
they've really been focusing on these
things a lot I mean there was definitely
some cool things that came out there was
another website it was something to cat
a Microsoft man I tweeted all this stuff
out actually real quick I just wanted to
mention that there actually was a tool
called engine I think I even came out
like when done that came out that let
you compile things to native code but
I'd always heard it was kind of a bad
thing because you lost a lot of the
benefits of like just in time compiling
so I've never been really clear on what
the difference between engine and the
new native stuff is but I've heard the
same claims about performance benefits
and everything so kind of interested to
hear the difference in
you know what the difference is I would
love to hear it yeah Oh in the site the
site i was talking about oh and it's
free by the way you can go up there and
check out all these things that we were
just kind of mentioning is microsoft
virtual academy com um so they
definitely have a lot of cool stuff and
it's all free like they teach you things
they have sections broken down by types
of C sharp and zamel hybrid cloud
automation cloud app development blah
blah blah blah blah there's a ton of
stuff so I'll definitely go check that
out if you're interested in the newest
things coming and learning for free yep
all right so i think i think we've we've
hit a lot of points on the build atl so
what you got yeah there's playing stuff
out there that you can find yeah yep so
just want to mention really quick tampa
code camp is coming up i missed the
orlando code camp on a move to the area
but just kind of throwing it out there i
do stop plan on starting to hit up some
of the meetups in Central Florida so if
you guys are in Central Florida what you
say is that i'll be there oh yeah you're
gonna be there should i drive now tried
any death I'm looking out i think it's
july fourteenth so you got a couple
weeks i'm actually gonna be down there
dude i'm not gonna be too far from you
oh really in tampa yeah yeah i will be
just across the way from Tampa so I
might actually come out to that awesome
I July eighteenth today excellent dude
I'm going to be done there alright
alright so um the next one I actually
appreciated this so Rebecca on on
Twitter the other night I had a very
very long coating night I think the
longest ever that I've done and in i was
getting a little punch drunk and I
needed some humor and she came to the
rescue she said um what do they call and
elevate an alligator in a vest all right
anybody I I don't know an investigator
that's wonderful it was super corny and
exactly what I needed at about three or
4am whenever sometimes a good bad joke
just make you feel fuzzy oh wait wait
wait why are you calling her jack a bad
joke
is fantastic it's a good bad joke you
know the great part is is I think all of
us looked at this on our phone and it
cut off the actual answer it I was like
we should never get to give us the
answer is ridiculous you're like text me
back forth like what's the answer I
don't know it was just further down on
tweet she built suspense so I
appreciated that that was fun yeah now I
have to pour one out for my buddy here
so you'll sense oh oh god no no means
thing about that are tight no resharper
oh my god so we've already talked about
you know how I had uninstalled it and
everything and iming yeah the sands
resharper and honestly I've kind of I've
kind of gotten addicted to productivity
tools the the ad in that Microsoft makes
for visual studio productivity tools are
pro tools or some like that yeah 2013
and it's got its got some nice little
add-ins to studio but definitely not to
the degree that resharper has especially
resharper with dot cover which was my
favorite combination and so you know I
said last time that I would eventually
come back to truant you know try and
reach sharper out like you know if I
ever decided to or felony to so I did I
decided hey you know what I'm going to
ultimate and because every version I've
ever used in the past has just been
immediate gold like I've loved it and it
has just been like you know a part of me
why am I going to bother with this trial
i'm just i'm all in let's buy the
upgrade to ultimate and awesome things
will happen and I didn't like it really
like to slow or shortcuts what I didn't
like okay like yeah it was really it was
really bad wait really bad well my
experience was really bad let me be
clear you know how you you hear a lot of
people that say
what they don't like about resharper is
that it's slow and you know the what it
does to visual studio and things like
that they're not wrong so I had problems
where like just trying to navigate
between like especially like you know
the current code base i'm working in as
a rather large in terms of the number of
files and whatnot and going between
files it was just visual studio would
hang often almost always and you'd get a
not responding prompt coming up from
visual studio all because you decided it
was time to look at another file and it
was random little things like that and
just even sluggishness while using it
and again like I know before anyone
jumps on this because I mentioned the
productivity tools there is a known
issue where productivity tools and
resharper can not coexist so I had
already at first I tried just leaving it
productivity tools disabled and see if
you know that would work and then that
still wasn't by him anything so i
uninstalled productivity tools because
you know really wanted to commit to
resharper especially after I'd already
paid for the license without trying the
trial but but and it's still my my luck
still wasn't bad so I wasn't good yeah
I'm sorry yeah uh yeah it did not work
out well for me and so I ended up
uninstalling it almost within 24 hours
Wow paying for the license although and
so for the first time what's your
license key I'll try it out make sure
yeah no connect so you're on Twitter and
just let whoever gets it yeah I mean I
just want to make sure it really is bad
right right but so so I but for the
first time though like like vision
resharper like a lot of tools or not a
lot but you know several tools do this
thing where like you know after you
install it they immediately
open up a browser to their feedback page
and they want to know like a yr un
installing this thing right and I have
always just been like if I'm gonna talk
for that forget it and why wow why do
you care whatever right but this was the
first time where I was like no this is I
love this thing I've loved this thing
for so long now right like hi I have you
told everyone I've gone to the hilltop
that I've sang its praises for so long
hell and now it has betrayed me I need
to let you know how I feel about this
betrayal right so i actually did write
back so i will say that it's not over
right because they're so there's there's
there is advantage to filling out those
forms it turns out because their support
team immediately got back in touch with
me to wanting to find out why and one of
the JetBrains tools is the profiler and
so i sent them some profile information
from visual studio so that they could
debug see like what was happening with
it so maybe they'll fix the problem in a
future resharper bug but until then I'm
kind of like you know at the mercy of if
they fix the bug you know if they decide
to fix it if they can reproduce it if
they can't fix it whatever right and to
be clear you're not running on like your
core i3 you have like an i7 with 16 gigs
of RAM right oh yeah yeah yeah so yeah
SSD and all that good stuff yeah it's
not it's not a slot machine and I can't
use my favorite tool mmm that's a little
road which really makes it difficult
like you know I suppose I haven't tried
and saw doc cover by itself because I
mean it hurts too much yeah the pains a
little too fresh yeah that's what it is
yeah I feel you though that would hurt
so all you reach our poor naysayers I
guess scoot over here he is alright so
one last quick thing in the news section
before we get into the real stuff here
today
is it this hit me so hard the other
night because we've all been there where
you got to get something done right like
it has to be done you have to get it
done dude I'm sitting there i think i
even i am out long i was like dude I'm
really just starting to throw away good
programming so it's right now he's like
dude you need to tweet that and I did
and a lot of people favored it because
apparently everybody feels his pain
right like you're open it's the 11th
hour and you've got you know 10 more
hours of work to do and it's like Oh God
and so you just really start you know
almost just forgiving yourself ahead of
time for what you're about to do because
it's like I don't have time to make this
perfect I don't have time to make this
even decent I'm just making this right
well maybe this should be the poll the
next paulding because I dare say that
like a majority of code that ain
developer has written where they were
like under the gun you know tightening a
tight deadline and really pressured
that's when they probably wrote the code
that they are the least proud of or
there's a portion of cut they're like
yeah not proud of that part but I had to
get it done too although i'd love to see
that commit message i just imagined
saying like I dare you to say something
you know for I am actually i was i was
laughing about this earlier so i've
become a fan of rebase and get because i
thought you could squash your own
history well apparently there's a way to
do that but the way that I've done it
doesn't so my commit messages like
there's things like man this is some BS
like I definitely had a bunch of commit
so I'm like man I'm fixing another
problem with their framework I'm so
ticked off right now right like remove
test case since code didn't ask you a
wait I didn't run a test case I guess
that's very good bracket sale but no I
mean seriously like we've all been there
where it's like oh you started out you'd
separated all your classes you had this
nice roadmap ahead of you and you get
down into it and you know 90 bugs later
that you're trying to work or
you like man I don't even care what this
looks like when it's done as long as it
comes up on the screen the way it's
supposed to right so yeah it just wanted
it all of those who favorited we tweeted
I'm sure that you've all been there I
did it along nerve did it for the walls
right get commit commented out failing
tests if you guys don't recall or if the
if this is new to you and you do find
yourself in a similar situation as Alan
did where it's 4am and you know you got
to do a commit and I gosh would I I
don't even know what to say about this
commit you really should just go to what
the commits calm and let it tell you
what your commit message should be yeah
that's I probably I wish I would have
remembered that the other night because
I would have or the other morning so
yeah man that was that was a rough night
so anyways on to what we're talking
about today which are hierarchical data
sets um we did a cat yeah we did a
couple episodes on sequel a while back
and these kind of things come up all the
time and they're a little bit more
advanced topic so we're going to start
down at the bottom with this but we're
going to work our way up so the first
one that we're going to talk about is
called the adjacency list and it's
pretty simple if you've worked in
databases for long at all you've seen
this stuff essentially you if you if you
think of an employee table just a simple
table typically what you'll have is an
employee ID and a manager ID that is the
adjacency list right there essentially
it's a self-referencing parent-child
relationship within the same table well
let me let me sum it up in an easier way
or every record knows its immediate
parent yes yes so if you have an
employee ID let's say that you know
let's say that Michaels the boss on the
middle quit if Michaels boss Jose the
middle guy and I'm the grunt down at the
bottom so that's why you're up at 4am
right Michael's ID 1 jose ID too so
Michael his manager ID is going to be
null because he's the top of the chain
right
that's right um Joe like where this is
going Joe is ID too well his manager ID
is going to be one that's Michael and
then me down at the bottom my employee
IDs three and my manager is too so
that's Joe so if you were to query this
thing going up then you'd see that hey i
am jose worker and joe is mike's worker
and that's how the table looks okay so
it's a tree basically right so everyone
has only one parent but each you know
parent could theoretically be parent to
multiple yeah so if we wanted to break
that down to where it wasn't a complete
waterfall down right to where it was
Mike than you than me it could be Mike's
at the top you know I d1 manager ID null
then your ID to manager ID 1 i'm
employee ID three with manager ID 1 so
both of us are just one level below him
but multiple children just like you said
okay so an example thing I might want to
query is uh give me all Michels reports
yep and yep and well are we gonna talk
about direct reports or reading time I
like the full trees let's start with
your direct reports right it easy yeah
we'll get we'll get into the meat of the
problem in a second but yeah so direct
reports you basically be like hey select
star from or star that's a bad idea
anyways but select star splat splat from
employees where manager ID equal one
give me all of Mike's direct reports
right so that's it pretty simple another
thing that you typically see in these
type of situations are hey show me the
top level guy and there's usually two
ways of going about this you'll either
have the manager ID null or you'll have
the manager ID equal whatever his ID is
so you'd say hey select star from
employee where manager ID equal know
that give you Mike back or if they had
filled it in you could say we're
employee ID equal manager ID and now you
have the top level guy so those have
covered the basics of of what the
adjacency list is um now to get into the
harder part right so let's say that you
are a few levels deep how do you go
about doing that well this is where
you'd be tempted to use you recurse
of CTE not to solve that's not your
problem okay well do this you could do
it this way yeah so but go ahead CTE for
those who don't know or haven't listened
to the previous one so that's a common
table expression oh and just to be clear
the previous episodes that we're talking
about were episodes 13 and 14 yep and
they those are pretty deep episodes so
um if you if you want to put your sequel
hat on it's there there's a lot of our
hats are a must yea though that those
are some pretty deep episodes um but a
CT is a common table expression and all
that is it gives you it kind of allows
you to create virtual tables in your
queries um with some added benefits what
we're talking about with the recursive
CT now here's the here's the thing with
it it's only available in some are dbms
s my sequel does not have ctes postgres
does sequel server does Oracle does a
lot of what they call enterprise based
database management systems do have this
but like my sequel one of the most
popular on the planet does not have a
recursive or even see T's sometimes
people call these width clauses right or
I think I've seen that word before we'll
say you're doing a width in your sequel
yep that's that's what it starts with as
a with um so with the recursive CT there
and I know why Mike saying that you
would be tempted to do it and here's the
thing if you have relatively shallow or
smaller data sets that you're using just
go ahead and use them they're awesome um
you know what's smaller like a hundred a
thousand I mean it kind of depends right
it depends on the load of your system
and all that um I mean I've definitely
done it with thousands of records and it
and it performs fine it's going to be
manageable it will be manageable I mean
so said just be clear then the way the
CTE is going to work is like let's say
you have like with employee hierarchy as
and then you'll do a select star from
what was your table employees right
where employee ID equals one yep write
your first guy or Leslie we're manager
ID
is no let's get let's get the top level
guy okay where it's no where employee ID
equals no union all select star from
employee what did I name the CT
originally CTE hierarchy okay so select
star from employee where employee
manager equal employee hierarchy dot
employee ID yep right so that that that
second portion of that second select
statement and that Union all is going to
call back on the CTE itself right so
it's going to recursively call on it and
that's going to be fine in your smaller
data set example yep or or it could even
be a large data set within that table
but depending on what you're doing with
that across other tables that you're
joining too and that kind of thing it
can get really big really fast and and
now your performance can really degrade
you say performance you mean CPU we talk
in memory everything all of it right
like so it could be your CPU well so
here's the thing you can index these
columns the one great thing about the
adjacency list is super easy to index
right you got two columns you have your
employee ID and your manager ID so
sequel server can utilize these indexes
well I mean there's other there's other
ways to solve hierarchical data to where
you could also index at night so I
wouldn't say that's necessarily the
benefit of adjacency list well so the
fact it's simple those what I'm saying
is right like you have your parent child
relationship in one table when we get a
nested set models though that's are
pretty simple things that you're gonna
enjoy building them not build know but
we're talking about the indexing now
okay okay forms part so because what I'm
thinking like when you talk about the
employee ID in the manager ID in the
benefits of the adjacency list
immediately I'm thinking of the fact
that you you could have integrity on
those columns that yep very easy yep
omission yeah cyclic data oh if you have
something that references something up
above yet so here's the thing with
something like sequel server I think it
has it has a mac version yeah max recur
of like 99 a it might be higher than
that I can't so I won't totally kill the
box but really it's invalid for this
you're not gonna be able to model this
with this approach no actually what you
would run into any ways is that would
eventually end up breaking you because
yeah if you have something if if you
have a record five down that references
a record that was three up from it then
yeah you're going to start getting into
this recursion so essentially you're
just going to start getting back a ton
of data that doesn't make sense right so
yeah that's a problem but that's
actually a data problem right that's an
integrity issue and it depends on your
data you know for like a manager
hierarchy that would be a bad thing but
well is it might be well I mean I said
there are some there are some management
chains that are called flat right to
where people can report to multiple
different people so yeah really checks
and balances like the legislative branch
checks the judicial no I'm thinking of
like the one the more proper the big
known one was blackberry when they there
was a period of time where blackberry
had to see a few CEOs right to the whole
company like it's starting at the top
there were two guys yeah I'm oh yeah
that's yeah if you've got two parents
this is right out the window too yep so
so that's all this is automatic though
like brainy get into like circular data
structures like that though this is this
wartime up higher cool I don't know if
you heard Joe by the beginning of the
show but we say we're drink about
hierarchies not circular circles right I
think that's a different show yeah
that's the graph databases so difficult
being remote you can't see that we're
coming hierarchies yeah you guys can't
hit me anymore it start throwing things
across the table oh so yeah I mean
here's the thing we do get into the CTE
so when we were talking about the
performance and all that if you think
about what sequel server is actually
having to do behind the scenes I'm sure
they've built in optimizations but in
the old days before you had things like
CTS essentially what people do is they'd
write prox right that would then fill in
temporary tables and it would loop over
and say okay go give me all the children
of this so hey select star from from
employees where manager ID equal this
then you get down another level and then
you and then you'd step through every
one of those and say all right give me
all the employees that report to them
and so you kind of fill this in behind
the scenes that's really what sequel
server is probably doing is it saying
okay give me all those parents now or
all those children now give me all those
children and so it's one at a time
stepping down the hierarchy so if you
have a really deep tree and and if you
have a wide table and by a wide table
you have a ton of columns in it these
these queries get expensive especially
if these if the data sets split across
pages like there's all kinds of things
that can happen there but the deeper you
go the more recursive levels are the
more expensive it is to actually run
that and but you know on the plus side
there are JC list very easy to implement
Oh super easy I mean right especially if
you have an R DBMS that supports ctes
right if you have a database system that
does not like my sequel then you end up
building something like we what we just
mentioned where you were filling in some
sort of temporary table some staging
table tour you can pull the data out
with an adjacency list well not only not
only is the implementation of a simple
which is easy for me to say the the crud
on it is also easier to see a moving
data around the leading data inserting
data into it you know those are all
cheap you're relatively cheap operations
compared to other hierarchical data
implementations yep absolutely um I mean
what moving somebody for manager want a
manager to you basically say hey update
employees set manager ID equal to two
where employee ID equal five right
whatever so super super easy and you're
done if you do that you're done there's
nothing else to look at nothing else to
touch I mean chances are if you're
writing any code where you even touch
the database you even look at the
database you've probably already seen
data that matches this model they're
like you you already know about it yep I
mean old
the old like not dashboards like what
can I think forms this is how the
commenting system would work in a lot of
forms right you'd have common ID equal
one if somebody replied to that then
then common ID tues parent ID was one
and so on down the list and that's how a
lot of commenting system works heck I
think even if you look in the WordPress
database um you'll actually see those
type of relationships right this is this
particular piece of content belongs to
that piece of content belongs to that
piece of content so it's a very simple
way to structure schema for represented
in a hierarchy so so what are the
problems with it so we mentioned that
you know large trees aren't cost process
if you're dealing with large data sets
it then this might not be your guy right
that that's really that's like the
number one thing that comes to mind for
me as far as like problems for this yeah
and here's another thing i will say even
if you're not going down a ton of levels
even if it's something that you are
constantly querying that way it can get
expensive right oh that's a great point
here yeah so you kind of need to look at
the frequency of it because you know
taking the hit on it once or twice may
not be a big deal but if every single
query you have and I'll give a good
example if you have um let's say you
have slim so as a product catalog right
that's a perfect example yeah if you're
constantly having to query down the the
categories every single time you are
going after products that gets really
expensive because you're now crawling
that that that tree on every single
query and if you got a lot of people
hitting that I mean that they can really
start running into some performance
issues okay so um just to make sure I
understand this I wanted to kind of sum
it up so would you say that and
adjacency list is one strategy for
solving the hierarchical data problem
where each record keeps track of its
parent yep
works for me double all right so I think
we've got adjacency list down it it's
it's a fairly simple one you've seen it
before but we wanted to go ahead and lay
the groundwork before we moved on to any
other because we wanted to do this is
going to be the first of a few episodes
where we wanted to talk about different
hierarchical data models right and so we
need to lay some groundwork out so some
some you know framework out that we can
all talk on a common language here so I
think we got a Jason see list but before
we move on to the next model I do want
to say that you know if you haven't
already we would greatly appreciate if
you would leave us a review you can go
to coding box net / review and find your
platform of choice be it itunes or
stitcher or whatever if you know of
another platform that you like to find
us on and you want to leave a review
their hey by all means please do and let
us know about that that platform because
you know there's there's probably
there's a ton of aggregators out there
that we're not aware of so yep um so I'm
being distracting on camera he is being
destroyed there you go I figured if I
took a selfie of myself sitting here
then I could just kind of tape my phone
to my webcam and go to the bathroom
interesting all right maybe the poll for
this one should be like how do you think
this remote gig is working should Joe
move back to Atlanta yeah i'm going to
go ahead and vote yes yeah yeah and if
our sound quality sucks this time you
guys to let us know we'd appreciate it
blame ya yep um alright so the next one
what's the next one we're going to look
at so as we as we step into our deep
dive here for nested for hierarchical
data models the next one we want to talk
about is nested set models right you
want to give us a brief overview or you
want me to dig into it I will try and
give a brief overview
we brought this up previously as well um
bow yeah I did want to say we did talk
about this in episode 13 and around the
44 or 45 minute mark but there was still
some some I don't know that we went into
it as deep as we probably could have
right yeah I mean it definitely wasn't
centered around higher hierarchical data
sets i think it was kind of a mention in
passing so so essentially what it is is
this if if you tried to take a hierarchy
and flatten it out to where if you
thought about everybody that was
underneath something let's talk about
employees and managers again because if
something people can kind of relate to
if if you were to just take your arms
and wrap them if they were big enough to
wrap around all the people under you
that's kind of what the nested set is so
essentially if if you envisioned that
everybody has a left and a right all
right and they're right is always one
more than their left if they are the
only person at that level so let's say
you're at the very so you kind of need
to picture it from the bottom of the
tree first right if you're at the very
bottom of the tree let's let's say that
your ID is 20 hold on before you go down
that path that yeah because because I
already see like there's some confusion
and I think I got a better way to
visualize this okay right like let's get
out of the the employee mindset for a
moment alysha talk family tree okay
right so so if you're building your own
family tree and let's say that you're
making the smallest family tree you
could possibly make and being lazy and
you just start with you and your parents
ok so this left right business that
Alan's talking about basically what
you're going to do is you're going to
start at the top of the tree right and
you're going to go down every node and
and count it and then when you get to
the bottom of a branch you're going to
start walking back up and in continue
counting right and then when you get to
wear a branch Forks then you're going to
go down that branch and continue
counting and you're going to come back
up and you're gonna keep doing that
until all branches have been visited and
node in the tree has been visited at
least twice yeah okay and this is where
the left right value part the Allen
comes in so as you walk down these nodes
the first time you're adding or you're
setting a value for the left side and
then as you start walking back up a
branch is when you set the right value
okay so in this in this very shallow
family tree version then if i start with
myself my left is one and then let's say
I start with my mom her left is too
because I don't go any further right her
right is now 3 and I come back to me and
then I go to my dad and his left is for
and because I'm not going any further
down the tree his right is five and then
I come back to me and now my right is
six so I have a left value of one and a
right value of six my mom has a left
value of two and a right value of three
and my dad has a left of four and a
right of five yep okay now that is as
simple as I can explain that but it's
hard to appreciate the value of it just
yet yeah now if you keep if you were to
make this tree bigger right let's say
that we we decided to include my mom's
parents in this tree then as I let's
start over with the counting yeah I
start with myself my left is one I go to
my mom her left is to I go to her mom
which is be my grandmother her left is
three she's now the end so her right is
for go back up to my mom and we go back
to the next branch which would be her
father so his left is five right six and
then come back to my mom her right is
now seven now we come back up to me and
then we go to my dad to calculate his
left of eight his right of nine and now
my right is 10 yep so now you can see
the
when there was just three people in that
hierarchy my left was one in six but as
soon as we added two more my values went
left of one and right of 10 yeah and
what we're going to do to help
illustrate this is we're going to put an
image up on the show notes for / episode
28 so the so that you could actually
kind of see what we're talking about
here but it will link to some there's
already some that are made i'm using a
family tree as an example just because
everybody can relate to that that's an
easy one to understand but yeah there's
some particularly in like a the
Wikipedia article if you look at this
where they talk about product catalogs
as an example for you know how you might
use this but the point that I wanted to
illustrate though is just that with
before you went too deep into left right
that really all that is is I consider it
and I haven't actually read this
anywhere and I'm curious to hear your
take on it but I consider this to be the
expense of walking the tree yep that
that's what those two values represent
the legends that you walk that tree
every time you insert or update yeah
yeah the left whoa okay hold on the Left
value represents the the expense of
walking the branch the first path down
that branch right and the right value
represents the expense of walking like
all of the brain all of the sub-branches
until you got back to that node now as
you already kind of hinted at though and
as you might have noticed when I
introduced just two more people in that
hierarchy I couldn't just I had to start
over with my counting I couldn't just
easily insert that in so those those
would be extremely expensive operations
especially in large data sets yes so so
notice what he said his first when when
he was first just including his two
parents his left was one his right was
six right when he introduced his
grandparents
his right bound completely changed at
that point but that's not just the
important part so did all the left
values for everybody under or after his
mom after the first note was visited
after him every other node at that point
changed for its left and right values so
he essentially had to recalculate the
entire tree at that point right um which
means that like if I had to if if I
wanted to remove my grandmother from
that list no she was the third note i
went to yeah but if i wanted to remove
her then she would change the values for
my grandfather my mother my father and
myself like that entire tree everybody
had at least one value whether it be the
left or the right or both changed yep so
that's why I like typically in
implementations where necessary used you
wouldn't want to bother trying to even
maintain your doing those type of crud
operations in the head instead you want
this data to be throwaway you create it
you save it into a table and when you're
done with it you throw it away and you
rebuild it yep it's it's one of those
things to wear it's probably not if it's
for mission critical time critical
applications where data is transactional
and changing you're not using this this
particular model because it would be too
hard to maintain however if it's
something that's not like to the minute
critical then if it's something that you
can build every hour every two hours
something like that you could do in
batch is something that you can do in
batch that you can basically let it run
do its thing and be done with it this is
when you use the nested set model but
let's go into some people be like why
would you even do that right because
we've only described like bad things
about it right like right even even me
describing it to you like hurt my brain
a little bit just saying it and I
already knew what it was right if you've
never ran across this before then I can
I can only assume that you would ask
like well it sounds horrible i never
want to do that and and here's the thing
to a lot of times um
the interesting part of this is it
typically typically relates back to the
arm cotton we call it the the adjacency
list so just to just to give you an idea
this is usually something that you build
off of an existing schema like an
adjacency list this is not something you
start with the nested list is almost I'm
not saying it never is I'm sure somebody
out there spent a lot of time writing
crud operations to make this work which
seems somewhat insane to me but
typically the way that this is used is
you take an adjacency list um where they
already have a hierarchical model built
and then you build this nested set and
we'll go into the reasons for it what
might as well right now anyways right
like what's yeah it makes sense to me
like if you want to know the ancestors
of Michael you just take that left to
right values and say give me everything
in between and yep you're done right
well more specifically let's drill let's
talk about like where if you wanted to
find only the ancestors or you know you
know that the lineage of my mother in
that example right her left value was
too and her right value was six right so
you can know who sit yeah because if
grandmother was three left four right
500 says yeah okay yeah real time
editing so yeah I'm sorry so mother my
mom would have been two and seven and
then you could do a search where the
left value is greater than 2 and the
right value is less than seven and then
that would immediately return back the
anyone in the tree below mother right
now here's that here's the big advantage
of this right like they are depending on
how much data you're working with you
know it does it is a little bit more
involved to create this data now that
doesn't like you could you can have
hundreds of thousands of records and
still create this data within like
yeah 30 seconds right so that might not
sound horrible it is horrible if you
were trying to do that inside of a web
call right yes oh you wouldn't want to
do it then that's why you'd want to do
it in batch but you so you could build
that all up front but the so you take
this relative term of it it takes a
while to create but once you have this
data created the querying of it is
ridiculously fast and easy into a really
large data sets back of these trees
right of you know these and sub trees or
start at the entire tree like whatever
portion of the tree you need right you
can real quickly get to all that data
and because we're just talking about
simple integers right or depending on
how large you need you know you can
easily index these which is why I wanted
to comment on any of the adjacency lists
like that's not necessarily just you
know rum you know specific to that so so
you can do some some nice indexing too
and really get your query performance on
it so what you would typically do when
you implement these nested set models is
you'd have the data and like Alan said
you would have going back to our
employee example you know you have that
employed table and built into that and
you know each one of those records is
the adjacency list where every employee
knows its manager right so there's a
column called manager ID right you would
have typically this nested set model
that that output in its own table right
and there would be a foreign key
relation between the employee table and
the hierarchy table so that you could
join those back and forth and so that
you can say like hey where the employee
and joint on the input where the
employee ID equals the hierarchies
employee ID and then find where the
values of for the left match whatever
you're looking for and the values for
right so if you wanted to find you know
if you wanted to find everyone in the
tree
above someone like going back to the
example where it said that my mom's
value was too and her right value was
seven or eight let's go no this time
about this used the grandmother in that
example her left was three and her right
was for will hold up before we go that
far I think there's one more piece that
we need to add in here now we got the
left and the right okay that tells us
what we encapsulate right like what our
reach is will say there's also one other
piece of information typically when
you're doing the nest and set model that
you add as well and that's the level so
so as you're walking down and and you
know and we'll go into why you do this
in a minute but I wanted to add this in
here because this is where the querying
becomes easier so right now Mike was at
the top so we'd say his node level is 1
or 0 depending on what your ordinals
work his mom is level two his
grandmother and grandfather level three
is dad when it started coming back up
the tree now is also level two alright
so we have nodes 1 2 and 3 node levels 1
2 and 3 and this is important in a
second when we start getting into kind
of where he was going with this so so
now each record has a left a right and a
level will call it all right and so now
let's go back to where you were talking
about so you're going to query from your
mom or your grandma well yes I was with
grant I was thinking the grandmother
because then you're going down like
three deep right because her her left
was three her right was four right right
so before we were saying where the
values were greater than but instead we
could say like where the left is less
than three and the right is greater than
four yep and that's going to walk you
back up the tree right and so that's
going to find that would return back my
mother in that case and myself in that
case and this is where the level comes
into play but the level wasn't necessary
it is so here's why so if you were going
to do something like um say hey tell me
everybody that is a direct report or a
direct on parent of Mike the easiest way
to do that yes yes yes I see where your
timeout and even going back up
even going back it up because you could
say hey who were her parents now you
would just say hey we're node level
equal no level minus 1 and left is uh
less than that left and right is greater
than this right and then that way you're
just going up one because if you just
said less than it's just what you said a
second ago if you'd say give me
everything with the left is less and the
right is greater that's going to give
you everybody above her okay I
understand what you're saying and I
don't disagree with it but the only
reason why I wasn't bringing that in
immediately though it was because it's
not required right like you could
implement you can have the necessary
that level yeah you could you can have
that you could have the necessary that
it I don't think it's just if depending
on the years listing specific kinds of
queries where you wanted to go as
particular levels and if that was the
case then yes it would absolutely be
crucial I don't I don't know that you
could do some of these queries without
it and the reason I say is because when
you start doing the left less than and
the right greater then um there's no way
to narrow it down to just one level
above you without the afraid he's a joy
and if that's the type of thing that you
needed to do if you didn't need to do
that type of query then that level isn't
it is irrelevant and that's why I'm
saying like if you only needed if you
only needed to build a model where you
either need to go down the tree from
where you start or from up the tree from
where you start then who cares about the
level but if you say that you only want
direct reports or direct parents we'll
see but and I'm saying I didn't list has
example but no but that's why I'm saying
like typically when you are doing a
nested set model you want those three
key pieces of information and the reason
I say it because without without the
level you are now hindered to what you
can do you can only go all the way up or
all the way down you get hint you can't
say I only want his first two levels or
I only want his first level or I only
one piece of math on that and that's
what I'm saying a lesson now that left
value now it becomes extremely expensive
and your joins are going to be crazy too
so so okay yet fair enough I'm not I'm
not I'm not discounting this but when
I'm when I'm trying to get at though is
the core for the necessary yes adding
the depth to it or the level or whatever
you want to call that is a variation on
this that definitely makes it far more
beneficial depending on what you're
trying to do but the root core of what's
required for the necessary that right it
doesn't that's the only point that I was
trying to make and that's why I hadn't
brought it up yet but but now to where
you're talking about though now you
could do some some more advanced queries
like what you were saying yeah I mean
and if we I don't even know that we've
so yet we somewhat talked about the
pseudo query on it right like if you
wanted to do it you'd say a select star
from a in let's say that you call this
employee tree right or something like
that because you still have your
employee table which like we talked
about earlier or not employ a little
istic with the employee because it was
already there you have your employee
table that had the manager ID and the
employee ID right if you're going to
create a nested set table you're
probably going to call it employee
hierarchy or something like that right
um and then in that table what you would
do is you'd say hey select all from
employee hierarchy where you know
employee ID equal one and then you would
join back to itself and say join
employee hierarchy where left is greater
than employ the the parent employee will
call it its left and or you just do the
between right we talked about this
before you can just say it between we're
left is it is between um the top
employees left and right yeah you ask me
a little bit there okay go ahead no I'm
trying to
trying like so so if you're trying to
find everybody that's a child of that
top level right you can say give me
everybody where their left is in between
my left and my right right in that will
return back the tree blood that are
returned about you area below you so
it's a very simple query that's another
part of the nested set that is actually
pretty awesome is when you first put it
all together it's kind of hard to look
at it doesn't make a lot of sense but
once you actually fully understand what
you're what you're looking at which is a
flattened hierarchy is really all it is
when you do that querying this thing
becomes easy hey give me all the left
values below me that's going to fall in
between my left and my right if you want
if you want everybody above you can say
hey give me everybody above where their
left is less than mine and they're right
is greater than mine right to get the
entry above yep and it's just it's a
it's a self join back to itself to the
same table so you would join employee
hierarchy to employee hierarchy on these
type of predicates that we're saying
we're left is between you know this
employees left in this employees right
so it's it's pretty simple to query
which is one of the big things now
building this table I think you did one
recently yeah it's a it's a bit of an
exercise right it's definitely it's
definitely a fun little challenge if you
haven't done one in a while but the yeah
it in again like let's exclude where Joe
was trying to get crazy with us on the
circular crap which breaks it completely
you can't even do it right I mean
circular is any problematic for a lot of
higher cool just about anything yeah
what's why they're called higher but how
do you prevent that right like you know
if my query for kind of recalculating
this stuff on it insert or update breaks
you know there's no sort of constraint
that I can really put in the database
right to prevent this from happening no
you could you could in sequel server you
can create constraints that would that
would not allow that you basically
create a blue
Eve you can create a check constraint
and sequel server and you can buy me
levels deep we should write a CTE that
would be that check constraint so it's
going to be fairly excited but but it
could be fairly expensive right but what
I'm saying is you can actually create a
check constraint I believe that would
allow you to query the hierarchy and
make sure that you're not inserting
anybody to weigh down here that's or
that's referencing you know somebody
that's going to put them into some sort
of circular loop that's kind of hard for
this model because you know it's almost
like I need to kind of disabled that
restriction while I'm doing all these
individual little updates in a
transaction and then I need to kind of
put that constrain back on right cuz
like as I'm kind of going through and
rejiggering this unless I you know wipe
out all the columns that's what we
really do again this will only way you
you wouldn't even have this this data
you would not want to be attached to
your main table you want this in its own
table because at every time this batch
runs you will be blowing that data away
and restarting and so if you had that as
columns in your main table then it's
going to decrease the performance of it
because you're going to end up locking
that all the time yeah every time this
batch runs but if you put it into a
separate table then you could do all
your work in memory and then at the very
end just truncate table and yep does it
in and let's be clear you would never
ever want to try and recalculate these
things on the fly I've heard of of
people who have tried to put enough
space in between left and right like pad
the left and right so that some hundred
in between exactly and you can kind of
fill ins by exactly so like what law was
saying a minute ago where you know he
was one as mom was to his grandma was
three and then so on back up instead of
that he would be he would be 100 she'd
be 200 and then 300 and yeah but then
you still take a hit because you had to
have something on your constraint to be
able to verify like hey have I gone
beyond yet because if i have now it's
time to take the big hit and redo this
out and that's nothing in it take it
even further now the logic you have to
build in to actually determine when you
need to rebuild this thing if it's not
just going to be some sort of time
it's going to be insane so basically
what I'm saying is you'd have to write
incredibly complicated code to manage an
update on something like this whereas
typically what you do is in sequel
server like a way that you will probably
go about this is you do a select into a
new table it's so so that you didn't
lose any any gap of time in between when
this thing is being built and if you
wanted to swap it out like a strategy
that I've seen done is you select into a
new table and then you would do
something like an SP rename to where
it's almost instantaneous you rename the
old table to underscore old and you
rename your new table to what the old
tables name was and then that basically
swaps it in immediately um and let's
let's take it back to it the two primary
reasons for building this table are one
performance in two easy to query right I
mean that's yet there is one other you
know another downside of this that we
haven't mentioned it yet and that's that
you don't have the referential integrity
that you're Jason c-list had right there
like these left right values are just
calculated values they're meaningless
outside of that table yeah like even
that depth column that you talked about
like if you did go with left right and
the depth none of those mean anything
other than what you know within this
table don't that's their only in place
where they provide value yep so and
let's be clear though they are extremely
useful like if you need performance they
are incredible oh yeah the nest set
model you mean yes yeah yeah and also
too I don't think that we mentioned this
but the guy who named it that Joe so co
GI Joe cellco cellco you know he's the
one with a giving credit for having
introduced the name nested set model and
will have shit will have some links in
the show notes to it it's it's once you
see this
some of these imagery to back this up
it'll it'll it'll lock in it'll sink in
a little bit better because I can
understand how like if you're hearing
this for the first time this is going to
be a tad much to understand so that's
why I'm trying to be I'm trying to
explain it as well as I can and I hope
I've done a good job of that lots of
good pictures in the show notes yeah
yeah I mean we'll have to it's but I
mean like everything we do on the
podcast all this stuff is kind of hard
to completely visualize but hopefully
this will give you something to go look
at be like oh if I run across this
problem in the future I have an idea of
how I can solve it right um I've used
nested set tables in the past and I
definitely did them to where their
process like every few hours or whatever
in in situations to where you know you
needed to see things like employees or
even products or things like that um
because the performance gain that you
get out of it is absolutely fantastic
now if you have bad data it can cause
you problems right like if you're a
referential integrity on your on your
real table that contains that data
doesn't do things like check for
circular dependencies or there's gaps
and the data now you have to figure out
what you're going to do with it right
like like typically you're going to look
down from the CEO and then you're going
to have that manager and then their
manager or whatever but what happens
when you have a break somewhere in the
middle where this guy's just kind of
floating he doesn't report to anybody
what do you do with that data right oh
well this is a good thing that we
haven't mentioned though is because that
this by having this data in its own
table right there's nothing to say that
you can't have multiple hierarchies in
red table right so if you're as you're
creating these nest set models right
you're as you're creating the data for
this nessa set model you depending on
your data structure you might have
multiple people who are considered you
know that at the top of their respective
tree and you can have multiples of those
trees yep no that's why tying it back to
the original table where the foreign key
is going to be crucial in that regard so
like in the employee example that I gave
where you would have an employee ID in
this hierarchal you know I think you
referred to it as the employee tree
table so you'd have an employee ID
column that was a foreign key back to
the employee tatis yes oh now one thing
this does not do though and will not
allow you to do is you could not have a
child be a child of multiple parents all
right no so that is there are other
situations and other solutions that
we're going to talk about other models
and well that does kind of confuse the
family tree example that we started with
that okay that's flipping the tree guys
fucking yeah so the way that he actually
created the tree where he was at the top
kind of surprised me because it sounded
like he created his parents but but no
if you were to take it from his
grandparents down you'd see that so like
I could not report to both Michael and
Joe in this type of situation unless you
have the tree upside down but but then
you'd have the inverse problem too um
but that is one thing that this
particular model will not support is a
child can only be a child of one parent
it cannot have multiple parents there
are other models that will allow that
but that's just something to be aware of
yeah and we're going to we're going to
just got like I said we're going to
discuss some other models in coming
episode so we look forward to this as
being you know a fun topic to be able to
dig into so and by the way family trees
start you start it yourself and worked
out I'd ever save every tree like that I
thought the truths always like the
branches came out those are all the kids
and everything right yeah they go down
like when you draw a family tree ok
maybe I'm just crazy I don't know that
I've ever drawn a family treats I'm
probably the worst person to ask about
that oh alright so yeah there are some
other examples we get into materialised
path closure tables you know we're going
to come into these into coming upset so
we're really looking forward to this
yeah it's and I think this is all really
useful information I mean if you ever
cross these paths you'll know some of
the pains that you that you um that you
hit doing this kind of stuff hey it
looks like we lost Joe yeah I don't know
what happened there we've had our first
technical diff our first technical
difficulty on the show which
not too bad a now until now militancy
yes and I reboot the internet down
alright so technical difficulties have
been resolved and we're back yep so I
just wanted to recap the adjacency model
is basically where records sources
parent ID and it's a simple model but
the problem is that it's scales poorly
so as the data size grows it gets slower
and slower and to contrast it with what
we've just been talking about the other
solution we talked about tonight is the
nested set model which is much easier to
query much faster much more elegant but
the problem is that you have to maintain
that data so it's harder on inserts and
updates but it's much quicker for
actually queering that data I agree with
most of that except with maintaining the
data you would just blow it yeah you
want in and you just can't do with that
often right well you could I mean it's
on your batch yeah it could I mean so
like like outlaw said I mean we've had
situations I know he's done it recently
and I've done situations where I had you
know hundreds of thousands if not close
to a million records and you can do it
in under a minute yeah I mean I had it
down to like look within the teens i
think in seconds yes no or huggies low
records so save loads got to be less
than a second right so you wouldn't do
it on the page load that's why you'd
batch it but you might do it every 10
minutes you might do it every five you
might do it every so it's not anything
that you're actually going to be
dependent on a user interaction this is
going to happen in batch behind the
scenes and then you're just going to use
that table for my purpose i was able to
do it like once a day yeah right and and
you know that that's 16 seconds or
whatever you know yeah you wouldn't want
to take that in a web request but 16
seconds you know at 4am the morning who
cares yeah right so even throughout the
day right if nobody's actually using
that code it's just happening and then
you get the benefit by using the table
and we'll have like I said we'll have
some some links to this stuff in the
show notes and you know some imagery to
to help describe it so be sure to check
out the show notes and yeah so let's get
into the resources that we like
yep so um one that I had found a while
back and kind of what sparked a little
bit of this was on SlideShare there was
a nice little thing that it got put
together that was literally several
different types of models for
hierarchical data and we'll go ahead and
link to that one and then one that I had
found years and years ago was Joe cellco
sequel for Smarties that's a book that's
available on Amazon and it's it's really
good i mean if you want to get some mind
benders this is I think we're the first
nested set model thing came into play so
um or at least one of the first
references that I'm aware of so that's
another reference yeah and there's also
a link that will include to stack
overflow where talks about different
options for hierarchical data to that
that gives a really nice concise
overview of different models so we'll
include that as well all right so now it
is time for the tip of the week oh yeah
let's get into it we tip of the month
whatever my idea may I be like that it
hurts okay so so here's the thing like
how well be honest with yourself now how
well do you recall all of your big o
notation totally like like not not just
all the variants but also like the
expense of it which one's better than
another one you have memorized which is
worse which is best like you know
average you know do you remember all of
that right I remember like the time
complexity this is a thing called Big O
there's a lot of it and and it is it is
a bit much to try to remember all of it
so so especially if you don't use it
regularly you know yeah let me out know
how much you know you talk about Big O
notation with your spouse but you know
it comes up every now and then right but
if it doesn't then this is where you
have the Big O cheat cheat com it's
awesome and is this really cool resource
that you can go to in it it
maps it all out you can see which ones
are that you know average performers
which ones are the worst performers
which ones are the best performers for
different it gets into it like for data
structure operations are a sorting
operations graph operations like heap I
mean there's a bulk of different ways
that it talks about you know which
operations perform better and gives
their big o notation for each of those
operations so again Big O cheat sheet
calm and we'll have a link to it in the
sugar yep that's most excellent yeah and
the one I wanted to mention is actually
from let's say they've got a
pronunciation guide div V us as your
website's net has a great setup for
basically the shortcuts they use with
their gaming mouse so we talked about
this a little bit in episode 8 um you
know basically gaming mice have all
sorts of crazy buttons and they've got a
great diagram here it's got maybe I
don't know eight buttons on the side of
their mouth and they show actually the
kinds of things that they have hooked up
to these different buttons so you can
press a single button to build a single
button to step over step into stuff like
that so this is really nice and whatever
that was kind of funny about as if um if
I tried to you know be honest with
myself and kind of setup shortcuts for
myself for things that I actually do
commonly I might have one for like
restarting visual studio I might have
one for you know I can go ahead and add
and commit with a message of I don't
know why this works you know
uninstalling resharper exactly how god
that hurts yeah it hurts even make the
jack troubleshooting now wireless and
the question though how did you say they
perhaps this because if I look at their
URL I got to hear this again yeah it's
on the first the first syllable is the
problem one it's like under
pronunciation guides dih which looks to
me like did but I always thought the
word was devious yeah because when I
look at their URL it's definitely
devious ghosty vyas so how do you
pronounce dih devious yeah I don't know
yeah this is wrong yeah that their their
URL is devious double major websites I
think I just got it it's Devi asst no
but yeah there's actually underneath the
pronunciation there's a definition for
the word which is showing a skillful use
of programming tactics to achieve goals
as in he's a devious as a programmer
needs to be ok ok it's devious all right
yeah I hate that I just said it totally
wrong even though his pronunciation
guide at the very top oh well anyway
it's awesome article and it's got great
pictures and it's great idea excellent
so mine is is because I ran into some
issues or a couple of us ran into issues
recently where we couldn't see
dimensions in a cube oh my god you go
into sequel manager on a hotter hotter
hotter haha you can't you can't bring up
this we haven't even talked about mdx or
cubes not even once and suddenly you're
just going to throw this on us as a tip
of the week i'm going to because anybody
else out there who runs across this will
probably be like Oh hallelu hallelujah
right yeah their brains are melting too
so if you have the misfortune of working
with cubes &amp; M DX and you have to look
at dimensions and things like this ran
across a thing to wear I get this query
from somebody in mdx query that has
these dimensions in it that I can't see
in the cube browser in ssms management
studio and in it it just stomped right
like there's magic here not all know
what this magic is the answer is to get
a data tools I forget what it was I'm a
business of business intelligence data
tools for visual studio and if you
install that you can then open up an
announced the services database within
visual studio and you'll have access to
everything now well basically at that
point you're looking at
what it takes mattituck yelled the cube
yes so super clarity all of them so for
those who aren't familiar with mdx is a
multi-dimensional wine or the X stands
for query I don't know I for you x times
4 but it's a multi-dimensional query
language yeah and it's disgusting it's
it's great and if you wonder like what's
a multi-dimensional query language Excel
yeah it seriously I we're not going to
go to open up our open up Microsoft
Excel and now imagine you know you have
you have your table as your worksheet
but then there are multiple worksheets
within that Bob's you could have
multiple workspaces or workbooks is what
they cry right we could have multiple
Excel files and they could reference
other ones like it's it's truly a 40
space but the key here is if you're not
able to see all the dimensions that you
think you should if you open up the cube
inside Visual Studio using that plug-in
then you will then you will be able to
see all the dimensions and everything
else that went into building that cube
and there was a trick to with this with
this plug-in that you should probably
mention which is if you already have
well you probably already have sequel
server tools installed but it during the
install it's going to bring up your
standard looking sequel server install
GUI and it's going to prompt you hey do
you want to install any kind of add-ons
to an existing instance or do you want
to create a new instance and you're
going to be tempted to say hey I just
want to add onto an existing instance
and because all I want to be able to do
is add in this ability to view cubes but
that's not going to work yeah you will
need to specify a new instance and even
though it sounds like it's going to
create a new instance it's actually not
yeah it doesn't is complete garbage for
you I for install I think that's just
the cost of reusing the regular
installer yeah yeah but um yeah pretty
cool pretty cool information frustrating
that you have to find out that way but
you know
yeah oh oh oh I have one other tip okay
only because he is now witness the
greatness that it is a 34 inch ultra
wide monitor what is your take outlaw I
don't know any time out hey I think he's
gonna try and steal it tonight what you
don't even have one yet he's gonna get
clubbed on you don't even have one yet I
don't know what you're talking about you
keep talking about wanting to buy one
you jealous of mine it's amazing right
you're jealous of mine hey what did you
do when you sat down with visual studio
on that thing well I did what any
self-respecting developer would do I
started tearing off tabs yep yeah i saw
you started nesting so I set up your own
little bat cave dude he had he had four
vertical tab groups on that modern man
it's a beautiful thing i I've never seen
someone have so much fun setting up
vertical tabs he's like look I'm at
third now I'm gonna take away I'll put
two more I I don't know why I'm calling
you out hey I'll tell you guys right now
we're gonna put another I'm gonna link
to it again in the show notes or
somebody's going to that monitor is
glorious like there's no other word for
it it is it's pretty spectacular I'm not
gonna lie like if you there's actually
there's actually include this and share
notes there was a life hacker article
where it was talking about you know
should you go multi monitor or
ultra-wide monitor and they made a
pretty good case for going single ultra
wide and you saw it it's is pretty
amazing yeah I mean it's all good it's
all it's pretty spectacular I'm not
gonna lie yep alright so that's it
alright so we talked about two ways that
you could possibly deal with higher cold
data and in the adjacency list and the
and I said well we're going to beginning
in them more in future episodes so you
know we hope you enjoyed this one and
see what oh no we needed to have a pole
and what should the pole be okay wait no
you go on I had an idea for the Pope me
go on yeah yeah I thought you wrote a
blog post talking about this and that's
how this all kind of came to be but now
I'm not so sure well I did write one
about a product hierarchy and cat
Asura's he and it's actually
surprisingly one of our more popular
articles on the site which is Shia
because I've given it no love since them
but oh so adamant thanks to put this in
the resources we like section but
apparently gets passed by the time or we
don't like it it's one of the 20 so yeah
that's pretty much it for that so um
what about for the PO I'll how long are
you a partner oh yeah so let's do this
on episode slut or cutting box.net /
episode 28 if you go there we're going
to have a poll on there and we're going
to ask you know how long have you been
programming what's your experience level
what's either that or another co-op
tonight happy you can see a ham sammich
phone is pull they just keep around like
whole idea there's another one that I
had to is that a shit Joe move back
there and I think I oh no I think that
we need to change is from pole to survey
oh right okay I'm feeling a little I
don't look okay yeah we'll stop that
right there and surveys filter go survey
all 2 episode 28 please that's this
guide to us on iTunes sister and more
using your favorite podcast app and be
sure to leave us a review on iTunes
stitcher more contact us with a question
or topic leave your name
and preferred method a shout out website
Twitter whatever and we'll be sure to
mention you and visit us at Cody box net
where you can find our show notes
examples discussions and more send your
feedback questions and rants to comments
at coding box.net and be sure to follow
us on twitter at cutting blocks in any
kind of corny jokes that you have we
appreciate that Simmons is late at night
yes especially late nights at coding
blocks just do it we have fun with it so
yeah that's a episode 28 is a wrap
you
hey you you green be targeted again
to weigh finally
it presents all the material list
wanted to send everyone at linkliste
full text lowered she wanted the
is president inside the mold to left
so this was about enemies finally
as well as a video tv video hifi if
wc as you remain a when it finally
anger is linkliste it is a target
it not that
these details would be ex boyfriend max
finally so many politicians on
pointer sisters anyway remains a
Hague's very strong in me is totally
number of notes and more than any
exot is a chain is left with 6 1
next thought and siris regulated how
at least as you may care not max
is not a theory
next is correction and 600 how to how
You wc still one of the not any other cases
visualize how such a cattle Triemli
Member of video wiki envy15 link
can they present
if it is useless as a presence in the form
is
is similar representation is not
not further
grabbed the front of electric nissan direct
I wanted the studio the sundaytimes
wants how well it
to 16
goal-it's the mavericks
she is fully present them to
graf think
hi I'm Jonah in this video I'm going to
explain two different ways to implement
a graph and then I'm going to explain
some of the pros and cons of each and
I'll show you how to implement both of
these methods in Python so the first way
to implement a graph is using an
adjacency list so let's look at this
undirected graph it has five vertices
and some edges connecting them an
adjacency list actually is a set of
adjacency lists because each list is
stored in its own vertex so a keeps its
own list of directly connected neighbors
other vertices that it has an edge to so
a has neighbors B C and E node B has
neighbors a and C as we can see here
this is going to be stored within each
node or each vertex is going to store
its own adjacency list now the other way
is using an adjacency matrix and the
adjacency matrix is a two dimensional
array and it basically stores a zero
where there is no edge or a one where
there is an edge from A to B we can see
there is an edge there or from A to C
there is an edge as you'd expect since
this is an undirected graph this is
going to be symmetrical across this
diagonal so from A to B is a 1 from B to
a is also going to be a 1 then the
adjacency matrix like I said it's a 2d
array and is stored in the graph object
so there's one adjacency matrix
centrally located in the graph object
how about if you have weighted edges on
an undirected graph well it's much
easier to implement weighted edges with
an adjacency matrix instead of putting a
one for edges where there is a
connection you just put the weight of
that edge so it's very easy to do that
you already have the cell you can put
instead of a 1 you can just put the
number of the cost or the distance or
weight of that edge in the cell so
extremely easy to implement using
adjacency matrix you can also implement
weighted edges in an adjacency list but
it's a little bit trickier so if you
have a directed graph again very easy to
do this using an adjacency list so here
we would have
a has one outbound edge to see so we
list under a only C as a neighbor that's
the only neighbor we can get to from a
so we're going to list all the outbound
edges for that vertex so C has edges to
B D and E and we list all the outbound
edges from C here in C's a Jason C list
you know Jason C matrix the same thing
we're basically going to put ones where
we have an edge outbound from that
vertex so we have the from on the left
and the two is div columns so which is
better well before we can answer that
question let's look at some other
characteristics of graphs a dense graph
is a graph where this is not absolute
value this is the number or count of
edges and the count of vertices so a
dense graph is a graph where you have
the number of edges is about equal to 2
the number vertices squared in other
words almost every vertex is connected
to every other vertex in the graph so
you get a really large number of edges
relative to the number of vertices a
sparse graph is a graph where E is about
equal to V which is what we have here in
this picture so there are a lot of
possible edges that are not actually
there another thing we're going to look
at before we answer the question which
is better adjacency matrix takes up V
squared space right this is a big factor
the amount of space required for this
adjacency matrix is going to be V
squared or number of vertices squared
regardless of how dense the graph is so
very very sparse graph you still are
going to take up the same amount of
space so for our little 5x5 you know we
only have 5 vertices in this example who
cares right but if you can picture a
graph that has ten thousand or a hundred
thousand vertices that's going to take a
project gigantic amount of storage space
so with those things in mind an
adjacency list is better in cases where
you have a sparse graph because it's
going to be faster and it uses less
space but the disadvantage of an
adjacency list this is slower for very
dense graphs large dense graphs is going
to be slower and the adjacency matrix is
going to be better for dense graphs
it's going to be faster and the space
complexity is the same as it would be
thrown on dense graph and another
advantage is that is simpler to
implement for weighted edges but the
disadvantage of this adjacency matrix is
that it uses more space and especially
for large sparse graphs or perhaps to
have a lot of vertices but relatively
few edges the adjacency matrix is not a
good choice so depending on the nature
of your graph you have to decide which
one of these is a better implementation
to go with so I'll give a quick
explanation of the adjacency list
version of the graph implementation
first we have our vertex class which
basically has two variables as a name
and it has a neighbors list and as we
add neighbors we see we have an add
neighbor function that basically is just
appending that vertex to the list and
then sorting it in the graph itself we
only have one graph variable which is a
dictionary of vertices so that we can
find any vertex by its name so when we
add a vertex we basically just check
that that object that you passed in
actually is a vertex object and then it
doesn't exist in the vertices dictionary
yet and if those two conditions are met
then it goes in as the vertex to the
vertices dictionary and when you try to
add an edge with vertices U and V then
it's first going to check if u and V are
both actually in this vertices
dictionary before adds it so if there's
an invalid vertex and it's not going to
be able to add that edge then we iterate
through the vertices and we locate
vertex U and vertex V and we add the
other to its neighbors and that's pretty
much it then I have a print graph
function down here at the bottom so this
is a pretty straightforward
implementation of graph I think it's a
little bit simpler so I usually favor
this over the matrix version although
the matrix version is not too hard and
then down below I have some test code
that we can test our our code up here so
implementing a graph using an adjacency
matrix this version is actually going to
support both weighted and unweighted
edges for undirected graphs and you have
to do slight modifications to support
directed graphs
so our vertex class you'll notice only
has one variable and that's just the
name of the vertex we don't need
adjacency this stored locally in the
vertex that doesn't happen here they're
stored centrally under the graph so we
have the same vertices dictionary so
that we can locate any vertex given its
name we also have this edges list which
is going to be our two-dimensional array
of edges that's the matrix and then we
have edge indices so that we can quickly
locate the index of any edge given its
name so when we add a vertex first we're
gonna check if it's actually vertex and
it is not in the vertices list already
and if not we add to the dictionary and
then our for loop here and the statement
right after that basically we need to
add another row and column of all zeros
to our edges matrix so we're going to do
that here we're add another row of zeros
and in another column of zeros on to
that edges matrix because we have mapped
any edges to this new vertex yet but we
need to add it to this matrix with all
zeros and lastly we add the index for
this vertex name into our edge indices
dictionary so to add an edge we're first
going to verify that both vertices U and
V are in our vertices dictionary and if
they both are then recall that this
edges matrix is symmetrical along the
diagonal so we want to add this edge we
want to enter the weight in the matrix
in both the top right bar in the bottom
left part so we're going to add the edge
to both u comma V and to V comma u we'll
set the edge weight and that's it for
add edge if we achieve that and we'll
return true and if not the return false
then lastly I have a pretty pretty
simple print graph function that prints
a pretty crudely formatted edges matrix
for us so you can see what that looks
like and our interface is exactly the
same as for the adjacency list version I
have exactly the same test code down
here below where we we set up a graph we
add some vertices and some edges to it
and we print it out I posted all of my
Python code here in my github site and
you can download that pin you also have
access to the PowerPoint file posted
here Omega up site so I hope this video
was helpful for you if you liked it
please click like and subscribe to my
channel I'm Joe James thanks for
watching
hey guys I'm Nili Schrom I deserve today
let's look at the problem of topological
sort so what is topological sort
topological sorting for a directed
acyclic graph is a linear ordering of
vertices such that for every directed
edge UV what text you should appear
before vertex V in the ordering for
example for this particular directed
graph in the topological sorted order
vertex three will appear before vertex
four because there is an edge from three
to four similarly vertex 3 will also
appear before vertex one and what text
one should appear before vertex four two
and six right
note that topological sorting for a
graph is not possible if the graph is
not a directed acyclic graph for this
particular graph topologically shorter
order of all over Texas would be this
order here vertex three appears before
vertex one and for vertex one and for
vertex one appears before four two and
six vertex one is appearing before four
two and six vertex four is appearing
before vertex five and vertex to vertex
four appears before two and five and so
on now let's look at the approach to
find out the topological sorted order
the first step is we start with the
vertex V having in degree of zero here
for this particular graph vertex three
has in degree of zero what X 4 has in
degree of two vertex one has been in
degree of 1 and so on so we'll start
with vertex three because it has in
degree of zero in the second step we
print the vertex V and remove the vertex
V and all in just coming out of it we'll
repeat these two steps till all the
vertices are removed let's simulate
these steps for this particular graph
first step is we start with vertex V
having in degree of zero that would be
vertex three because it has in degree of
zero second step is we print that vertex
V and remove the vertex V and all edges
coming out of it
so after execution of second step
our graph will look like this and we
also have to print vertex three then we
have to repeat these two steps till all
vertices from this graph are removed so
we jump to step number one we again find
the vertex V which has been degree of
zero here in this reduced graph if you
note what text one has now in degree of
zero in the second step we need to print
this vertex V and remove these three
edges from the graph so after execution
of second step topological sort order
will look like this and reduced graph
will look like this
because all the vertices from this graph
are still not remove we again jump to
step number one now there are two
vertices which have in degree of zero
vertex four and vertex six now in the
second step we can choose either of
these two vertices and proceed let's say
we choose to remove at X 4 from the
graph then the shorter order will look
like this and reduce graph will be this
we again jump to step number one now
note that vertex 2 also has got a degree
of 0 in the second step if we choose to
remove our text two modified graph will
be this and sorted order will be this we
jump to step number one again now we
know that what text six has got in
degree of zero in the second step we add
this vertex 6 in the sorted order and
remove vertex and edge from the graph
therefore shorter order will be modified
to this and graph will be reduced to
this now it's pretty obvious that vertex
Phi has got in degree of zero so in the
second step we print this vertex 5 and
remove vertex 5 from the graph therefore
sorted order will be modified to this at
this point all the vertices from the
graph are removed therefore topological
sorting for this example is complete
finally for this particular example a
topological sort order of vertices is
this now let's look at the Java code
which implements this algorithm to
implement the first step of finding a
vertex V
having in degree of 0 we first have to
compute in degrees of all these vertices
and then choose vertex within the
of zero in this print sorted subroutine
this for loop comes the in degrees for
all the nodes it also adds nodes having
in degree of greater than zero to in
degree hash table after completion of
this for loop or in degree hash table
will look like this
note that vertex 3 is not present in
this in degree table because we have
added only those vertices which have in
degree of greater than 0 therefore to
find out the vertices which have got in
degree of 0 we have to find out the
vertices which are not present in this
in degree table this particular for loop
populates the zero Degree list with
those vertices which have got in degree
of zero so after completion of this for
loop our zero Degree list 0 degree list
will have vertex three into it so using
these two for loops we have basically
implemented this first step of finding
out the vertex with the in degree of 0
now let us look into the next part of
this code which implements the complete
algorithm once this 0 degree list is
populated in this for loop in the while
loop what we do is we remove the first
vertex from this 0 degree list then we
print that vertex here which would be in
the topological sorted order and finally
to implement the removal of all outages
from current vertex what we do is in
this while loop we decrement the in
degrees of all the neighbors of current
vertex for example if the current vertex
would have been 3 that will decrease the
in degrees of 4 and 1 that is force in
degree would be modified to 1 and once
in degree would be modified to 0 and for
all those vertices which had previous in
degree of 1 the modified in degree would
be 0 and therefore we will add these
vertices in to the 0 degree list so
initially in the first iteration of this
while you are 0 degree list will have
only vertex 3 in it then at this step
will print the vertex 3 and in this
while loop what we'll do is for all the
neighbors of 3 that is 4 and 1 will
decrement the in degree by 1 so force in
degree would be modified to 1 and once
in degree would be modified to 0 and
because once ending
is now zero it will be added to the zero
Degree list so after the completion of
first iteration of this while ooh
our zero Degree list will have vertex 1
in it now in the second iteration of
this while loop one will be removed from
the zero Degree list it will be printed
here and for all the neighbors of one
that is for two and six in degrees will
be decremented by 1 so force in degree
will be modified to 0 2 is in degree
will be modified to 1 and n degree of 6
will be modified to 0 and because the in
degree of 4 and 6 is now zero what Isis
4 &amp; 6 are added to the zero Degree list
where text 4 &amp; 6 are added to the zero
Degree list repeating these steps until
are zero Degree list is empty gives us
the topologically shorter order of the
vertices the topologically sorted order
of what Isis would be 3 1 4 2 6 5
I hope the explanation was clear in case
you have any queries or feedback please
feel free to comment and do not forget
to subscribe thank you and Cheers
This video is on graph representations.  It is the second video in a basic
graph algorithm playlist, after the introduction to graphs.  This one goes
over the two most common ways to implement graphs, adjacency matrices
and lists.  After a few simple representation related algorithms, I'll
compare their strengths and weaknesses. 
So you have this abstract
graph out there, with vertices and edges, and maybe each of those has
information that goes with it.  The graph representation we choose
is just some implementation which captures that abstract graph
information, but you can come up with different implementations to
capture the same graph.  The two most common models
are the adjacency matrix, and the adjacency list.  
Starting with
an adjacency matrix for a directed graph, we use a two dimensional
matrix.  We assume that vertices are numbered, and an edge from vertex i
to j goes in row i, column j.  What do we store for the edge?
In the simplest case, just a single bit, true or false, if the edge exists.
In the most complex case, you can store an edge object, or maybe a
reference to an edge, where that edge can store whatever information you want:
weight, name, hobbies, whatever you need for your problem.
A common case between those two extremes is when you just need an
edge weight.  So great, just store the edge weight in the matrix.
But what do we store if there is no edge?  Some languages might allow
you to store nil, or a null reference, but even then, each time you need an
edge weight, you first need to see if the edge exists, and then use it.
That slows your code down a bit, and also makes it clunky.
Instead, depending on what the weights represent, it's common to store a dummy
weight for missing edges.  If the weights represent something you are trying to minimize,
like a cost, you store a huge value, like infinity.
If you are minimizing costs, you should never take an infinite
weight edge, unless you can't solve the problem without one.  Again,
depending on what the weights represent, other dummy weights for non-existent edges
might make sense.  Hugely negative, 0, or hugely positive
are the most common values, where negative infinity might be used if
edge weights are profits that you are trying to maximize.  Finally,
for undirected graphs, the matrix is symmetric over the diagonal,
so you could try to halve your space by just keeping one side.
The Cormen book mentions keeping the top part, but I think the indices come
out cleaner with the bottom part.
Next comes the
adjacency list representation.  Here, we have an array of vertices,
and for each, you have a list of it's edges.  In the simplest case,
if your current vertex i has an edge to j, maybe you only need
to store that index j in i's list to mark
that the edge exists.  You can't get away with just a single true/
false bit here, you have to identify the other vertex.
For a weighted graph, you can't just store weights, you also need an
index or reference.
What do you use for lists?
You can use any list, and if the graphs don't change, you can even just
use static arrays.  If the graph never changes AND
you frequently have to look up whether or not edges exist, you
could even use sorted arrays, and then use binary search if you are looking for a
particular vertex in a list.  If you care about quick
lookup and also want to let edges be added or removed,
you could even use a balanced binary tree structure.  But, for lots
of algorithms, you only look at all edges incident on a vertex
in arbitrary order.  There, pretty much anything you use is fine.
I'll just show comma separated text in my slides.
For undirected graphs in the adjacency list model,
you store each edge twice, once in the list for each vertex,
unless you don't care how long it takes you to look anything up.
For directed graphs, you have a choice:  for each vertex,
you can store all of the vertices that it has an edge to, or
all of the vertices that it has an edge from.  Those are two different ways of storing
the same graph, and you pick one depending on how you are going to need
to access your data.  Storing outgoing edges is more common.
For some problems, you might want both lists.
What if you are given the data as an outgoing adjacency list, but you want the incoming
list?  You can go from one format to the other in time linear
in the size of the graph:  given an outgoing representation,
you create a new incoming representation with the same vertices,
and then for each vertex i in the graph, for each vertex
j in i's outgoing list, append $i$ to $j$'s incoming
list.   Let's quickly run through an example.
If vertex 1 has a link to 3, append 1 to 3's incoming list.
If 1 has a link to 5, append 1 to 5's list, and if 2 has a link
to 4, append 2 to 4's list.  Do that over all edges, it takes
constant time per edge plus constant time per vertex, done.
Going from the incoming list to the outgoing list is the same algorithm.
Going from an adjacency list to a matrix is
very similar.  Make an empty matrix, or for a weighted graph, a
matrix filled with dummy values.  Then, for each vertex, for
each outgoing edge, add that edge to the matrix.  It takes
time no more than the size of the matrix, the number of vertices squared.
To go from the matrix to the outgoing list format,
create an empty list, step through every location in the matrix, and when
there is an edge, add it to the appropriate list.  It takes time proportional to the number
of vertices squared to look through the matrix.
One final
basic graph manipulation algorithm: flipping the direction
of each edge in a graph is called taking the graph's transpose,
because if you are using the adjacency matrix format,
you just take the transpose of the matrix.  If you are using the outgoing
adjacency list format, just find the incoming adjacency
list for the same graph, and interpret that incoming list as the
outgoing list, that's the transpose.
So great, we have
multiple representations for the same graph, and can transform
one to another as needed.  Assume you have whichever representation
suits your needs most.  Let's compare the outgoing list
to the matrix to get an idea of when to use each.
First let's look at the space, or memory usage.  The adjacency list
has one list for each vertex, and each edge shows up in one
of the lists, or two for undirected graphs.  That's space linear
in the size of the graph.  The adjacency matrix takes up
size quadratic in number of vertices.  Is that bad?  It depends
on how dense the graph is.  If the graph has enough edges, the matrix
could actually use somewhat less space than the adjacency list,
but for sparse graphs, the adjacency list is asymptotically
better.  If we think about Facebook, each user has
on average a couple hundred friends.  It's a lot easier to store a hundred
links per user than to store a billion by billion matrix
for the graph as a whole.
What tasks does
each representation do well?  The most common basic graph
operations are to ask what vertices are adjacent to a vertex,
and to ask if an edge between two vertices exists.
Iterating through a list of vertices adjacent to a vertex is easy with an
outgoing adjacency list.  It takes time linear in the size
of the list, which is the vertex's outdegree.  The matrix
format takes time linear in the total number of vertices in the graph.
Again, not bad if the graph is dense and the vertex has an edge to
most other vertices, but it gets worse and worse the more sparse
the graph is.  Again, for Facebook, imagine how wasteful it would be if they
had to run through over a billion users just to see what they
should stick on your freakin' feed.  No one is that popular.
The matrix can find out if some edge exists in constant time,
while the list might take time linear in the degree of one of the edge
vertices to run a linear search.  If you expect to do lots
of those lookups, and decide to have the lists sorted in arrays or trees,
each lookup will only take time logarithmic in the degree of
the vertex, which might be small compared to the number of vertices.
That might be worth doing sometimes, but for lots of nice algorithms,
we don't look up whether or not an edge exists, we only want to
list vertices by adjacency.  Even though we will occasionally use
the adjacency matrix, the adjacency list is our default,
including for the videos up next on this playlist,
breadth first search, and depth first search.  For now,
I've got to go practice my miming skills.
[Sound of a mime screaming]
hi this is James Cook of the University
of Maine at Augusta and this video is
being shot to demonstrate the use of our
in combination with an R package called
I graph to enter social network data in
the form of an edge list and to present
it in the form of a network graph so
this video is based on two prior videos
which you can look at in my list of
instructional videos the first one is
about installing R and the second is
about the our environment the our
console in which you could type
individual commands and in which you get
reports about how things are going and
the other window which you can initiate
by heading to file and selecting new
script this our editor is a script
editor a script is a set of commands
that can be used again and again just
like a script in a play or a movie as a
set of lines that tell you how the plot
is supposed to go every command has one
line so I'm going to introduce a little
bit of a wrinkle which is that the neat
thing about R but also the thing you
have to pay attention to is that it's
expandable from a basic statistical
package and you can expand from your
basic statistical package by adding a
package a new expansion package and to
do that we'd simply head over in either
of the script or the console contextual
drop-down menu and select packages and
we could select install packages when we
do that it's going to ask for some
source to get this package from I'm
gonna select a Michigan source and move
ahead with that and then it's going to
come up with a list of packages now I'm
looking for the I Graf package because
the I Graf package allows me to engage
in social network analysis using
are and so I'm gonna literally scroll
down this alphabetical list until I get
to I G i GRA pH great and then I'm gonna
select okay now you only really need to
install this package once on your own
computer every time you use a different
computer you'd have to install it again
that's not really very hard watch it's
downloading it automatically and then
it's showing a log file that is saying
hey look at that it was successfully
unpacked and sums were checked which
means basically it's not a fraud package
trying to do anything sneaky that's
great so now I can begin my script and
the first thing I'm going to want to do
is use the command library I graph and I
graph is in parentheses what does that
do you just consider it a magic command
it just says hey let's use that package
you have to do that in every script
that's going to use this special package
so our knows to go look for it then the
next thing we're going to do is we're
going to define a network let's call it
my first network and there's a little
bit of magic here we're gonna have the
arrow we've used before which means the
stuff to the right is what the thing to
the left is going to mean but here's
what it's going to mean it's going to
mean it's it's called graph and it's
going to be a graph of particular edges
so this piece inside the parentheses is
the conditions under which we have the
graph so by saying we have graph and
then a parentheses edges we know we're
gonna have an edge list what's it going
to be well it's going to be equal to use
an equal sign see now why you see it
means it's a list this is just what our
does sometimes you just have to go with
what our means okay it's referring to a
list
and a list of what a list of nodes now
we can name these nodes why don't we
name them Alice and Sam okay and you'll
notice here I've put Alice and Sam in
quotes because I want the computer to
know that they are words that that mean
just text they're just names so I'm
putting them in quotes something called
a string and I'm putting a comma between
them to indicate that this is a network
in which Alice is connected to Sam but
that's not the only edge I want okay so
I'm gonna put another comma in between
to say wait that's not the only edge
here's another edge the next edge is
from Sam in quotes and then a comma and
another quote to David I'm gonna add
another comma to indicate ooh here comes
another edge and the edge this time is
between david quote comma and Alice and
I'm gonna put one more in and that's
gonna be between Frank comma and David
now you notice um I am moving over to
the right it's moving me along with it
and it's shoving the text over that's
okay I can just go down to the scrollbar
here and I can see it all the way over
now to the left as well as to the right
what I see here on the left is that I've
got two beginning parenthesis and you
always have to close off your
parenthesis so I'm going to do that but
I'm going to end the list by putting an
end parenthesis okay so there's C and
then all the stuff in the parenthesis is
a list a list of what of edges we know
that from the text okay and this is just
the syntax that's used just like we know
in English this is the language that you
will use to express an idea like I'd
like to have that book please period it
just the syntax you use finally we need
to let the computer know whether this is
a directed graph a digraph or an
undirected graph are these directed ties
or not so we're gonna add finally one
more comma outside the parentheses of
the C and we're going to indicate that
the option for it being directed is
false if we wanted it to be a digraph we
would indicate directed equals true if
we don't want it to be a set of directed
ties will indicate false now I have gone
through and decided that I'm going to
try to plot my first network and you'll
notice that there's this kind of syntax
you should notice the command is plot
and then what are we going to plot the
thing in parentheses my first network
and what is my first network look at the
line above it's the graph with the edge
list so now I can try to run this and
let's see what happens I'm going to head
to edit making sure that I have the
script window selected and I'm going to
run all super and there it is there's my
Network and it's even labeled that's
cool there are other options we'll
consider them later but that's all you
need to do your homework this week
there's one more thing you could do okay
right now if you've got this and you
wanted to work with this image how could
you get the image to save and then move
forward well you could right-click and
you could copy it as a bitmap and then
paste it into a Word file or paste it
into a graphics program or something
like that there's something else you
could do if you wanted to and we're
gonna go back to the script Network or
excuse me the script to window you can
actually instead of simply plotting you
can say let's say that as a graphics
file and the graphics format that is
universal so just about every computer
device is PNG portable Network graphic
or
meaning hey you can find it anywhere and
let's set a filename PMG parentheses
filename equals what's the name of the
file
my first network dot PNG and quote and
parentheses and then hey let's give it a
title so below plot I'll then put in the
title will be for the plot that the main
title okay title parentheses name equals
James cooks family Network and quote and
parentheses and then a final magic
command it's just what you have to do
death period dot off and then beginning
parentheses and then parentheses don't
ask me why right now you need to use
that it let's just say it turns the plot
off it turns the graphics generation
often says okay go save it to that place
what's the file name my first network
dot PNG where is it going to save it's
gonna save to your working directory
which you can find by clicking on the
console window and then edit excuse me
and then file mm-hmm
changed air I know mine is it's set to
documents right now but let's set it
instead to my professional folder ok so
that means that now when I run this if I
go to my professional folder and I look
for my first Network look what's there
it's a graphic and if I click on it to
look at it there it is it's a file James
Cook's family network with the network
in it it's all ready to go it's ready to
upload and that's your work for this
week why because I want you to have that
initial success in creating a network
graph in future work we will think about
different ways to enter network data and
think about different ways to visualize
to draw networks using our but as you
can see if we look at this script it's
only six commands they're really
relatively simple and once you get the
hang of it and make sure that you type
exactly as you need to it's not that
hard you'll get the hang of this and in
no time you'll be in our programmer best
of luck and if you run into trouble make
sure that you have everything spelled
exactly right if it stills not working
please get in touch with me and I'd be
glad to give you a hand
so hopefully you've watched the videos
on both network statistics and network
visualization what we're going to do
here is actually look at a network and
I'm going to run you through the full
basic process of loading up that network
running it through Gaffey pulling up the
basic statistics and doing an initial
analysis I'm going to do this at a
relatively quick pace I'll explain
everything I'm doing of course but I'm
not going to go really slow fortunately
this is on video so you can pause it
rewind and go back over things so I'm
going to do the whole process for you
like I do all the time watch it a few
times pause it check out all the details
and this should make it pretty
straightforward for you to go ahead and
do it yourself what I have open here are
two different files I've actually
created these from a different file part
of the difficulty in doing network
analysis is actually getting data in the
right format so I've done a little bit
of pre formatting for you here but I do
want to talk you through these so I have
two files nodes and edges which you can
see listed over here on the side let's
start with the edge file you can see
that it's just one number comma another
phone number so we have an adjacency
list here and on the top line it says
source
comma target this is specifically for
Getty if you're importing an adjacency
list you need the first line to be
exactly like this with this
capitalization that allows Guffey to
recognize your file as an adjacency list
so it can populate the edges correctly
within the program so there's lots of
places that you'll be able to find
adjacency lists online for all different
kinds of networks but if you do you want
to open them up in a plain text editor
and make sure you have source and target
up at the top this is a comma separated
list so I have a comma between those
words if this work tab separated for
example you would put a tab between them
this isn't the case here but you may
have additional information so for
example your edges might have a weight
in that case you could go ahead and put
weight as a third value here and then
your weight could go as the next item in
your lid
just make sure you get a label to
explaining what it is like wait the only
ones that have to be exactly correct are
source and target you can make up other
names to describe the other columns if
you have them I don't have weights so
I'm going to delete that and that's our
edges table now you might just be
working with an adjacency list here this
is given all in numbers but you may have
people's names or the names of other
entities I only have numbers here the
information about each of these nodes
was given separately so I have a
separate nodes file so my nodes are here
you can see that have the number and
then there's a name in quotes afterwards
again if you look at the top row of this
file it's ID comma label again those are
forget to let you know that the first
column is the ID of the note that's
going to match up with the numbers that
were in our edges file and then the
label is a keyword for get feed that
says basically this is the label that
we're going to put on that node so you
won't always have separate edges and
nodes but you can especially if you want
to add extra information about your
nodes I decided to go with this more
complex example that has the two files
so you can really see how to get it all
imported okay so we're going to come
over here to get e I've just launched
Jeffy's so this is our opening screen
and you can be tempted to just open a
CSV file that has an adjacency list
sometimes it'll work and sometimes it
won't so I want to show you how to do an
import that will always work instead of
opening a file just start a new project
and you're going to have a blank
workspace come to the data laboratory
tab on the top that's basically going to
take you to spreadsheets that have your
nodes and edges and you can see that
those are described here we're going to
start by importing the edges I clicked
on edges here but it actually will work
regardless of what's clicked on what you
want to look for now is this import
spreadsheet this is not the same as open
up here in the file menu so you do have
import spreadsheet there or you can
click it here and now we want to find
the file to import we're going to start
by importing our edges I happen to be in
the right folder you may have to
navigate to the right folder
I'm going to pick our edges file and
then do open and you often will have
this you want to check what kind of
table are you importing this says oh
you're importing notes which isn't right
we're importing edges so you have to
make sure that we pick the edges table
the separator here is what you have
delimiting or separating your columns
this is selected right as common now but
you can see it has presets for
semicolons tabs or spaces we're going to
leave it on comma and then we get this
little preview down here so we can see
that it has them labeled a source and
target and then we have all of our
numbers in here you may see an error if
you have like numbers or actual data
pair showing up in that top row that
probably means you forgot to add the
source in the target but this all looks
good so we're going to click Next this
says everything we need this create
missing nodes is always a good thing to
keep checked so just leave that as it is
and click finish and now we can see we
have a bunch of data here in our edges
table if we click over to the nodes
table we can see we have an ID that's
the number for all the nodes but there's
no label so we want to import our nodes
table that we had separately again we're
just going to click that import
spreadsheet button and we're going to go
and pick the nodes table now now you can
see there's an error here it says we
need source and target column but that's
because it thinks this is the edge table
so we have to go back and tell it note
that's the nodes table and now our
preview looks good we have ID in label
in the top and then we have the IDS
matching our numbers and the labels are
people's names so make sure that these
are matching ID and label they are and
then click finish and now you can see
our nodes table is populated with
people's names to match up with all
those numbers that were over here so
that's how we import our data click on
the data laboratory tab and use import
spreadsheet now let's go back to
overview and now we have this kind of
mess of a network before I actually go
through the steps here let's talk a
little bit about the network that we're
looking at this is a co-citation
network or a collaboration network we're
looking at people who have cited
a paper by Stanley Milgram this is a
small world's paper which we're going to
actually talk about later in the
semester and so we're looking at people
who have worked together or cited one
another are linked here so our network
is a mess the first thing we want to do
is lay it out that's always a good first
step I like to use the e fun whoo
algorithm I always keep the defaults
here if you start to get more into
looking at the different things to do
with layout you can of course change
those but they're pretty good at default
so pick that and then click run okay and
there's some crazy stuff going on there
right so we have our interesting little
thing down here but if you saw we had a
bunch of nodes fly off to the outside
you can use the zooming feature of
Jeffie by on a mac using two fingers up
and down or using the scroll wheel on
your mouse so i can zoom out a little
bit and you can see those nodes across
the edge if you get uncentered or if you
just want to see the whole network you
can always also click this magnifying
glass down here which will reset the
zoom and center the visualization so if
we zoom in here on all these nodes on
the outside they're just these single
nodes these are here because these are
people who have sighted the paper but
don't have any other connections those
aren't interesting to us and so we
actually want to filter those out
filtering is one of the first steps that
you'll do a lot of times if there's
anything to be filtered and it also
something that you might do it early
throughout your analysis you may look at
something and say oh actually only these
kinds of nodes or these kinds of edges
are important so filters matter you'll
see that there's a filters tab over here
and if we click on that we get a bunch
of different options
this query section is where we actually
put the filters that we want to apply I
suggest you take some time load up a
sample network and just explore all of
these filters but the one that I use the
most is under topology and that's degree
range so that lets us filter out nodes
that have a degree greater than or less
than some value so find degree range and
then it says drag filter here do that
drag the filter there
and now you have some settings you have
a slider down here at the bottom so you
can slide that pick a value and filter
things out you filtered that too much
there obviously slide it back down
things come back in sometimes it can be
hard to slide it to exactly the value
that you want you know I'm trying to
slide it to one and it keeps going up so
this is a hidden little thing if you
just double click that number
it looks like it's highlighted but you
can actually type the number that you
want and hit enter and that will filter
your network for you now once I've done
that I can click the center and we get
this big cluster in the middle just one
other thing in the filters you can also
click this arrow here that shows us the
parameters click that it shows us the
range and then that can be a way to see
the actual values if for some reason you
can't tell down here we could filter
further so we could take another filter
for example and drag it so after we
filter degree range then we could do
something else but for now we're just
going to leave that as degree range
so we filtered out all those singleton
nodes and now we have our main cluster
in the middle so you want to do some
analysis of that and hopefully right off
you can kind of see that we have two
main clusters one on the right and one
on the left so let's go over to to
statistics and now we're going to run
some basic statistics on this Network
the network overview has a lot of really
useful ones those ones that I always run
by myself I start with network dynamic
diameter that's going to give us a lot
of the main centrality measures you can
pick if you want to do that as an a
directed or an undirected network I'm
going to treat this as undirected I
think it's easier to work with
undirected networks so do that and click
OK and it's going to run this ran pretty
quickly but you may have noticed a
little progress bar opened up here on
the bottom of the guffy window you can
always check there if you feel like it's
running slow once you run it you get
this report it's always pretty
uninteresting I think it's got a few
little points that show up on these
graphs but it's not really anything that
provides a lot of insight but what you
get out of this is that Gabi has now
computed a bunch of different
melody measures so you must close this
window out and now we can use those
centrality measures to find other things
in the network the way that I like to do
that is to change the way the network
looks so there's this appearance box up
here at the top and you can click on
nodes or edges we're going to look at
nodes and you can pick all sorts of
different information about the nodes
the information is coded over here and
the two that we're going to look at our
color and size those can be hard to
remember but if you just kind of hover
it it will tell you that this is color
and this is size so let's click on size
and then you can choose if you want a
unique size so there you could just
specify every node will be the same size
or you can adjust the size based on an
attribute so let's click on attribute
and we're going to pick we'll start with
between this centrality you can get a
minimum so that's the smallest between
this will get this size for the node
that's in pixels the biggest between
this will get this one and it'll create
a smooth gradient between there so a
node that has a medium value between
this centrality will get a size
somewhere in the middle between 10 and
50 you can adjust those however you want
these are values that I tend to use by
default because it makes it easy to see
the big nodes but they don't get kind of
overwhelmingly large so from there we're
going to click apply and now you can see
we've got this one big giant node in the
middle that is the most central if I
mouse over that you can also see this
other interesting feature here which is
this arc right there that means the
person has cited themselves that's a
self loop the first place I actually saw
this was in food webs where you see what
species eat what and you'll see a
self-loop if they're cannibalistic so I
always kind of think of those as
cannibalistic nodes so we can see most
of these nodes have a pretty small
betweenness centrality except for that
one big node in the middle that's
something that we're going to come back
and look at in a bit okay apologies you
can see that my network has changed a
little bit because I crashed my guffy so
we edited that out I relayed it out so
now we're back here where we were so we
just noticed that we have this big node
here but everybody else looks about the
same
so there's other ways that we can look
at those other nodes in addition to
setting the size attribute we can also
set the color and we can base that on an
attribute and if we look there's all
kinds of other things we can pick here
so we can do degree total degree
separate that by in and out degree but I
like to look at closeness centrality so
that's where shows us the more center of
the nodes that may end up being the same
as between the centrality or it may be
different so that's an interesting thing
that you can visually look at in this
case we've made the big nodes have
higher between this centrality so if
they also tend to match the higher end
of our color scale then we know that the
two types of centrality are sort of the
same so they won't necessarily be so
here we have a color scale that's just
going from white to green if you click
on this little icon here you can pick a
whole bunch of different color scales
so let's actually do this one this red
to yellow to blue so we can really see
the color differences so the lower
closest centrality nodes will be red
middle ones will be yellow high
closeness centrality will be blue and so
if we apply that we say our big middle
node with high betweenness centrality
tends to be blue and then we have kind
of a mixed we've got a lot of these red
nodes with low closeness centrality but
and then some yellow ones scattered in
here so our closest seems to pretty much
track between this there's a similarity
there we could also compare this to
degree centrality and here we'll leave
the white to green scale and apply that
and again we can see there's a pretty
pretty close tracking our most high
between this node is also the darkest
green and as you go out from there
we see that the nodes get whiter so
basically that's telling us this node
has a very high degree high closeness
and high betweenness what is that node
right that's the question so we can we
can't tell from here and unfortunately
there's not some nice feature where you
mouse over it and it tells you but we do
have labels for that so there's a few
options that you can do you can kind of
pull this node off to the side if you
want to
and then we really can see how many
connections it has in fact it seems to
be connected to almost everyone which is
interesting so let's put that back where
it was by the way I just use this little
grabby tool over here that should be
your default that's selected I had
clicked on something else which is why I
had to go back to it so that's our
grabby tool let's actually look at the
labels now so we have this bar down at
the bottom and if you click the T it's
going to turn the labels on and this is
usually what happens when you do that
you're overwhelmed with the amount of
text that's there there's this tiny
little icon over here and if you click
that it brings up this panel that gives
you some control over these labels so if
we click on labels here one of the most
useful features here is under size you
can pick node size and you can see what
that does is it scales the size of the
text to match the size of the node and
so our big note in the middle has a big
label and the other ones have smaller
labels that makes it easier to read and
of course we don't even need to do much
we can see that this is Milgram he's the
guy that this network is based on right
we're looking at people who have cited
his paper and so of course he's going to
be connected to all these nodes in one
way or another so that sort of becomes
an uninteresting node to have in the
network we know that this is about
people who are connected to Milgram and
so it's not all that useful to have him
here from there we can sort of look in
and we can see on this side we've got
Duncan Watts you can there he is
Watts D we're going to read some of his
work in this class so he's a pretty big
one and we can't really read a lot of
the other labels so now what do we do
what I would do in this point and since
I'm showing you exactly how I do this
analysis is that we need Milgram out of
this network
he's just cluttering things up for us so
I'm going to turn these labels off we
know that Milgram is this big one and if
you can control click on it you can do
delete that's going to take that node
out of the network so I'm going to say
yes and now we have a network without
that big giant node now all of our
previous statistics no longer apply
right because they're computed having
that
in the network so the first thing I'm
going to do is just repeat the process
I'm going to use the you fun hoo
algorithm and lay the graph out again it
looks about the same except our big
giant node is missing I'm going to rerun
the network dynamic diameter making this
an undirected graph ignore the report
but now I have new values and so for the
nodes I can resize the degree and even
though the degrees haven't changed for
these other nodes the relative values
have changed right because our very
highly connected node is gone so nodes
may fall in a different place on the
scale so we'll apply that it's a little
bit greener for the size will still use
between the centrality and apply it and
then we can see we get some more central
nodes in this side and on the side
appearing bigger now I feel like this is
a little bit claustrophobic like
everything's kind of in on top of each
other and so there's an option here in
layout called expansion and all it does
is spread the nodes out it keeps their
relative position it just makes them
further spread so I'm going to click
that and you'll see it get bigger and
we'll do that a few more times so now
there's just more space between our
nodes that makes it easier to see which
of these are big ones and which aren't
so this is our node that I believe was
Duncan Watts we can turn our labels back
on we have J Travers and Granovetter up
here Duncan Watts we're going to read
he's written a lot about small worlds
mark Granovetter we're going to read he
wrote about the strength of weak ties
and so we're already starting to see big
players in this space of things that
we're learning about what we also can
tell is that we really do have separate
communities and if we zoom in here a
little bit this you can see for example
is Mark Newman Strogatz here Albert
barabsi these are all people who study
small world networks and network
structure we can also see a few little
errors in our data for example here's
Duncan Watts again so he appears as two
different nodes in the network if we
really wanted to clean it up we'd merge
those but since this one's so small
we can probably say well it won't affect
what we're seeing so over here these are
a community of people who all study
network structure small world networks
and the kind of mathematics of what
networks look like if we zoom out and
then zoom in over on this side what we
can see is that we have a lot of people
who study the sociology of networks and
I know this because this is what I study
but you'll see this when we look for
example at Granovetter asure k-- he's
really a sociologist and so these people
are looking at the math of networks
they're looking at the sociology of
social networks and how people use them
and so it makes sense that these
communities are largely siting within
themselves the mathematical people are
citing other mathematical people the
sociologists are largely citing other
sociologists but there is some overlap
between that you can see if we look at
Duncan Watts he's got some citations
over to this cluster and I kind of
jiggle the node you can see those edges
moving and vice-versa
our big nodes like Mark Granovetter has
some citations over to that side but
then we do have some nodes that kind of
fall in the middle they haven't written
a lot of papers with a lot of citations
but they point pretty much equally to
both sides so that's one way that we can
do this kind of analysis you can see I
kind of did this iteration between
looking at who's important running some
calculations and some statistics trying
different sizing and coloring attributes
and then potentially filtering out the
network in this case I deleted a node
but remember we've also filtered out
those Singleton's that were around the
outside reapplying our statistics
looking at it again and then doing an
in-depth analysis saying let's go into
this cluster which we can clearly see as
group together and let's see who these
people are so I'm fortunate that I read
a lot of this work and I knew who these
people are so I could define the
different clusters but if you didn't you
would just simply randomly pick some
people out of here probably pick the
higher between this ones first but then
also look at some others and look them
up and see what kind of care
mystics they have in common that can be
a lot of work but it's a really critical
step in the hybrid process of looking at
the structure and the content of
networks which is kind of the core of
what we're doing in this class so you
eventually learn here the distinguishing
characteristics of this group versus the
distinguishing characteristics of our
sociology group over here so that's a
basic overview of the process that I
often do and hopefully you'll get very
comfortable doing when using guffy to
analyze a network run this through a
couple times you'll see on the website I
have links to the files that I've used
here so you can try it out yourself and
hopefully that will get you feeling a
little bit more comfortable with the
process
we are going to look at using adjacency
lists in graph theory so let G be a
simple graph at the vertex set v1 v2 v3
v4 v5 so void for 5 vertices and that is
the adjacency list there v1 is a
neighbor of is adjacent to v2 v3 v4 v2
is adjacent to v1 v3 v4 v5 and so on
what we have to do here is answer the
two following questions first off list
the degree sequence of G so let's see
that one first so v1 is connected to
three vertices so 3 and v2 is connected
to 4 so there's four three three and one
so how do we write at the degree
sequence we write it out as follows for
in descending order there you have it
there in descending order four three
three three and one so now let's look at
drawing the graph here so I'm going to
sort of set it up here as follows
so we have five vertices this is v1 v2
v3 v4 and V 5 and let's see how they
connect up to one another so v1 is
connected to v2 v3 and v4 so that
connects there there and down there v2
is connected to all of the other four
vertices so it's already connected to
one there so it's connected to be three
it's connected to be five and it
connects to vie for v3 and v4 so we've
already connected it to v1 and v2 so all
that remains is just connected to be
four down there just going to color the
vertices back in here plus a v4 is
connected to v1 v2 and v3 so we've
actually have taken care of all of those
already lastly v5 is connected to v2 and
again that has also been connected
already 2v2 so that there is the graph G
and that ends our presentation thank you
so in our previous lesson we talked
about adjacency matrix as a way to store
and represent graph and as we discussed
and analyzed this data structure we saw
that it's very efficient in terms of
time cost of operations with this data
structure it costs Big O of 1 that is
constant time to find if two nodes are
connected or not and it costs Big O of V
where V is number of vertices to find
all nodes adjacent to a given node but
we also saw that adjacency matrix is not
very efficient when it comes to space
consumption we consume space in order of
square of number of vertices in
adjacency matrix representation as you
know we store edges in a two-dimensional
array or matrix of size V cross V where
V is number of vertices in my example
graph here we have eight vertices that's
why I have an 8 cross 8 matrix here we
are consuming 8 square that is 64 units
of space here now what's basically
happening is that for each vertex for
each node we have a row in this matrix
where we are storing information about
all its connections this is the row for
the zeroth node that is a this is the
row for the one at node that is B this
is for C and we can go on like this so
each node has got a row and a row is
basically a one dimensional array of
size equal to number of vertices that is
V and what exactly are we storing in a
row let's just look at this first row in
which we are storing connections of node
a this two-dimensional matrix or array
that we have here is basically an array
of one-dimensional arrays so each row
has to be one dimensional array so how
are we storing the connections of node a
in these eight cells
this one-dimensional array of size 8/0
in the zeroeth position means that there
is no edge starting a and ending at zero
at node which again is a an edge
starting and ending at itself is called
a self loop and there is no self loop on
a of 1 in 1 its position here means that
there is an edge from a to 1 at node
that is B the way via storing
information here is that index or
position in this one-dimensional array
is being used to represent endpoint of
an edge for this complete row for this
complete one-dimensional array start is
always the same it's always the zero at
node that is a in general in the
adjacency matrix row index represents
the start point and column index
represents the end point now here when
we are looking only at the first row
start is always a and the indices 0 1 2
and so on are representing the endpoints
and the value at a particular index or
position tells us whether we have an
edge ending at that node or not one here
means that the edge exists 0 would have
meant that the edge does not exist now
when we are storing information like
this if you can see we are not just
storing that b c and d are connected to
a we are also storing the knot of it we
are also storing the information that a
e f g and h are not connected to a if we
are storing what all nodes are connected
through that we can also deduce what all
nodes are not connected these zeros in
my opinion are redundant information
causing extra consumption of memory most
real-world graphs are sparse that is
number of connections is really small
compared to total number of possible
connections so
so often there would be too many zeroes
and very few ones think about it let's
say we are trying to store connections
in a social network like Facebook in an
HSN C matrix which would be the most
impractical thing to do in my opinion
but anyway for the sake of argument
let's say we are trying to do it just to
store connections of one user I would
have a row or one dimensional matrix of
size 10 to the power 9 on an average in
a social network you would not have more
than thousand friends if I have thousand
friends then in the row used to store my
connections I would only have thousand
ones and rest that is 10 to the power 9
- thousand would be zeros and I'm not
trying to force you to agree but just
like me if you also think that these
zeros are storing redundant information
and our extra consumption of memory then
even if we are storing these ones and
zeros in just one byte as boolean values
these many zeros here is almost one
gigabyte of memory once are just 1
kilobyte so given this problem let's try
to do something different here let's
just try to keep the information that
these nodes are connected and get rid of
the information that these nodes are not
connected because it can be inferred it
can be deduced and there are a couple of
ways in which we can do this here to
store connections of a instead of using
an array such that index represents
endpoint of an edge and value at that
particular index represents whether we
have an edge ending there or not we can
simply keep a list of all the nodes to
which we are connected this is the list
or set of nodes to which a is connected
we can represent this list either using
the indices or
using the actual names for the nodes
let's just use indices because names can
be long and may consume more memory you
can always look at the vertex list and
find out the name in constant time now
in a machine we can store this set of
nodes which basically is a set of
integers in something as simple as an
array and this array as you can see is a
different arrangement from our previous
array in our earlier arrangement index
was representing index of a node in the
graph and value was representing whether
there was a connection to that node or
not here index does not represent
anything and the values are the actual
indices of the nodes to which we are
connected now instead of using an array
here to store this set of integers we
can also use a linked list and widest
array or linked list I would argue that
we can also use a true here in fact a
binary search tree is a good way to
store a set of values there are ways to
keep a binary search tree balanced and
if you always keep a binary search tree
balanced you can perform search
insertion and deletion all three
operations in order of log of number of
nodes we will discus cost of operations
for any of these possible ways in some
time right now all I want to say is that
there are a bunch of ways in which we
can store connections of a node for our
example graph that we started with
instead of an adjacency matrix we can
try to do something like this we are
still storing the same information we
are still saying that zero at node is
connected to one at two it and three at
node 1 at node is connected to 0 at 4th
and 5th node to ethno disconnected to 0
at and sixth node and so on but we are
consuming a lot less memory here
programmatically this adjacency matrix
here
is just a two-dimensional array of size
8 cross 8 so we are consuming 64 units
of space in total but this structure in
right does not have all the rules of
same size how do you think we can create
such a structure programmatically well
it depends in c or c++ if you understand
pointers then we can create an array of
pointers of size 8 and each pointer can
point to a 1 dimensional array of
different size 0 8 pointer can point to
an array of size 3 because 0 8th node
has 3 connections and we need an array
of size 3 one at pointer can point to an
array of size 3 because one it's node
also has 3 connections to it node
however has only 2 connections so 2 its
pointer should point to an array of size
2 and we can go on like this the 7th
node has four connections so 7th pointer
should should point to an array of size
4 if you do not understand any of this
point to think that I am doing right now
you can refer to my code schools lesson
titled pointers and arrays the link to
which you can find in the description of
this video but think about it the basic
idea is that each row can be a
one-dimensional array of different size
and you can implement this with whatever
tools you have in your favorite
programming language now let's quickly
see what are the pros and cons of this
structure in the write in comparison to
the matrix in the left
we are definitely consuming less memory
with the structure in right with
adjacency matrix our space consumption
is proportional to square of number of
vertices while
the second structure space consumption
is proportional to number of edges and
we know that most real-world graphs are
sparse that is the number of edges is
really small in comparison to square of
number of vertices square of number of
vertices is basically total number of
possible edges and for us to reach this
number every node should be connected to
every other node in most graphs a node
is connected to few other nodes and not
all other nodes in the second structure
we are avoiding this typical problem of
too much space consumption in an
adjacency matrix by only keeping the
ones and getting rid of the redundant
zeros here for an undirected graph like
this one we would consume exactly two
into number of edges units of memory and
for a directed graph we would consume
exactly ethat is number of edges units
of memory but all in all space
consumption will be proportional to
number of edges or in other words space
complexity would be Big O of e so the
second structure is definitely better in
terms of space consumption but let's now
also try to compare these two structures
for time cost of operations what do you
think would be the time cost of finding
if two nodes are connected or not we
know that it's constant time or Big O of
1 for an adjacency matrix because if we
know the start and end point we know the
cell in which to look for 0 or 1 but in
the second structure we cannot do this
we will have to scan through a row so if
I ask you something like can you tell me
if there is a connection from node 0 to
7 then you will have to scan this zero
at row you will have to perform a linear
search on this zero eighth row to find
seven right now all the rules in this
structure are sorted you can argue that
I can keep all the rules sorted and then
I can perform a binary search which
would be a lot less costlier that's fine
but if you just perform a linear search
then in worst case we can have exactly V
that is number of vertices cells in a
row so if we perform a linear search in
worst case we will take time
proportional to number of vertices and
of course the time cost would be big-oh
of log V if we would perform a binary
search logarithmic runtimes are really
good but to get this here we always need
to keep our rows sorted keeping an array
always sorted is costly in other ways
and I'll come back to it later for now
let's just say that this would cost us
big o of V now what do you think would
be the time cost of finding all nodes
adjacent to a given node that is finding
all neighbors of a node well even in
case of adjacency matrix we now have to
scan a complete row so it would be Big O
of V for the matrix as well as this
second structure here because here also
in worst case we can have V cells in a
row equivalent to having all ones in a
row in an adjacency matrix when we try
to see the time cost of an operation and
we mostly analyze the worst case so for
this operation we are Big O of V for
both so this is the picture that we are
getting looks like we are saving some
space with the second structure but we
are not saving much on time well I would
still argue that it's not true when we
analyze time
complexity we mostly analyze it for the
worst case but what if we already know
that we are not going to hit the worst
case if we can go back to our previous
assumption that we are dealing with a
sparse graph that we are dealing with a
graph in which a node would be connected
to few other nodes and not all other
nodes then the second structure will
definitely save us time things would
look better once again if we would
analyze them in context of a social
network I'll set some assumptions let's
say we have a billion users in our
social network and the maximum number of
friends that anybody has is 10,000 and
let's also assume computational power of
our machine let's say our machine or
system can scan or read 10 to the power
6 cells in a second and this is a
reasonable assumption because machines
often execute a couple of millions
instructions per second now what would
be the actual cost of finding all nodes
adjacent to a given node in adjacency
matrix well we will have to scan a
complete row in the matrix that would be
10 to the power 9 cells because in a
matrix we would always have cells equal
to number of vertices and if we would
divide this by a million we would get
the time in seconds to scan a row of 10
to the power 9 cells we would take
thousand seconds which is also sixteen
point six six minutes this is
unreasonably high but with the second
structure maximum number of cells in a
row would be 10,000 because the number
of cells would exactly be equal to
number of connections and this is the
maximum number of friends or connections
a person in the network has so here we
would take 10 to the power 4
10 to the power 6 that is 10 to the
power minus 2 seconds which is equal to
10 milliseconds 10 milliseconds is not
unreasonable now let's try to deduce the
cost for the second operation finding if
two nodes are connected or not
in case of adjacency matrix we would
know exactly what cell to read we would
know the memory location of that
specific cell and reading that one cell
would cost us 1 upon 10 to the power 6
seconds which is 1 microsecond in the
second structure we would not know the
exact cell we will have to scan a row so
once again maximum time taken would be
10 milliseconds just like finding
adjacent nodes so now given this
analysis if you would have to design a
social network
what structure would you choose
no-brainer
isn't it machine cannot make a user wait
for 16 minutes would you ever use such a
system milliseconds is fine but minutes
it's just too much so now we know that
for most real-world graphs this second
structure is better because it saves us
space as well as time remember I am
saying most and not all because for this
logic to be true for my reasoning to be
valid graph has to be sparse number of
edges has to be significantly lesser
than square of number of vertices so now
having analyzed space consumption and
time cost of at least two most
frequently performed operations looks
like this second structure would be
better for most graphs well there can be
a bunch of operations in a graph and we
should account for all kind of
operations so before making up my mind I
would analyze cost of few more
operations what if after us two
during this example graph in computer's
memory in any of these structures we
decide to add a new edge let's say we
got a new connection in the graph from A
to G then how do you think we can store
this new information this new edge in
both these structures the idea here is
to assess that once the structures are
created in computer's memory how would
we do if the graph changes how would we
do if a node or edge is inserted or
deleted if a new edge is inserted in
case of an adjacency matrix we just need
to go to a specific cell and flip the
zero at that cell to 1 in this case we
would go to 0-8 row and sixth column and
override it with value 1 and if it was a
deletion then we would go to a specific
cell and make the 1 0 now how about this
second structure how would you do it
here we need to add a 6 in the first row
and if you have followed this series on
data structures then you know that it's
not possible to dynamically increase
size of an existing array this would not
be so straightforward we will have to
create a new array of size 4 for the
zeroth row then we will have to copy
content off the old array write the new
value and then wipe off the old one from
the memory it's tricky implementing a
dynamic or changing list using arrays
this creation of new array and copying
of old data is costly and this is the
precise reason why we often use another
data structure to store dynamic or
changing
and this another data structure is
linked list so why not use a linked list
why can't eat Robi a linked list
something like this logically we still
have a list here but concrete
implementation wise we are no more using
an array that we need to change
dynamically we are using a linked list
it's a lot easier to do insertions and
deletions in a linked list now
programmatically to create this kind of
structure in computer's memory we need
to create a linked list for each node to
store its neighbors so what we can do is
we can create an array of pointers just
like what we had done when we were using
arrays the only difference would be that
this time each of these pointers would
point to head of a linked list that
would be a node I have defined node of a
linked list here node of a linked list
would have two fields one to store data
and another to store address of the next
node a zero would be a pointer to head
our first node of linked list for a a
one would be a pointer to head of linked
list for B and we will go on like a to
foresee a three for D and so on actually
I have drawn the linked lists here in
the left but I have not drawn the array
of pointers let's say this is my array
of pointers now a zero here this one is
a pointer to node and it points to the
head of linked list containing the
neighbors of a let's assume that head of
linked list for a has address 400 so in
a 0 we would have 400 it's really
important to understand what is what
here in this structure this one a zero
is a pointer to node and all up
winter does is store an address or
reference this one is a node and it has
two fields one to store data and another
a pointer to node to store the address
off next node let's assume that the
address of next node in this first
linked list is 450 then we should have
450 here and if the next one is at let's
say 500 then we should have 500 in
address part of the second node the
address and last one would be zero or
null now this kind of structure in which
we store information about neighbors of
a node in a linked list is what we
typically call an adjacency list what I
have here is an adjacency list for an
undirected unweighted graph to store a
weighted graph in an adjacency list I
would have one more field in node to
store weight I have written some random
weights next to the edges in this graph
and to store this extra information I
have added one extra field in node both
in logical structure and the code all
right now finally with this particular
structure that we are calling adjacency
list we should be fine with space
consumption space consumed will be
proportional to number of edges and not
to square of number of vertices most
graphs are sparse and number of edges in
most cases is significantly lesser than
square of number of vertices ideally for
space complexity I should say Big O of
number of edges plus number of vertices
because storing vertices will also
consume some memory but if we can assume
that number of vertices will be
significantly lesser in comparison to
number of edges then we can simply say
Big O of number of edges but it's always
good if we do the
right now for time cost of operations
the argument that we were earlier making
using a sparse graph like social network
is still true adjacency list would
overall be better than adjacency matrix
finally let's come back to the question
how flexible are we with this structure
if we need to add a new connection or
delete an existing connection and is
there any way we can improve upon it
well I leave this for you to think but
I'll give you a hint what if instead of
using a linked list to store information
about all the neighbors we use a binary
search tree do you think we would do
better for some of these operations I
think we would do better because the
time cost for searching inserting and
deleting a neighbor would reduce with
this part I'll sign off this is it for
this lesson thanks for watching
so now I get to tell you about the very
cool randomized contraction algorithm
for computing the minimum cut of a graph
let's just recall what the minimum cut
problem is we're given as input an
undirected graph and parallel edges are
allowed and in fact they will arise
naturally throughout the course of the
algorithm that is for a given pair of
vertices we allow multiple edges to have
that pair as influenced now I do sort of
assume you've watched the other video
and how graphs are actually represented
although that's not gonna play a major
role in the description of this
particular algorithm and again the goal
is to compute the cut so a cut is a
partition of the graph vertices into two
groups a and B the number of edges
crossing the cut is simply those that
have one endpoint on each side and
amongst all of the exponentially
possible cuts we want to identify one
that has the fewest number of crossing
edges for a min cuts so here's the
random contraction algorithm so this
algorithm was devised by David Carter
back when he was an early PhD student
here at Stanford and this was in the
early 90s so like I said quote-unquote
only about 20 years ago and the basic
idea is to use random sampling now we've
known forever right ever ever since
quicksort that random sampling could be
a good idea in certain context and
particularly when doing sorting and
searching and one of the things that was
such a breakthrough about Carter's
contraction algorithm as it showed that
random sampling could be extremely
effective for fundamental graph problems
so here's how it works we're just gonna
have one main loop each iteration of
this while loop is going to decrease the
number of vertices in the graph by one
and we're going to terminate when we get
down to just two vertices remaining now
in a given iteration here's the random
sampling amongst all of the edges that
remain in the graph to this point we're
going to choose one of those edges
uniformly at random each edge is equally
likely once you've chosen an edge that's
when we do the contraction so we take
the two endpoints of the edge call them
the vertex U and the vertex V and we
fuse them into a single vertex that
represents both of them this may become
more clear when I go through a couple
examples on the next couple of slides
this merging may creates parallel edges
even if you didn't have them before
that's okay we're going to leave the
parallel edges and it may create a
self-loop edge we're now both of the
endpoints is the same and self loops are
stupid so we're just going to
leet them as they arise each iteration
decreases the number of vertices that
remain we start with n vertices we end
up with 2 so after n minus 2 iterations
that's when we stop and at that point we
return the cuts represented by those two
final vertices you might well be
wondering what I mean by the cut
represented by the final two vertices
but I think that will become clear the
examples which I'll proceed to now so
suppose the input graph is the following
four node five edge graph there's a
square plus one diagonal so how would
the contraction algorithm work on this
graph well of course it's a randomized
algorithm so it would work in different
ways and so we're gonna look at two
different trajectories and the first
iteration each of these five edges is
equally likely each is chosen for
contraction with 20% probability for a
concluding that's let's say that the
algorithm happens to choose this edge to
contract to fuse the two endpoints after
the fusion these two vertices on the
Left have become one whereas the two
vertices on the right are still hanging
around like they always were so the edge
between the two original vertices is
unchanged the contracted edge between
the two vertices on the Left has gotten
sucked up so that's gone and so what
remains are these two edges here the
edge on top and the diagonal and those
are now parallel edges between the fused
node and the upper right node and then I
also shouldn't forget the bottom edge
which is edge from the lower right node
to the super node so that's what we mean
by taking a pair of vertices and
contracting above the edge that was
previously connecting them vanishes and
then all the other edges just get pulled
into the fusion so that's the first
iteration of cargas algorithm or one
possible execution so now I proceed to
the second iteration of the contraction
algorithm and the same thing happens all
over again we pick an edge uniformly at
random now there's only four edges that
remain each of which is equally likely
to be chosen so with 25% probability for
concreteness let's say that in the
second iteration we wind up choosing one
of the two parallel edges say this one
here so what happens well now instead of
three vertices we go
- - we have the original bottom right
vertex that hasn't participated in any
contractions at all so that's as it was
and then we have the second vertex which
actually represents the fusion of all of
the other three vertices so two of them
were fused the left must versus refused
in iteration one and now the upper right
vertex got fused in with them to create
this super node representing three
original vertices so what happens to the
four edges well the contracted one
disappears that just gets sucked into
the super node and we never see it again
and then the other three go in where
this would go it is supposed to go
so there's the edge that used to be the
rightmost edge that has no hash mark
there's the edge with two hash marks
that goes between the same team knows
that it did before just the super node
is now an even bigger node representing
three nodes and then the edge which was
parallel to the one that we contracted
the other one with a hash mark becomes a
self-loop and remember what the
algorithm does is once ever self loops
like this appear they get deleted
automatically and now that we've done
our n minus two iterations we're not
just two nodes we returned the
corresponding cut by corresponding cut
what I mean is one group of the cut is
the vertices that got fused into each
other and wound up corresponding to the
super node in this case everything but
the bottom-right node and then the other
group is the original nodes
corresponding to the other super node of
the contracted graph so which in this
case is just the bottom-right node by
itself so they said a is going to be
these three nodes here which all got
fused into each other contracted and to
each other and B is going to be this
node over here which never participated
in any contractions at all and what's
cool is you'll notice this doesn't facts
define a min cut there are two edges
crossing this cut this one the rightmost
one on the bottom most one and I'll
leave it for you to check that there is
no cut in this graph with fewer than two
crossing edges so this is in fact I mean
cuts
of course this is a randomized algorithm
and randomized algorithms can behave
differently on different executions so
let's look at a second possible
execution of the contraction algorithm
on this exact same input let's even
suppose the first iteration goes about
in exactly the same way so in particular
this leftmost edge is going to get
chosen in the first iteration but
instead of choosing one of the two
parallel edges let's suppose that we
choose the rightmost edge to contract in
the second iteration totally possible
25% chance that's going to happen now
what happens after the contraction well
again we're going to be left with two
nodes no surprise there the contracted
node gets sucked into oblivion and
vanishes but the other three edges the
ones with the hash marks all stick
around and become parallel edges between
these two final nodes this again
corresponds to a cut a and B where a is
the left two vertices and B is the right
two vertices now this cut you'll notice
has three crossing edges and we've
already seen that there is a cut with
two crossing edges therefore this is not
I mean cuts so what have we learned
we've learned that the contraction
algorithm sometimes identifies the min
cut and sometimes it does not it depends
on the random choices that it makes
depends on which right edges it chooses
to randomly contract so the obvious
question is you know is this a useful
algorithm so in particular what is the
probability that it gets the right
answer and then we know it's bigger than
zero and we know it's less than one is
it close to one or is it close to zero
so we find ourselves in a familiar
position we have what seems like a quite
sweet algorithm this random contraction
algorithm and we don't really know if
it's good or not we don't really know
how often it works and we need to do a
little bit of math to answer that
question so in particular we'll need
some conditional probability so for
those of you who need a refresher you
would go to your favorite source or you
can watch the probability review part
two to get a refresher on conditional
probability and independence once you
have that in your mathematical toolbox
we'll be able to totally it nail this
question get a very precise answer to
exactly how frequently you
action algorithm successfully computes
the minimum cut
hello friends in this lecture we will
look at graph representation using
adjacency lists and we will use C++
STL's to do accomplish this task so we
will just look at a very simple graph
here
and let's see that this one is the graph
0 1 2 3 so we have 4 nodes in our graph
and this is how they are connected with
the edges so now what we want is we want
the adjacency list representation and
what does adjacency list do is that for
each node the case of we have node 0
node 1 node 2 and node 3 ok so we have
these in a vector okay so we have them
like this so this is a vector where we
store all the nodes and we also have
what is known as a list for all these
nodes okay
so node 0 it is connected to node 1 2
okay so we will have here node 1 and
node 2 ok so these are the nodes that
are connected to node 0 then for node 1
we again see 0 and 2 are the nodes that
are connected to node 1 for node 2 we
see that node 0 node 1 and node 3 are
connected and for node 3 it's just
connected to node 2 so this is the
adjacency list representation and what
happens is that it saves storage for us
okay it saves memory and how because
each now if there are mod e number of
edges so all these nodes just we have
the list of nodes for each node which
are connected to it ok so this
is the basic idea but here the important
another important thing is how to
represent it in C++ so in C++ our most
important thing that we need to know is
that we have what we have set of nodes
okay our set of vertices and each
vertices each vertex is connected to a
set of other nodes through edges okay
and this is what we have to represent so
how we do that thing so we will use what
is known as so a vector we will use for
all the nodes we have vector where we
will store all the nodes but each node
now has a list so we have vector or a
list of int okay so this is what we will
have so if you see here so we have and
if there are n nodes okay so what it
becomes is that we have a vector of list
of nodes okay and which we will call it
adjacency list and what happens in the
vector you have each node okay and in
each node you have a list which tells
you that which other nodes it that
particular node is connected to so now
we will look at the C++ code that
implements this graph representation
using adjacency matrix so of course the
first most important thing here is so we
are using STL where we use vector and
list okay so these are the two
representations the data structures that
we use and the most important thing is
here so this piece of code so standard
vectors we have a vector of what the
vector is also upset basically indexed
set and in that what we have in each
vector item we have a list okay so we
have a list
of all the nodes it is connected to so
this is the basic idea and now what
happens let's see how we have done so we
have a simple graph here and what that
graph looks like is we have four nodes
okay so 0 1 2 &amp; 3 and let's see how are
they connected so we do because this is
a vector so it is like an array very
much similar to an array where we can
indexed items we can use to adjacency
list 0 that is the first node dot push
back 1 ok so now let's try to see this
thing so when we do adjacency list 0 dot
push back 1 it means that our graph is
basically 0 is connected to 1 so let us
first draw the graph then 1 is connected
to 2 and 0 2 is connected to 0 1 and 3
so this is our graph and now let's look
so this is an unweighted graph so and
what happens and undirected ok so here
what happens is this is adjacency list 0
means the node 0 and when we do dot push
backs of this item adjacent see list 0
this represents in list ok list and a
list for basically or you should remove
list for node 0 similarly adjacency list
1 is the list of nodes that are
connected to 1 so this is basically of
type standard list ok this is the type
of the adjacency list I now what happens
is so we have a if napi okay push
underscore
back where we just pushed the note
number which it is connected to so
adjacency list 0 dot push back 1
adjacency list 0 dot push back to so we
push in this creates for us now we have
here 1 &amp; 2 similarly what happens
adjacency list 1 so for node 1 the
vector and this is the list so we have 2
and 0 here for - we have a list 0 1 &amp; 3
so this is the list and for 3 we have
just got two so this is the your
adjacent see list and your graph is here
and this is how you create the graph
okay now the thing is we want to print
the graph okay how the nodes are
connected and so on and which is a
little bit complicated because of STL
that we are using and in fact STL makes
your life very simple because you don't
need to have your linked list maintain
your own linked list it's and resize
everything will be done by your vector
and list STL classes okay so this is the
part where we construct our graph now we
would look at how we Traverse so how we
will Traverse so let's see so for
traversing we have this piece of code
okay and let's try to see how it is done
so we have what we have one is vector so
if let's say I want to print for all the
vertices I want to print their neighbors
so first thing is I need a kind of for
loop which will iterate through all the
nodes so for all the nodes and a nested
for again for
each of its neighbor so print their name
so these are the two things that you
need to do so how we do so there is a
concept of iterator in C++ STL where
what happens when we want to I trait
through some STL class so if we have a
vector so we are making a vector I
traitor so you need to have the same
kind of hydrator through the type of
class you want to I take I trait through
so we have standard vector and that
vector is of what so it consists of
vector of standard list of ends so it's
I traitor by scope resolution I gave I
traitor I we have a see count is zero
initially we start so standard vector
standard list int i traitor i so i
traitor now it starts at adjacency list
dot begin and till it goes till
adjacency list dot end and i plus plus
happens okay so what happens it's just
like a for loop okay where i is equal to
0 to some maximum size so here we are
going because we don't know the size of
the the list or the vector so we keep on
iterating and this adjacency list dot
begins show me the beginning of the
vector and adjacency list dot n j--
shows me the end of the vector okay so i
is your eye traitor that is ight rating
through your vector of 0 1 2 3 those
objects so this is the vertical i
traitor i am going through
i but each time i also need to traverse
the list for each of the nodes ok so
this is again one i traitor so when i am
traversing here so this vector gives me
what inside the each vector object there
is a list of int okay and that list of
int vivant so what happens so we do
so in this a traitor I we will always
have a pointer to the list
okay so standard list of int okay so we
have in star I we get the list so let's
see so we have now the pointer to the
list for that particular vector item so
for standard list I traitor ITER Li dot
begin I traitor so now we are iterating
through this list using this for loop so
a standard list int so we have no I
traitor of type list of integers
it starts with Li dot begin so this is
the from here we take for this first
node what is the list I get from here
get the list for this node so we get it
here Li dot big ni traitor is not equal
to Li dot n plus plus ITER we do and we
what we do print the neighbors okay we
print which are the neighbors of this
particular node so what is has connected
to node C which is here and then we just
give one end line and C++ so that we are
printing the nodes okay which we are
traversing so this is the simple idea
where we are creating up for undirected
graph and with novated edges so this is
how we represent it using a vector of
list of int okay so the main thing is
how you implement this the concept of
adjacency list is simple but how you
implement using STL is a bit tricky and
I hope you understand this now so thanks
a lot
okay so one thing I forgot is that I
need to show you that it runs really
okay so that is important which I did
not do so let's try to see so vertices
connected to node 0 or 1 &amp; 2 vertices
connected to node 1 or 2 and 0 vertices
connected to node 2 are 0 1 &amp; 3 vertices
connected to node 3 are 2 just one node
that it is connected to so this brings
for us that how wonderfully in a compact
way we are representing a graph using
adjacency lists okay
so I hope you understand this thanks a
lot
the graph data structure is not the same
as a graph you may have learned about a
math class graphs are collections of
things and the relationships or
connections between them the data in a
graph are called nodes or vertices the
connections between the nodes are called
edges one example of graphs is a social
network where the nodes are you and
other people and the edges are whether
two people are friend with each other
there are two major types of graphs
directed and undirected undirected
graphs are graphs without any direction
on the edges between nodes directed
graphs are graphs with a direction and
its edges an example of an undirected
graph could be a social network the
nodes are people and the edges are
friendships an example of a directed
graph could be the internet and web page
links the nodes are web pages and the
directed edges are links to other pages
which might not necessarily point the
other way I'm going to show you three
ways to represent a graph the first way
is called an adjacency list this
representation for a graph associates
each vertex in the graph with the
collection of its neighboring vertices
or edges in this image a is connected to
B B is connected to a and C and C is
connected to B this is how you could
show a relationship with texts and here
is how you could show this adjacency
list with JavaScript this is an
undirected graph because it does not
show the direction of the edges this can
also be more simply represented as an
array where the nodes just have numbers
rather than string labels another way to
represent a graph is to put it in an
adjacency matrix an adjacency matrix is
a two-dimensional array where each
nested array has the same number of
elements as the outer array so it's
basically a matrix of numbers where the
numbers represent the edges zeroes means
there is no edge or relationship and one
means there is a relationship this table
shows an adjacency matrix to represent
the image you can see that the labels
for the nodes are on the top and left
now here's a JavaScript representation
of the same thing unlike an adjacency
list each row of the matrix has to have
the same number of elements as nodes in
the graph here we have a 3 by 3 matrix
which means we have 3 nodes our graph
and adjacency matrix can be used to
represent a directed graph here's a
graph where the second node has an edge
pointing toward the first node and then
the third node has an edge pointing to
the first node notice how the numbers in
the array change there are only ones
where a node is pointing toward another
node and since there are only two points
there are only two nodes the final way I
will show to represent a graph is an
incidence matrix like the adjacency
matrix and incidence matrix is a
two-dimensional array however the rows
and columns means something else here
the adjacency matrix use both rows and
columns to represent nodes and incidence
matrix uses roads rose to represent
nodes and the columns to represent edges
this means that we can have an uneven
number of rows and columns each column
will represent a unique edge also each
edge connects two nodes to show that
there is edge between two nodes you will
put a 1 in the two rows of a particular
column as you can see in the diagram
edge 1 is connected to nodes a and B now
look at the column for edge 1 in the
incidence matrix table you will see a 1
in both the a row and the B row this
shows the edge 1 connects the nodes a
and B here is a directed graph for a
directed graph use negative 1 for an
edge leaving a particular node and 1 for
an edge entering a node and here is a
JavaScript implementation of the
incidence matrix graphs can also have
weights on their edges so far we have
unweighted edges where just the presence
and lack
of edges binary zero one you can have
different weights depending on your
application a different way is
represented as a number greater than one
well now you know about different types
of graphs and how to represent them in
JavaScript in my next video about graphs
I will cover graph traversal algorithms
thanks for watching my name is Bo Carnes
don't forget to subscribe and remember
use your code for good
[Applause]
hello friends welcome back in this
tutorial we will learn how we can
represent a graph by at the sensi list
so in this tutorial we will study about
representation of a graph by adjacency
list in adjacency list representation of
a graph a graph with n vertices is
represented using an array of and lists
at lists of this array contains all
vertices which are adjacent to what X I
right now consider this undirected graph
right now we have to represent this
graph by adjacent see list
representation right
since this graph has only five vertices
so in adjacency list representation this
graph will be represented by an array of
five lists right now let this graph is
represented by an a/d e right so size of
array e will be five right now consider
the vertex one of this graph right what
this is 2 &amp; 5 are adjacent to vertex 1
so a 1 right that is first element of
array e represents the linked list of
vertices I've just set to vertex 1 right
so this linked list will contain the
vertices 2 and 5 now see the vertex 2 of
this graph vertices 3 4 5 &amp; 1
right are at the sent to vertex 2 right
so a 2 that is second element of array a
represents the linked list of vertices
HSN to vertex 2 and this length list
will contain the vertices three four
five and one right now see this what x3
right vertices two and four are adjacent
to what x3 right
so a three that is third element of
array II represents the length list of
vertices answer sent to Fort x3 right so
this length list will contain the
vertices two and four right now see the
vertex four offer this graph right
vertices 2 3 &amp; 5 are adjacent to vertex
4 so people that is fourth element of
array a represents the length list of
vertices which are adjacent to vertex 4
right so this length list contain the
vertices 2 3 &amp; 5 right now see this
vertex v of this graph what is this 1 2
&amp; 4 are adjacent to what X 5 in this
graph right so if I that is 5th element
of array a represents the length list of
vertices which are adjacent to what X 5
so this length list contains the
vertices 1 2 &amp; 4 but so this was the
adjacency list representation of an
undirected graph now let us discuss the
adjacency list representation of a
directed graph right so now we will see
the adjacency list representation of
this graph right we will see the
adjacency list representation of this
graph right this graph has four vertices
so an adjacent see list representation
of this graph
we will use an array of four lists but
so an adjacency list representation this
graph will be represented by an array of
full lists right slut this graph is
represented by re e right so size of
this array e will be 4 right now see
vertex form or for this graph right what
X 2 is adjacent to vertex 1 right so
even that is first element of array e
represents a linked list which contains
the vertices which are adjacent to
vertex 1 so this linked list will
contain vertex 2 only because only
vertex 2 is adjacent to what X 1 now see
this vertex to vertex 3 is adjacent to
vertex 2 right so it will that is second
element of array e represent a linked
list which contains the vertices which
are adjacent to vertex 2 so this linked
list contains only vertex 3 now see
vertex 3 right what X 4 is adjacent to
vertex 3 so a 3 that is third element of
array a represents the linked list of
vertices which are adjacent to vertex 3
right so this linked list contains only
vertex 4 because so only vertex 4 is
adjacent to vertex 3 now see the vertex
now see this vertex for what X 1 and 2
are adjacent to what X 4 right in this
graph vertex 1 and 20 X 2 are adjacent
to vertex 4 in so
a four that is the fourth element of
array a represents a linked list of
vertices which are adjacent to vertex
four right so this linked list contains
the vertices 1 and 4 right so in this
way we can represent Accra by at this
cell see list
hi this is sesh we're on again for
another lesson in data structures and
algorithms in this lesson we're going to
see how we can efficiently store graphs
using what's called the adjacency linked
list scheme this is a follow-up to a
previous video that described the
adjacency matrix storage structure for
graphs if you didn't see that yet you
probably want to do it now before
continuing with this lesson the title of
that video is graphs types and
representation here is a sample
friendship / Facebook graph I used in
the earlier video what storage for the
vertex names in an array and storage for
the edges in the adjacency matrix where
the truth stand for the edges between
the vertices the problem is that there
are too few truths relative to the total
amount of space used by the matrix the
space utilization is only 8% in case you
jump right in and I'm wondering why it's
8% instead of 16% it's because half the
true values are really redundant since
the matrix is symmetric about the main
diagonal it is sufficient to look only
at the upper triangle or the lower
triangle so effectively we only need
half of the 16 true values it's pretty
clear that we need a much more space
efficient alternative than the adjacency
matrix and the clue to what that might
be is in the empty or false valued cells
in the matrix we don't need these cells
because they don't tell us anything
about the graph we don't already know
from the true values so really this is
what we want now that the cells and the
rows are not contiguous anymore we need
to stitch them together the numbers at
the top can function as column indices
since there isn't an array anymore but
we can get rid of them because they are
vertex numbers so we can bring them down
to replace the truth
next let's bring in the vertex names
array into the picture then we can get
the
row and column indices out of the
picture and have the Rowling's
originated from an additional field in
each of the vertex array cells it is
apparent now that we have linked lists
for each vertex holding the numbers of
all the vertices that are adjacent to it
for instance in the very first row for
Sara the vertex number is the linked
list 1 and 3 are those for Sam and AJ
which are adjacent to Sara in the graph
observe that again as in the adjacency
matrix each edge appears twice take the
edge between Sam and Mira
for example the vertex numbers for Sam
and Mira are 1 and 4 respectively
so 4 appears in one's linked list and 1
appears in forest linked list let's
clean up the pictures so the linked
lists look more like what we're used to
seeing this is the standard adjacency
linked list story scheme each vertex
stores a linked list of vertices
adjacent to it resulting in an array of
linked lists
notice that the neighbors of a vertex
appear in increasing vertex number order
in the lists but that's not a
requirement neighbors can appear in any
order the adjacency link lists
data structure can be coded like this
the neighbor class implements the linked
list nodes the vertex class gathers
together the vertex name and the pointer
to the first node in its adjacency
linked list and lastly the adj lists
variable is the array of vertex objects
which is the collection of names and
addition see linked lists of all the
vertices since each edge appears twice
the space needed for all the adjacency
link lists is twice the number of edges
times the space for a linked list node
now each linked list node has two fields
so let's say this is to you mister space
this is in contrast the single unit of
space for each cell of the matrix
in addition there are as many units of
pointer space in the vertex array as
other vertices so leaving aside the
space for the names of vertices which is
the same for the matrix as well for this
example the number of units of space for
the adjacency linked lists is 8 edges
times two notes per edge times 2 units
per node plus 10 units for the vertices
which adds up to 42 units of space and
all compare this with the space of the
matrix which is 10 times 10 or 100 units
in general if the number of vertices is
N and the number of edges is e then for
an undirected graph the space usage for
the adjacency linked lists is n plus e
times 2 times 2 or n plus 4 times e
while that for the matrix is N squared
for comparison here are the adjacency
link lists for the website graph without
edge weights since this is a directed
graph each edge contributes only one
link list node for a space usage of 8
edges times 2 units per node plus 6
units for the vertices adding up to 22
units while the matrix uses up 6 squared
or 36 units
if the graph is weighted then in
addition to the vertex number of the
neighbor the weight of the connecting
edge must be stored as well here is the
storage for the weighted version of the
website graph with the linked list nodes
modified to hold edge weights the
original data structure code can be
modified to include edge weights by just
changing the neighbor class like this
the space utilization now increases by
eight units one unit per edge for the
weight field for a new total of 22 plus
eight or 30 while the matrix is still 36
units because the same array cells now
hold weight numbers or negative ones
instead of boolean's here's a table that
compares the space requirement for the
linked list storage and the matrix for
the four kinds of graphs we are studying
the size of the graphs are generalized
to n vertices and E edges Spacek part of
the matrix is unchanging and only
depends on the number of vertices not on
the edges space acquired for the link
lists varies according to whether the
graph is undirected or directed whether
it has weights and how many edges that
are in the graph just around the soft
with a realistic example suppose we had
a weighted undirected graph with 10,000
vertices say on average each vertex has
100 connections to other vertices 10,000
times 100 is 1 million but remember that
each connection is counted twice so the
number of edges is half 1 million which
is 500,000 edges each edge node would
have 3 fields for the vertex number 2
the edge weight and the next node and
each edge would be represented twice so
two nodes / which means 6 units per edge
so the total space used would be 10,000
plus 500,000 times 6
which is over three million units of
space while the matrix would use up ten
thousand squared or 100 million units of
space to compare the linkless scheme
needs only three percent of the space
that is needed by the matrix okay let's
pull together everything we've learned
so far about the different kinds of
graphs and the adjacency linked list
storage into a simple program this
program will read an undirected
unweighted graph from a text file and
populate the adjacency linked lists here
we are in Eclipse the program is in a
file called graph the Java in a package
called graphs we call the data structure
definition for the adjacency link lists
that we saw earlier for the friendship
graph that's pretty much copied as is
here right before the graph class itself
the graph class starts out by defining a
field called adj lists or edge lists for
the array of adjacency link lists the
constructor does all the heavy lifting
reading the graph from a file whose name
is passed as a parameter in two edge
lists let's take a look at the graph
file friendship dot txt here so we can
get acquainted with the input format
there isn't a standard format that
everyone uses but this one works pretty
well the first line has the number of
vertices in the graph which is 10 in
this gray case the following ten lines
lists the vertex names one per line
subsequently each line lists one edge by
writing out the two end point vertices
alright back in the graph class the
construction starts by reading by
setting up a scanner to read from the
graph file the first line of the file
gives the number of vertices which is
used as the length of the adjacency
linked lists array which is created the
vertex names are then read in this for
loop one at a time each time a vertex
object is created with the name and null
for the neighbor list just to refresh
our memory
here's the word vertex class again okay
time to read the edges this is a little
more involved there are two vertex names
on each line but in order to add each to
the linked list of the other we need to
know the corresponding vertex numbers
this functionality is implemented in the
index for name method which cancer
vertex objects in the edge lists array
comparing the name field of the object
against the target name if a match is
found it returns the current index in
the array outside the loop which means a
match was not found it returns negative
one this should not happen if the graph
file has correct data back in the code
where the edges are being read
after getting the vertex numbers v1 and
v2 for the two end point where disease
v2 is added as a neighbor to the front
of v1 slist and v1 to v2 s list two
nodes for the same edge since the graph
is undirected recall that neighbor is a
linked list node
with vertex number and next fields since
the neighbors don't need to be in any
particular order it is fastest to keep
adding to the front of the lists that's
it for the constructor to make sure we
have read and store the graph correctly
there is a print method we can use that
runs through the edge lists array and
for each vertex prints its name and the
list of all its neighbors okay
let's run the program to make sure it
works as advertised
although the main method does is to ask
and get a file name create a graph
object by passing the file name to the
constructor which will end up populating
the adjacency link lists and then print
the graph so here goes let's run this on
our friendship graph let's stretch the
view to get everything in one go you can
verify that the output matches the
picture of the friendship graph now you
might be thinking what if the graph is
directed all the same code with just one
small change can handle the writer
graphs as well so take for example the
website graph without edge weights every
edge only goes one way from the first
vertex to the second vertex so when the
graph is read going back to the
constructor here
vitu should be added to V ones list but
not the other way so all we need to do
is to comment out the second line save
it and we can run it on the website
graph now to make sure it works
correctly so website dot txt again let's
just increase the view and there you go
now this is good but we can go even one
better the way it works now we need to
change the code every time we switch
between directed and undirected graphs
but if we change the graph format to
include a line up front as to whether
the graph is directed or undirected then
we can read that line in and use that
information to act accordingly so let's
go ahead and go to the website graph
file and add a line up front says
directed and save this and likewise for
friendship txt up before the number of
vertices will add a line that says
undirected now in the graph class
constructor just before we read the
vertices we're going to add the
statement string graph type is scanner
next and what we'll do is set up a
variable a boolean variable called
undirected initialize to true and if
graph type equals directed then we can
change that variable to false
and here instead of commenting this line
we'll make it conditional on the graph
being undirected
so if undirected then do this
okay now let's run our program for both
kinds of graphs and if yours website dot
txt well that doesn't look good and I
think I know what I did here we actually
read the first line right up here so I
need to move this before that statement
so the very first read will be the graph
type and then we get the next int and
then we can do the rest of the stuff
okay let's do this again run the program
website txt looking good let's do it for
friendship XD and that looks good as
well
okay that's about it for graph
representation and storage in summary
adjacency linked lists is the way to go
except for a few niche applications
where the matrix might be better see you
later
okay let's talk about graph
representation before we can talk about
exploring and graph we need to know what
we're given as input and there's
basically one standard representation
and a bunch of variations of it and
they're called adjacency lists so the
idea with an adjacency list is you have
an array called a DJ for adjacency of
size v each element in the array is a
pointer to a linked list and the idea is
that this array is indexed by a vertex
so we're imagining a world where we can
index array is by vertices so maybe you
just label your vertices 0 through V
minus 1 then that's regular array or if
you want to get fancy you can think of a
vertex as an arbitrary hashable thing
and a DJ is actually a hash table and
that's how you probably do it in Python
maybe your vertices are objects and this
is just hashing based on the address the
object but we're not going to worry
about that just going to write a DJ if
you assume that somehow you can get the
linked list corresponding with that
vertex
and the idea is for every vertex we just
store its neighbors namely the vertices
you could reach by one step from you so
i'm going to define that a little more
formally adj of you is going to be the
set of all vertices V such that UV is an
edge okay so if you have a vertex
where's where my graphs here so if I
have a vertex like be a j.o.b is going
to be both a and C because in one step
there are outgoing edges from B to a and
B to C so a DJ abhi is AC right then in
that graph should label diversity
something different adj of a is going to
be just see because you can't get from
one with one step from A to B there's a
the edges in the wrong direction okay an
Ag JFC is be okay I think that
definition is pretty clear for
undirected graphs you just put braces
here which means you store I mean the
same thing for here adj of c is going to
be a B and D as you can get in one step
from C to a from C to B from C to D this
for pretty much every at least for graph
exploration problems this is the
representation you want because you're
at some vertex you want to know where
can I go next an adj of that vertex
tells you exactly where you can go next
so this is what you want
sighs welcome to this tutorial and this
video is about graphs and its
representation using edges in G lists
let's quickly have a look what a graph
is really is so graph is basically a
collection of nodes and edges between
those nodes so zero connects to one one
connects to two and three and four zero
connects to four fourth and X to 0 1 and
three graphs could be of two types one
is the undirected graph and one is the
director graph that undirected graph
basically means if one to two is the
neighbor then to the one is also enable
directed graphs on the other hand if one
to do is a neighbor two to one is not
enabled so if two to one had had been a
neighbor then there would have been an
arrow pointing from two to one now that
we know what a graph basically is we can
get to putting this in Eclipse we
quickly over hand create a new Java
project
let's call this graph wait for it to
build path let Kelso's create a new
class and we call this graph graph hsn.c
list pretty cool name big one though
okay first let's import java.util u2
tour so then we create a private
instance of a map at a list and list and
in teacher so this air LS it should be
array list it's provided was by Java dot
util and it lists and let's call this
adjacency list map
alright now we create the constructor
for this class it's called public graph
HSMC
list and it will take an input and
square this is so we give an input as
the number of vertices then we create
and a big off with those vertices and
edges and see list map is basically a
new hash map which will take input as an
integer and then add a list of type
integer so it should be captive I okay
then we say for the number of vertices
start the user input we create an empty
graph with it so and I equals 1 I less
than equal to the number of vertices I
plus plus we create an array list of
integers in teacher and let us call this
as neighbors this will be a new
ArrayList of integer
Edge's until s map is now we just put
four ayat element we put in the
neighbors so what we just did was for
supports a node zero we created an
ArrayList which will which we are
calling as neighbors so for zero there's
a list for one this list for two and so
on for the number of what it is that the
user input we have created an empty list
of neighbors now we basically need a
function to add n8 so let's call this
public void add edge and this will take
as input the voltage and the neighbors
that we want to add the neighboring word
is that we want to add first we check if
the world is start with input that the
user input is actually a part of the
nodes that we initially defined so
suppose our graph is for node 0 1 &amp; 2
but the user wants to access the node
say 7 so that is not in the range in the
scope and so we need to check that case
and W belongs is greater than adjacency
list list map node size then we simply
return so this should be W create a pan
ok and if that is not the case then we
use the inbuilt function it's in C list
map dot get B first get the word test V
and then we basically add W as its
neighbor we should put brackets over
here to make clear
we get the list but we get vertex we and
then we add W as its neighbor so this if
we add only this line that means that
graph we are talking about is an
undirected graph is a directed graph
sorry and if we add this line as well
adjacent c-list map dot get W and then
dot add we so now the graph we're
talking about becomes an undirected
graph so what we basically mean over
here is that we get V and add W of its
neighbor and then we get W and add V as
its neighbor okay
now we need to add neighbors as well so
we create a new function which we call
as let's call it get neighbors so this
function basically returns us the list
of neighbors to a particular node that
they input
okay so what seems to be there okay so
okay let's say let's again check our
base case which is if we is actually a
part of a cross
in this case we simply return a null as
we return an ArrayList of integer should
be capital I of individual which will be
agency list math dot get we so this
returns us the list of neighbors to the
vertex we all right now we write down
the main code public static void main
string argument let's create an integer
and count and get initiated to one and
then we need the source vertex and we
need a destination vertex then we can
create a line on that synthesis enter
the number of vertices and edges
and we use scanner to get the input and
we call some dot n then we create a new
variable let's call it number of
vertices number of vertices and we take
input from the user
next int then we take input as the
number of edges and we take input again
from the user extent okay now what we
need we create a new we need to enter
semicolon over here then we take we
create a new instance of the class graph
adjacency list it sealers and let's call
this adjacency list new graph hsn.c it
sends C in C list and the input will be
the number of vertices that we just took
input from the user seems fine till now
then we need the user to enter the edges
so like zero to one is an edge we need
the user to develop start so again we
tell the user one here we told a friend
in line
say enter edges in format source space
edge toast space destination alright now
we create a loop and we say while count
is less than equal to number of edges we
just simply take input source is scan
dot next int destination is scan dot mix
end and we add the edge edge SNC list
dot add edge between source and
destination and we done and now we just
increment count consciousness okay now
let's tell the user that the given
adjacency list for the graph and then
[Music]
let's give a line after this and then we
simply create an Impala we say int I
equals 1 I less than equal to the number
of vertices i plus plus system dot out
dot print print how do we print so
there's a node followed by the neighbors
so let's do it like this I and then you
say plus followed by an arrow this
should be double bracket okay now let's
say let's create an array list of type
which is integer let's call it edge list
jason see list dot should be a jason
seed yes so we're talking about this
edges in serious adjacency list or gate
neighbors so we created get neighbors
function over here now we're just using
it to get the list of neighbors and the
input to this will be our vertex I and
now we simply need to print this in J
equals 1 semicolon semicolon j + s we do
this ok now we say if J not equals edge
list dot size
then we output turns out dot print edge
list dot get J minus one plus again we
give an air over here else let's do this
system dot out dot print edge list H
list dot get J minus one and and then
break so this this statement is just to
take whether the node whether the
neighbor we are talking about it's the
last neighbor or it's an end with me
neighbor so if it's the last neighbor
then we simply do this if it's not the
last neighbor then we do this because we
want to keep like putting arrows after
each neighbor so let's just give this
space over here like this okay seems
pretty nice till now now just give a new
line over here system dot out dot print
line just to make it look up a little
better think we done over here we can
run this enter the number of vertices
and edges so number of vertices is say
four and edges are five five and of the
edges in format source and destination
so we say one
has an edge with to one has an edge with
three to as an edge with or with three
and let's say one is an edge with four
and one okay - as an edge with four
pretty cool so one as neighbors two
three and four to have neighbors one
three and four three has neighbors one
and two and four s neighbors one and two
seems to be working fine
hey guys welcome to this video in this
video we are coding agency lists and
Python very quickly let's look at the
path that we want to plot so we got six
vertices 0 1 2 3 4 5 0 if connected to
neighbor as 1 &amp; 2 2 is connected to
neighbor 4 1 is connected to 2 &amp; 3 and
so on so we can actually use 2 ways to
implement this infighting so the first
way for list of list methods so what we
want to do is we want to create a list
let's call it edge until this and this
will basically be a list of list
so the 0th index will contain all the
neighbors of vertex 0 so we got 1 &amp; 2 1
&amp; 2 so we done we just implemented the
neighbors of vertex 0 now we want to put
in the neighbors of vertex 1 which are 2
&amp; 3 so we create another list we say 2 &amp;
3 and similarly the neighbor 4 3 which
is 4 neighbor 4 2 which is 4 then
neighbor 4 3 is 4 &amp; 5 and the neighbor 4
5 so this would be 5 and then we or non
point 5 so this will be an empty list
all right so we just specified what are
the neighbors of each vertex 1 &amp; 2 for
vertex 0 2 &amp; 3 for vertex 1 and so on
now we we just created the structure we
can simply loop through the structure
and print the neighbors of each so what
we'll say is we created on your variable
n which is basically the length of this
so edges until s and now we want to
implement a for loop and we say for we
end range the 0 to n 0 comma N and
now we just want a friend so friend and
this should be V space in and we want to
print and we should give a space between
this and then we say HSN seal is base we
actually let's do it do it like this so
this should be a space okay so let me
open the terminal and try to run this is
a item which is in say list or py okay
very neat
so one into neighbors of zero two and
three neighbors of one and so on so this
was a list of lists method the other
method that we want to use the
dictionary method so let me write down
dictionary okay so what we want to do is
a dictionary will basically cut there a
contain a pair of vertex and list so
great a dictionary let's call it agency
list for system is collected and
implemented as an empty dictionary now
we simply can insert the nodes so
adjacent village dip and for 0 we'd
specify the neighbors and this will
basically be a list so this would be 1 M
2 and similarly you can you can copy
this but we'll see we now we can go 1 2
3 4 4 5 so this will be an empty list
for has neighbors 5 3 has neighbor 4
comma 5 2 as neighbors for and this
court neighbor 20 okay so we just
specify the gradient structure we
specified what are the neighbors of each
four days and now we can again create a
loop like this so we copy this again and
we say for be in range at this time this
should be and let's create another
variable let's call it and two and this
should be length of edges and he left
stick and should be Co like this it
should be picked and pretty cool we can
try to run this so go over there again
run my code I should probably give a
line over here so let's just write this
print mm backslash in okay now we run
this
okay pretty cool we can see the code is
working fine we got neighbors for all
the six vertices so that's how we
implement adjacency list in Python or
using these two methods if you got any
queries you cannot ask me in the comment
section I'll be posting this code in the
description and if you liked the video
to it the like button and thanks for
watching
in this presentation we are going to
look at using adjacency lists in graph
theory so let G be a simple graph at the
vertex set v1 v2 v3 v4 v5 so value for
five vertices and that is the adjacency
list there v1 is a neighbor of is
adjacent to v2 v3 v4 v2 is adjacent to
v1 v3 v4 v5 and so on what we have to do
here is answer the two following
questions first off list the degree
sequence of G so let's see that one
first so v1 is connected to three
vertices so three and v2 is connected to
four so there's four three three and one
so how do we write at the degree
sequence we write it out as follows for
in descending order there you have it
there and descending order at four three
three three and one so now let's look at
drawing the graph here so I'm going to
sort of set it up here as follows
so we have five vertices this is v1 v2
v3 v4 and v 5 and let's see how they
connect up to one another so v1 is
connected to v2 v3 and v4 so that
connects there there and down there v2
is connected to all of the other four
vertices so it's already connected to
one there so it's connected to be three
let's connect it to be five and it
connects to vie for v3 and v4 so we've
already connected to v1 and v2 so all
that remains is just connected to be
four down there just going to color the
vertices back in here plus a v4 is
connected to v1 v2 and v3 so we've
actually have taken care of all of those
already lastly v5 is connected to v2 and
again that has also been connected
already 2v2 so that there is the graph G
and that ends our presentation thank you
hello everyone so far in this series on
data structures we have talked about
some of the linear data structures like
array linked lists stack and queue in
all these structures data is arranged in
a linear or sequential manner so we can
call them linear data structures and
we've also talked about tree which is a
nonlinear data structure tree is a
hierarchical structure now as we
understand data structures are ways to
store and organize theta and for
different kinds of data we use different
kinds of data structures in this lesson
we are going to introduce you to another
nonlinear data structure and that has
got its application in a wide number of
scenarios in computer science it is used
to model and represent a variety of
systems and this data structure is graph
when we study data structures we often
first study them as mathematical or
logical models here also we will first
study graph as a mathematical or logical
model and we will go into implementation
details later okay so let's get started
a graph just like a tree is a collection
of objects or entities that we call
nodes or vertices connected to each
other through a set of edges but in a
tree connections are bound to be in a
certain way in a tree there are rules
dictating the connection among the nodes
in a tree with n nodes we must have
exactly n minus 1 edges one edge for
each parent-child relationship as we
know an edge in a tree is for a
parent-child relationship and all nodes
in a tree except the root node would
have a parent would have exactly one
parent and that's why if there are n
nodes there must be exactly n minus 1
edges in a tree all nodes must be
reachable from the root and there must
be exactly one possible path from root
to a node now in a graph there are no
rules dictating the connection among the
nodes a graph contains a set of nodes
and a set of edges and edges can be
connecting nodes in any possible way
tree is only a special
kind of graph now graph as a concept has
been studied extensively in mathematics
if you have taken a course on discrete
mathematics then you must be knowing
about crafts already in computer science
we basically study and implement the
same concept of graph from mathematics
the study of graphs is often referred to
as craft theory in pure mathematical
terms we can define graph something like
this a graph G is an ordered pair of a
set V of vertices and a set of edges now
I'm using some mathematical jargon here
an ordered pair is just a pair of
mathematical objects in which the order
of objects in the pair matters this is
how we write and represent an ordered
pair objects separated by comma put
within parentheses now because the order
here matters we can say that V is the
first object in the pair and E is the
second object an ordered pair a B is not
equal to B a unless a and B are equal in
our definition of graph here first
object in the pair must always be a set
of vertices and the second object must
be a set of edges that's why we are
calling the pair an ordered pair we also
have concept of an ordered pair an
unordered pair is simply a set of two
elements order is not important here we
write an unordered pair using curly
brackets or braces because the order is
not important here an ordered pair a B
is equal to B a it doesn't matter which
object is first and which object is
second okay coming back so a graph is an
ordered pair of a set of vertices and a
set of edges and G equal V E is a formal
mathematical notation that we use to
define a graph now I have a craft drawn
here in the write this graph has 8
vertices and 10 edges what I want to do
is I want to give some names to these
vertices because each node in a graph
must have some identification it can be
a name or it can be an
index I'm naming these vertices as V 1 V
2 V 3 V 4 V 5 and so on and this naming
is not indicative of any order there is
no first second and third node here I
could give any name to any node so my
set of what he sees here is this we have
eight elements in the set v1 v2 v3 v4 v5
v6 v7 and v8 so this is my set of
vertices for this graph now what's my
set of edges to answer this we first
need to know how to represent an edge an
edge is uniquely identified by its two
endpoints so we can just write the names
of the two endpoints of an edge as a
pair and it can be a representation for
the edge but edges can be of two types
we can have a directed edge in which
connection is one way or we can have an
undirected edge in which connection is
two way in this example graph that I'm
showing here edges are undirected but if
you remember the tree that I had shown
earlier then we have directed edges in
that free with this directed edge that
I'm showing you here we are saying that
there is a link or path from vertex u to
V but we cannot assume a path from V to
u this connection is one way for a
directed edge one of the endpoints would
be the origin and the other endpoint
would be the destination and we draw the
edge with an arrowhead pointing towards
the destination for our edge here origin
is U and destination is V a directed
edge can be represented as an ordered
pair first element in the pair can be
the origin and second element can be the
destination so with this directed edge
represented as ordered pair UV we have a
path from u to V if we want a path from
V to u we need to draw another directed
edge here with V as origin and u as
destination and this edge can be
represented as ordered pair V you
the upper one here is UV and the below
one is vu and they are not same
now if the edge is undirected the
connection is two-way an undirected edge
can be represented as an unordered pair
here because the edge is bi-directional
origin and destination are not fixed we
only need to know what two endpoints are
being connected by the edge so now that
we know how to represent edges we can
write the set of edges for this example
graph here we have an undirected edge
between v1 and v2 then we have one
between v1 and v3 and then we have v1 v4
this is really simple I'll just go ahead
and write all of them so this is my set
of edges typically in a graph all edges
would either be directed or undirected
it's possible for a graph to have both
directed and undirected edges but we are
not going to study such graphs we are
only going to study graphs in which all
edges would either be directed or
undirected a graph with all directed
edges is called a directed graph or
digraph and a graph with all undirected
edges is called an undirected graph
there is no special name for an
undirected graph usually if the graph is
directed we explicitly say that it's a
directed graph or digraph so these are
two types of graph directed graph or
digraph in which edges are
unidirectional or ordered pairs and
undirected graph in which edges are
bi-directional or unordered pairs now
many real-world systems and problems can
be modeled using a graph graphs can be
used to represent any collection of
objects having some kind of pairwise
relationship let's have a look at some
of the interesting examples a social
network like Facebook can be represented
as an undirected graph a user would be a
node in the graph and if two users are
French there would be an edge connecting
them a real social network would have
millions and billions of nodes I can
show only few in my diagram here because
I am short of space
now social network is an undirected
graph because friendship is a mutual
relationship if I am your friend you are
my friend too so connections have to be
two-way now once a system is modeled as
a graph a lot of problems can easily be
solved by applying standard algorithms
in graph theory like here in this social
network let's say we want to do
something like suggest friends to a user
let's say we want to suggest some
connections to Rama one possible
approach to do so can be suggesting
friends of friends who are not connected
already Rama has three friends Ella Bob
and Katie and Friends of these three
that are not connected to Rama already
can be suggested there is no friend of
Allah which is not connected to Rama
already Bob however has three friends
storm Sam and Lea that are not friends
with Rama so they can be suggested and
Katie has two friends Lee and Swati that
are not connected to Rama we have
counted Li already so in all we can
suggest these four users to Rama
now even though we described this
problem in context of a social network
this is a standard crafts problem the
problem here in pure graph terms is
finding all nodes having length of
shortest path from a given node equal to
two standard algorithms can be applied
to solve this problem we'll talk about
concepts like path in a graph in some
time for now just know that the problem
that we just described in context of a
social network is a standard crafts
problem okay so a social network like
Facebook is an undirected graph now
let's have a look at another example
interlinked web pages on the internet or
the world wide web can be represented as
a directed graph of web page that would
have a unique address or URL would be a
node in the graph and we can have a
directed edge if a page contains link to
another page now once again there are
billions of pages on the web but I can
show only few here the edges in this
graph are directed because
relationship is not mutual this time if
page a has a link to page B then it's
not necessary that page B will also have
a link to page a let's say one of the
pages on my code school comm has a
tutorial on craft and on this page I
have put a link to Wikipedia article on
graph let's assume that in this example
graph that I'm showing you here page B
is my my code school tutorial on graph
with this address or URL my code school
comm / videos / graph and let's say page
Q is the Wikipedia article on graph with
this URL wikipedia.org
/ wiki / graph now on my page that is
page P I have put a link to Wikipedia
page and graph if you are on page P you
can click on this link and go to page Q
but wikipedia has not reciprocated to my
favor by putting a link back to my page
so if you are on page Q you cannot click
on a link and come to page P connection
here is one way and that's why we have
drawn a directed edge here okay now once
again if we are able to represent web as
a directed graph we can apply standard
graph theory algorithms to solve
problems and perform tasks one of the
tasks that search engines like Google
perform very regularly is web crawling
search engines use a program called web
crawler that systematically browses the
worldwide web to collect and store data
about web pages search engines can then
use this data to provide quick and
accurate results against search queries
now even though in this context we are
using a nice and heavy term like web
crawling web crawling is basically draft
traversal or in simpler words act of
visiting all nodes in a graph and no
prizes for guessing that there are
standard algorithms for craft traversal
and we'll be studying graph traversal
algorithms in later lessons okay now the
next thing that I want to talk about is
concept of a weighted graph sometimes in
a graph all connections cannot be
treated as equal some connections can be
preferable to others like for example we
can represent intercity through a
network that is the network of highways
and freeways between cities as an
undirected graph I am assuming that all
highways would be bi-directional
intra-city road network that is road
network within a city would definitely
have one-way roads and so intra-city
road network must be represented as a
directed graph but intercity road
network in my opinion can be represented
as an undirected graph now clearly we
cannot treat all connections as equal
here roads would be of different lengths
and to perform a lot of tasks to solve a
lot of problems we need to take lengths
of roads into account in such cases we
associate some weight or cost with every
edge we label the edges with their
weights in this case weight can be
lengths off the roads so what I'll do
here is I'll just label these edges with
some values for their length and let's
say these values are in kilometers and
now edges in this graph are weighted and
this graph can be called a weighted
graph let's say in this graph we want to
pick the best route from City a to city
D have a look at these 4 possible routes
I'm showing them in different colors now
if I would treat all edges as equal then
I would say that the green route through
B and C and the red route through E and
F are equally good both these paths have
3 edges and this yellow route through E
is the best because we have only two
edges in this path but with different
weights assigned to the connections I
need to add up weights of edges in a
path to calculate total cost when I'm
taking weight into account
shortest route is through B and C
connections have different weights and
this is really important here in this
graph actually we can look at all the
graphs as weighted graphs and unweighted
graph can basically be seen as a
weighted graph in which weight of all
the edges is same and typically we
assume the weight as 1
okay so we have represented inter-cities
road network as a weighted undirected
graph social network was an unweighted
undirected graph and World Wide Web was
an unweighted directed graph and this
one is a weighted undirected graph now
this was anticipated what I think
intra-city road network that is road
network within a city can be modeled as
a weighted directed graph because in a
city there would be some one-ways
intersections in intra-city road network
would be nodes and Road segments would
be our edges and by the way we can also
draw an undirected graph as directed
it's just that for each undirected edge
we'll have two directed edges we may not
be able to redraw our directed graph as
undirected but we can always redraw an
undirected graph as directed okay I'll
stop here now this much is good for an
introductory lesson in next lesson we
will talk about some more properties of
graph this is it for this lesson thanks
for watching
the following content is provided under
a Creative Commons license your support
will help MIT OpenCourseWare continue to
offer high quality educational resources
for free
to make a donation or view additional
materials from hundreds of MIT courses
visit MIT opencourseware at ocw.mit.edu
today we're going to sort of introduce
graph search in general and talk about
one algorithm which is breadth-first
search and understand how in principle
you could solve a puzzle like the
Rubik's Cube so before I get to rubik's
cubes let me remind you of some some
basic stuff about graphs or I can tell
you start out with graph search is about
exploring a graph and there's many
different notions of exploring a graph
maybe I give you some note on a graph s
and some other node in a graph T and I'd
like to find a path that's going to
represent a problem like I give you a
particular state of a Rubik's Cube and I
want to know is there some path that
gets me into a solve state I really want
to solve this on stage what the hell we
started all right so this is a
particularly easy state to solve which I
set it up this way alright so there you
go seven by seven by seven rubik's cube
solves in 10 seconds amazing new world
record so that you're given some initial
can state of the rubik's cube you given
the target state you know what solve
looks like you want to find this path
maybe you want to find all paths from s
maybe you just want to explore all the
nodes in a graph that you can reach from
s maybe you want to explore all the
nodes in a graph or maybe all the edges
in the graph these are all exploration
problems they're all going to be solved
by algorithms from this class and next
class so before we go further though I
should remind you what a graph is and
sort of basic features of graphs that
we're going to be using this is all 6 of
14 material so you should know it very
well
if you don't there's an appendix in the
textbook about it we have a set of
vertices we have a set of edges
okay edges are either unordered pairs so
sets of two items or ordered pairs in
this case we call the graph undirected
in this case we call the graph directed
usually there's only one type either all
the edges are directed or all the edges
are undirected there is a study of
graphs that have both but we are not
doing that here so some simple examples
here's a graph this is an undirected
graph
this is a directed graph okay set of
vertices here is ABCD set of verses here
is ABC set of edges here is so e is
going to be things like a b c c c d i
think you get the idea
just for completeness V is ABCD just so
you remember of notation and so on one
of the issues we're going to talk about
in this class is how do you represent a
graph like this for an algorithm so it's
all fine to say oh this is a set of
things this is a set of things an
obvious representation is you have a
list or an array of vertices you have an
array of edges each edge knows as two
endpoints that would be a horrible
representation for graph because if
you're I don't know you're at vertex a
and you want to know what are the
neighbors of a B and C you have to go
through the entire edge list to figure
out the neighbors of a so it's been
linear time just to know where you can
go from a so we're not going to use that
representation we're going to use some
better representations something called
adjacency lists cool okay over here
you've got things like AC BC and CB so
you can have edges in both directions
what am I missing
ba that's e in that case there whole lot
of applications of graph search I make
you a little list talk about a few of
them so we've got web crawling your
Google you want to find all the pages on
the web most people don't just tell you
hey I've got a new page please Index it
you have to just keep following links in
the early days of the web this is a big
deal following links finding everything
it's out there it's a little bit of an
issue because if you define it wrong the
Internet is infinite because of all this
dynamically generated pages but to deal
with that google goes sort of
breadth-first for the most parts to
prioritize but you from you want to see
all the things you can reach from pages
you already have and keep going at some
point you give up and you run out of
time social networking and Facebook use
friend finder it tries to find the
friends that are nearest to you or
friends of friends is sort of a level to
search that's essentially a graph search
problem you want to know what's two
levels or three levels of separation
from you and then you go you look loop
over those and look for other signs that
you might be good friends you're on a
network like the internet or some
intranet you want to broadcast a message
so here's you you want to send data out
that's essentially a graph exploration
problem that message that packet is
going to explore the graph garbage
collection I hope you all know that
modern languages have garbage collection
this is why you don't have to worry
about freeing things even in Python even
in C Python I learned there is a garbage
collector as a version two but also in
pi PI and Jai thon and in Java and like
pretty much every fairly modern language
you have garbage collection meaning if
there's some data that's unreachable
from so you have your variables whatever
is actively in variables that can be
accessed by the program everything is
reachable from there you have to keep
but if some data structure becomes no
longer reachable you need to you can
throw it away and regain memory and so
that's happening behind the scenes all
the time and the way it's being done is
with the breadth-first search which is
what we're going to talk about
today another one model checking model
checking is you have some finite model
of either a piece of code or a circuit
chip whatever you want to prove that it
actually does what you think it does
and so you've drawn a graph which is the
graph is all the possible states that
your circuit or your computer program
could reach or that it could possibly
have you started some initial state and
you want to know among all the states
that you can reach does it have some
property and so you want need to visit
all the vertices that are reachable from
a particular place to do that and
usually people do that using
breadth-first search I use breadth-first
search a lot myself to check
mathematical conjectures so if you're a
mathematician and you want you think
something is true like maybe well it's
hard to give an example of that but you
have you can imagine some graph of all
the possible sort of inputs to that
theorem and you will need to check them
for every possible input this is true
typical way to do that is breadth-first
searching through that entire graph of
states usually we're testing finite
special cases of a general conjecture
but if we find a counter example we're
done don't have to work on it anymore
if we don't find a counter example
usually then we have to do the
mathematics so it's not doesn't solve
everything but it's helpful
and then the fun thing we're going to
talk about a little bit today is if you
want to solve something like a 2x2 2x2
Rubik's Cube optimally you can do that
using breadth-first search and you're
going to do that on your problem set do
it solving this one optimally using
breadth-first search would probably what
would definitely take more than the
lifetime of the universe so don't try 7
by 7 by 7 leave that to the cubing
experts I guess no I think no one will
ever solve a 7 by 7 by 7 Rubik's Cube
optimally but there are ways to find a
solution just not the best one okay so
let me tell you just for fun as an
example this pocket cube which is 2 by 2
by 2 rubik's cube what we have in mind
is it's called the configuration graph
or sometimes configuration space but
it's a graph so graph this graph has a
vertex for each possible state of the
cube so this is a state little quickie
here this is a state this is a state
this is a state now I'm hopelessly lost
ok
anyone want to work on this board no one
all right leave it I'm so thin ok so all
those are vertices there's actually a
lot of vertices there are 264 million
vertices or so if you want on the side
here number of vertices is something
like 8 factorial times 3 to the eighth
and one way to see that
try to vet to vet your Rubik's Cube so
these are these guys are yeah these are
what you might call cubelets or cubes i
think is standard term in rubik's cube
land and so the how there's eight of
them and a two by two by two two cubed
you can essentially permute those cubies
within the cube however you like that's
eight factorial and then each of them
has three possible twists it could be
like this it could be like this or it
could be like this okay so you've got
three for each and this is actually an
accurate count you're not over counting
the number of configurations all of
those are at least in principle
conceivable if you take apart the cube
you can reassemble it in each of those
states and that number is about 264
million okay which is not so bad for
computers you could search that life is
a little bit easier you get 2 divided by
24 because there's 24 symmetries of the
cube 8 times 3 you can divide by 3 also
because only 1/3 of the configuration
space is actually reachable if you're
not allowed to take the parts apart you
have to get there by emotion you can
only get to 1/3 of the 2 2 by 2 by 2 so
it's a little bit smaller than that if
you're actually doing a breadth-first
search which is what you're going to be
doing on your problem set but in any
case it's feasible
okay that's vertices should talk about
edges
for every move every move takes you from
one configuration to another you could
traverse it in one direction I'll make
that move you could also undo that move
because every move is undoable in a
rubik's cube this graph is undirected or
you can think of it as every edge works
in both directions so so this is a move
is called a quarter twist sum it's a
controversy if you will some people
allow whole half twists as a single move
whether you define that as a single move
or a double move not that big a deal
just changes some of the answers but
you're still exploring essentially the
same graph so that's the graph and you'd
like to know some properties about it so
let me draw a picture of the graph I'm
not going to draw all 264 million
vertices but in particular there's the
solved state we kind of care about that
one
where all the colors are aligned then
there's all of the configurations you
could reach by one move so these are the
possible moves from solve state and then
from those configurations there's more
places you can go maybe there's multiple
ways to get to the same node ok but
these would be all of the configurations
you can reach in two moves
okay and so on and at some point you run
out of graph so there might be some ways
to get there might be a few things she
nodes out here these are kind of the way
I'm drawing this this is everything you
can reach in one move and two moves and
three moves at the end this would be 11
moves if you if you allow half twists
and I guess as puzzlers we're
particularly interested in this number
which you would call as a graph theorist
the diameter of the graph puzzlers call
it God's number if you were God or some
money something being you have the
optimal algorithm for solving the
Rubik's Cube how many moves do you need
if you always follow the best path and
the answer is in the worst case 11 so
we're interested in the worst case of
the best algorithm for 2 by 2 by 2 the
answer is 11 for 3 by 3 by 3 the answer
is 20 that was just proved last summer
with a couple years of computer time for
4 by 4 by 4 I don't have one here I
think we'll never know the answer for 5
by 5 by 5 we'll never know the answer
for 6 4 7
same deal but 4 2 by 2 by 2 you can
compute it you will compute it on your
problem set and it's kind of nice to
know because it says whatever
configuration I'm in I can solve it in
11 moves but the best known way to
compute it is basically to construct
this graph one layer at a time until
you're done and then you know what the
diameter is the trouble is in between
here this grows exponentially at some
point it decreases a little bit but
getting over that exponential hump is
really hard and for 3 by 3 by 3 they
used a lot of tricks to speed up the
algorithm but in the end it's
essentially breadth-first search
what's a breadth-first search this going
layer by layer so we're going to
formalize that in a moment
but that is the problem
so just for fun any guesses what the
right answer is for an N by n by n
rubik's cube what's the diameter not an
exact answer because i think we'll never
know the exact answer but if i want data
something what do you think that
something is how many people here solved
a Rubik's Cube ever okay so you know
what we're talking about here
most people have worked on you think
about an N by n by n rubik's cube each
side has area N squared so total areas
surface area is 6n squared so it's
roughly Stata N squared little cubes
here
so what do you think the red asymptotics
is for n by n by n now guesses
and cubes reasonable guess but wrong
it's an upper-bound yn cubes
oh you're guessing based on the numbers
yes the numbers are misleading
unfortunately it's love love small
numbers I guess doesn't really look
right I know the answer I know the
answer because we just wrote a paper
with the answer this is a new result
from this summer but I'm curious to me
the obvious answer is N squared because
there's about N squared Q B's and it's
not so hard to show in a constant number
of moves you can solve a constant number
of cubies if you think about the general
algorithms like if you've ever looked up
professor's cube how to solve it you're
doing like 10 moves and then you saw
maybe swap two cubes which you can use
to solve a couple cubes in a constant
number of moves so N squared would be
the standard answer if you're following
standard algorithms but it turns out you
can do a little bit better the right
answer is N squared divided by log in I
think it's cool
hopefully you guys can appreciate that
not a lot of people can appreciate N
squared divided by log n but here in
algorithms we're all about and squared
over log in
so if you're interested papers on my
website things called algorithms for
solving Rubik's cubes there's a constant
their current constant is not so good
let's say it's in the millions but hey
you got to start somewhere
there's the next work the next open
problem would be to improve that
constant to something reasonable that
maybe is close to 20 but we're far from
that okay let's talk about graph
representation before we can talk about
exploring a graph we need to know what
we're given as input and there's
basically one standard representation
and a bunch of variations of it and
they're called adjacency lists so the
idea with an adjacency list is you have
an array called a DJ for adjacency of
size V each element in the array is a
pointer to a linked list and the idea is
that this array is indexed by a vertex
so we're imagining a world where we can
index arrays by vertices so maybe you
just label your vertices 0 through V
minus 1 then that's regular array or if
you want to get fancy you can think of a
vertex as an arbitrary hashable thing
and adj is actually a hash table and
that's how you probably do it in Python
maybe your vertices are objects and this
is just hashing based on the address the
object but we're not going to worry
about that just going to write adj if
you assume that somehow you can get the
linked list corresponding with that
vertex
and the idea is for every vertex we just
store its neighbors namely the vertices
you can reach by one step from you so
I'm going to define that a little more
formally adj of U is going to be the set
of all vertices V such that UV is an
edge
okay so if you have a vertex where's
where my graphs here so if I have a
vertex like B a G of B is going to be
both a and C because in one step there
are outgoing edges from B to a and B to
C so a GJ of B is a see in that graph
should label the vertices something
different
adj of a is going to be just C because
you can't get from once with one step
from A to B there's a the edges in the
wrong direction okay an Ag G of C is B
okay I think that definition is pretty
clear for undirected graphs you just put
braces here which means you store I mean
it's the same thing for here adj of C is
going to be a B and D as you can get in
one step from C to a from C to B from C
to B this for pretty much every at least
for graph exploration problems this is
the representation you want because
you're at some vertex you want to know
where can I go next and adj of that
vertex tells you exactly where you can
go next so this is what you want there's
a lot of different ways to actually
implement adjacency lists
I've talked about two of them you could
have the vertices labeled zero to V
minus one and then this is literally an
array and you have I guess I should draw
in this picture adj is an array so
you've got a B and C each one of them is
a pointer to a linked list this one's
actually going to be a C and we're done
this one in oh sorry that was B B who
said it had to be alphabetical order a
is pointer to C C is a pointer to be
okay that's explicitly how you might
represent it this might be a hash table
instead of an array if you have weirder
vertices you can also do it in a more
object-oriented fashion you could for
every vertex V you can make V the
vertices objects and V dot neighbors
could store what we're defining over
there to be a DJ of V okay this would be
the more object-oriented way to do it
I've thought a lot about this and that I
like this and usually want to implement
graphs this is what I do but it is
actually it's convenient to have this
representation there's a reason the
textbook uses this representation
because if you've already got some
vertices lying around and you want to
have multiple graphs on those vertices
this lets you do that if you can define
multiple adj arrays one for graph one
one for graph two one for graph three
they could all talk about the same
vertices whereas here if vertex can only
sort of belong to one graph it can only
have one neighbor structure that says
what happens if you're only dealing with
one graph this is probably cleaner but
with multiple graphs which will happen
even in this class Jason see lists are
kind of the way to go you can also do
implicitly represented graphs
which would be to say a DJ of you is a
function or V Nabors is a method of the
vertex class okay meaning it's not just
stored there explicitly whenever you
need it you call this function and it
computes what you want this is useful
because it uses less space you could say
this uses zero space or maybe V space
for one for each vertex depends maybe
you don't even need to explicitly
represent all the vertices you start
with some vertex and given a vertex
somehow you know how to compute let's
say in constant time or linear time or
something
the neighbors of that vertex and then
from there you could keep keep search
and keep computing neighbors until you
find what you want maybe you don't have
to build the whole graph you just need
to be able to build enough of it till
you find your answer whatever answer
you're searching for
you think of a situation where that
might be the case where implicit
representation would be good idea yeah
Rubik's cubes you're really good I never
want to build this space it has a
bajillion States bajillion vertices it
would take forever there's more
configurations of this cube than there
are particles in the known universe yeah
just computed that in my head I have
done this computation recently for five
by five by five it's like 10 to the 40
States
or 10 to the somewhere 10 to the 40 10
to the 60 there's about 10 to the 80
particles in the known universe 10 to 83
or something so this is probably I don't
- 10 to the 200 or so it's a lot you
never want to build that but it's very
easy to represent this state just store
where all the cubes are and it's very
easy to see what are all the
configurations you can reach in one move
just try this move
this move try this move put it back and
try the next move and so on so in you
know time for an N by n by n cube in
order n time you can list all the order
n next States you can list all the order
and neighbors and so you could keep
exploring searching for your state now
you don't want to explore too far for
that cube but at least you're not you're
not hosed just from the problem of
representing the graph so it for even
for 2 by 2 by 2 it's useful to do this
mostly to save space you're not really
saving time but you don't you'd like to
not have to store all 264 million states
because it's going to be several
gigabytes and it's annoying speaking of
space ignoring the implicit
representation how much space does this
representation require
v+ e it's going to be our the bread and
butter of our graph algorithms most of
the things we're going to talk about a
TV plus e time this is essentially
optimal it's linear in the size of your
graph we've got V vertices edges
technically if in case you're curious
this is really the size of V plus the
size of E but in the textbook and I
guess in the world we just omit those
sizes of whenever they're in a theta
notation or Big O notation so a number
of vertices plus number of edges that's
sort of the bare minimum you need if you
want an explicit representation of the
graph and we achieve that because we've
got V space just to store the vertices
in an array and then if you add up all
each of these is an edge to be a little
careful in undirected graphs each of
these is a half edge so there's actually
two times e nodes over here but Stata e
so theta V + e the amount of space for
need and ideally all our algorithms will
run in this much time is that that's
what all you that's what you need just
to look at the graph okay
so let's do an actual algorithm is
breadth-first search so - the simplest
algorithm you can think of graphs I've
already outlined it several times you
start at some node you look at all the
nodes you can get to from there you look
at all the nodes you can get you from
there
keep going until you're done so this is
going to explore all of the vertices
that are reachable from a node the
challenge the one annoying thing about
breadth-first search and why this is not
trivial is that there can be some edges
that go sort of backwards like that to
some previous layer actually that's not
true is it this can't happen see why
because if that if that edge existed and
from this node you'd be able to get here
so in an undirected graph that can't
happen in a directed graph you could
conceivably have a back edge like that
you have to realize oh that's the vertex
I've already seen I don't want to put it
here even though it's something I can
reach from this node because I've
already been there you've got to worry
about things like that yeah that's I
guess the main thing to worry about
so our goal is to visit all the nodes
vertices reachable from given a s we
want to achieve V Plus E time and the
idea is to look at the nodes that are
reachable first in 0 moves 0 moves
that's s then in one move well that's
everything you can reach from s in one
step that's adjacency of s and then 2
moves and 3 moves and so on until we run
out of graph ok but we need to be
careful to avoid duplicates we want to
avoid revisiting vertices for a couple
reasons one is if we didn't we would
spend infinite time because we just go
there and come back and go there and
come back as long as there's at least
one cycle you're going to keep going
around the cycle forever and ever if you
don't try to avoid duplicates all right
so let me write down some code for this
algorithm it's pretty straightforward
but so straightforward we can be
completely explicit and write code
a few different ways to implement this
algorithm I'll show you my favorite
textbook has a different favorite I'm
going to write in pure Python I believe
almost done
okay got that right so this is at the
end of the while loop
and at that point we should be done we
could do an actual example maybe
I'm going to do it on a direct us or an
undirected graph but this algorithm
works just as well on directed and
undirected graphs okay there's an
undirected graph we're given some start
vertex s and we're given the graph by
being given the adjacency lists so you
could iterate over the vertices of that
thing given a vertex you can list all
the edges you can reach in one step and
then the top of the algorithm is just
some initialization the basic structure
we have this thing called the frontier
which is what we just reached on the
previous level I think that's going to
be level I minus 1 just I want to make
an index error these are going to be all
the things you can reach using exactly I
minus 1 moves and then next is going to
be all the things you can reach in I
moves okay so to get started what we
know is s S is what you can reach in 0
moves so we set the level of s to be 0
that's the first line of the code
there's this other thing called the
parent we'll worry about that later it's
optional just it gives us some other fun
structure we sent I to be 1 because we
just finished level 0 frontier of what
you can reach in level 0 is just s
itself so we're going to put that on the
list that is level 0 I equals 1 so 1
minus 1 is 0 all good and then we're
going to iterate and this is going to be
looking at that the end of the iteration
is to increment I so you could also call
this a for loop except we don't know
when it's going to end so it's easier to
think of I incrementing each step
not knowing when we're going to stop
we're going to stop whenever we run out
of nodes so whenever frontier is a
non-empty list and the bulk of the work
here is computing what the next level is
that's called next it's going to be
level I we do some computation
eventually we have what's on the next
level that we set frontier next so
because that's our new level we
increment I and that invariant of
frontier being level I minus one is
preserved right after here and then we
just keep going till we run out of notes
how do we compute next well we look at
every node on the frontier and we look
at all the nodes you can reach from
those nodes so every node you and the
frontier and then we look at so this
means there's an edge from u to V or the
picture we look at all the edges from
all the frontier nodes where you can go
and then the key thing is we check for
duplicates we see have we seen this node
before if we have we would have set its
level to be something if we haven't seen
it it will not be in the level hash
table the level dictionary and so if
it's not in there we'll put it in there
and add it to the next layer so that's
how you avoid duplicates we set its
level to make sure you will never visit
it again you add it to the next frontier
you iterate you're done okay this is one
version of what you might call
breadth-first search and it achieves
this goal visiting all the nodes
reachable from s in linear time let's
see how it works on a real example
so first frontier is this thing frontier
just has the node s so we just look at s
and we look at all the edges from s we
get a and X so those get added to the
next frontier maybe before I go too far
let me switch colors
Multimedia here oh so here's level 1 all
of these guys have we're going to set
their level to 1 they can be reached in
one step that's pretty clear so now
frontier is a and X will go to that's
what next becomes then frontier becomes
next and so we look at all the edges
from a that's going to be s and z s
we've already looked at it already has a
level set so we ignore that so we look
at Z Z does not have a level indicated
here so we're going to set it to AI
which happens to be 2 at this point then
we look at X it has neighbors s D and C
we look at s again we say oh we've
already seen that yet again
so we're worried about this taking a lot
of time because we look at s 3 times in
total then we look at D D hasn't been
set so we set it to 2 C hasn't been set
so we set it to two so the frontier at
level two is that ok then we look at all
the neighbors of Z there's a A's already
been set look at all the neighbors of D
there's X or C those have been set
there's F this one gets added then we
look at C there's X that's been done DS
been done F's been done V has not been
done so this becomes a frontier at level
three then we look at level three F
these been done C's been done B's been
done that we look at V C's been done s
been done nothing to add to next next
becomes empty frontier becomes empty the
while loop finishes
tada we've computed we visited all the
vertices questioned
yeah
what this is Python notation you may
have heard of Python this is a
dictionary whose which has one key value
s and has one value zero so you could
you could yeah that's shorthand in
Python for usually you have a comma
separated list the colon is specifying
key value pairs okay I didn't talk about
parent we can do that a little bit so
parent we're initializing to say parent
of s is nobody and then whenever we
visit a new vertex V we said its parent
to be the vertex that we came from so we
had this vertex V we had an edge to V
from some vertex u we set the parent of
V to be u so let me add in what that
becomes will change colors yet again
although it gets hard to see any color
but red let's see so we have s when we
visited a then the parent of a would
become s when we visited Z the parent of
Z would be a parent of X is going to be
s kind of D is going to be X pan of C is
going to be X parent of F it could have
been either way but the way I did it D
went first and so that became its parent
and I think the C was its parent okay so
that's what the parent pointers will
look like they always follow edges they
actually follow edges backwards if this
was a directed graph graph might be
directed that way but the parent
pointers go back along the edges so it's
a way to return it's a way to return to
s if you follow these pointers all roads
lead to s ok because we started at s
that's the property we have in fact
these pointers always form a tree and
the root of the tree is s in fact these
pointers form what are called shortest
paths let me write down a little bit
about
this shortest-path properties
if you take a node and you take its
parent and take the parent of the parent
and so on eventually you get to s and if
you read it backwards that will actually
be a path in the graph and it will be a
shortest path in the graph from s to V
meaning if you look at all paths in the
graph that go from s to V so say we're
going from s to V how about that we
compute this shortest we compute this
path out of BFS which is follow a parent
of V is C prime of C is X parent of X is
s read it backwards that gives us a path
from s to V the claim is that is the
shortest way to get from s to V might
not be the only one like if you're going
from s to F there's two short paths
there's this one of length three there's
this one of length three just three
edges same length and in the parent
pointers we can only afford to encode
one of those paths because in general
there might be exponentially many ways
to get from one node to another we find
a shortest path not necessarily the only
one and the length of that path so
shortest here means that you use the
fewest edges and the length will be
level of V that's what we're keeping
track of the level 0 you can get there
with 0 steps if the level is 1 you can
get there with 1 steps because we're
visiting everything you can possibly get
in K steps the level is telling you what
that shortest path distance is and the
parent pointers are actually giving you
the shortest path that's the cool thing
about BFS yeah BFS explores of vertices
sometimes that's all you care about but
in some sense what really matters is it
finds the shortest way to get from
anywhere to anywhere for a rubik's cube
that's nice because you run the shortest
path
you run BFS from the start state rubik's
cube then you say oh I'm in this state
you look up this state you look at its
level it says oh you can get there in 9
steps that's I think the average so I'm
guessing I don't know how to do this in
10 steps
and then great so now you know how to
solve it you just look at the parent
pointer the parent pointer gives you
another configuration Co what move was
that and then you do that move
I'm not going to solve it then you look
at the parent pointer that you do that
move look at the parent pointer that you
do that move eventually you will get to
the solved state and you will do it
using the fewest possible moves so if
you can afford to put the whole graph in
memory which you can't for big Rubik's
Cube but you can for a small one then
this will give you the a strategy the
optimal strategy God's algorithm if you
will for every configuration it solves
all of them is great what is the running
time of this algorithm I claim that's
order V + E but it looked a little
wasteful because it was checking
vertices over and over and over but if
you think about it carefully you're only
looking it's the right way to say this
you only check every edge once or in
undirected graphs you check them twice
once from each side when I visit a
vertex enters the frontier only once
because once it's in the frontier it
gets a level set and once it has a level
set it'll never go in again it'll never
get added to next so you know s gets
added once then we check all the
neighbors of s a gets added once then we
check all the neighbors of a X each of
these guys gets added once we check all
the neighbors so the total running time
is going to be the sum over all vertices
of the size of the adjacency list of B
so this is the number of neighbors that
V has and this is going to be answer
twice the number of edges for undirected
graphs it's going to be the number of
edges for directed graphs this is the
handshaking lemma if you don't remember
the handshaking lemma you should read
the textbook just double o6o for two
stuff because you basically visit every
edge twice for directed graphs you visit
every edge once but it's order e we also
spend order V because we touch every
vertex so total running time is order V
+ e in fact the way this is going you
can be a little tighter and say it's
order e I just want to mention in
reality sometimes you don't care about
just what you can reach from s you
really want to visit every vertex then
you need another outer loop that's
iterating over all the vertices as
potential choices for s and you then can
visit all the vertices in the entire
graph even if it's disconnected we'll
talk more about that next class that's
it for BFS
all right in this video I just want to
talk a little bit about some graph
theory and just some basic terminology
and ideas they get used so definitely
not going to be a you know a complete
version of everything you need to know
but definitely some basic ideas so graph
theory got started by really kind of I
think really came about by Leonardo and
what he did is he solved a problem the
famous bridge of coningsburgh problem
and that kind of a put graph theory sort
of out there for people to start
thinking about and for a while graph
theories kind of kind of poo-pooed on it
was kind of considered I think sort of a
recreational branch of math not really a
ton of uses but uh definitely with the
advent here of computer science that's
changed all that graph theory gets used
all the time in computer science lots of
other places as well
definitely become a very hot area to
research and I like it just because the
problems are easy to understand you can
draw pictures and visualize I definitely
enjoy it but let's see so the definition
of a graph that we're going to use and
these vary again from person to person
things still aren't really set in stone
a lot of the notation and definitions
but for us a graph is going to be a
non-empty finite set of vertices some
people will let it be infinite with a
set of two elements subsets of V we call
the elements of V vertices and the
elements of a are called edges so that
sounds may be a little more confusing
that it is all a graph is it's just dots
and lines connecting that's all a graph
is okay so we talked about graph theory
we're not talking about y equals x
squared
just just points and lines connecting
them so we would say the vertex set V
for this
graphs maybe we'll call it G are just v1
v2 v3 v4 v5 and v6 and you can think
really you know maybe these are just six
people at a party and v1 knows v2 v3 v4
you can see that v5 only knows person v4
and v6 maybe that's what an edge
represents is if they know each other
okay you know and you can make the edges
represent whatever you want to so maybe
we'll just think about the edges as
meaning there's a connection between
them and they know each other so the
edge set that's just going to be all two
elements subsets and basically we just
list all the vertices that have an edge
between them so v1 and v2 v1 and v3 v1
and v4
let's see v4 is connected to V 5 and
then vertex V 5 is connected to V 6 and
I think that's everything we need you
know we don't need to list V 6 is
connected to V 5 for example it's just
redundant already so if I had you know
again basically just this set in this
set e again it's just basically telling
me all the information in this original
graph so I still know that a couple
things the cardinality the cardinality
of a graph just represents the number of
vertices
the notation I've seen is they'll put an
absolute value so the absolute value of
G the cardinality of G is just the
number of vertices which in this case is
six
let's see another thing that we often
talk about is the degree of a vertex so
for example the degree of vertex v1
which will abbreviate little deg v1 all
that tells you is the number of edges
coming out from vertex v1 so there's one
two three edges leaving v1 so we would
say the degree of vertex v1 is three
again so vertex v1 knows three other
people is all that says another kind of
convention for a typical graph we don't
let a vertex have a loop back to itself
okay I mean definitely that certainly
happens in a lot of applications but
when we lao graphs to have loops back to
themselves typically people will call
those multi graphs so multi grass have
loops regular graphs don't have loops so
pretend that loops not there and we just
got the original the original matrix
that we are the original graph we
started with a couple other things to
the way that you draw the graph is
irrelevant
so here's V one here's V two here's V
three here's V 4 V 5 down there I want
to make it too crazy v 6 you know they
don't have to be straight lines they can
be whatever they want so okay so V 1 is
still connected to V 2 V 1 should still
be connected to V 3 V 1 is still
connected to V 4
we'll have v4 still connected to v5 and
hey v5 is still connected to vertex v6
so all the original connections are
still preserved and there's sort of no
new connections in there that weren't
there before
so when you have a graph where basically
all the original information is
preserved the original connections
there's no new connections there's
nothing missing and again this is very
kind of loose definition but we would
say that the original graph and this new
graph are isomorphic and all that means
is from a graph theory point of view
they're one in the same they're exactly
the same graph okay so typically tribuna
will try to draw them as a you know in
the least confusing manner as possible
but definitely an important idea the way
that you draw the graph in general
doesn't matter let's talk about a couple
other ideas just a way to describe a
graph one way is with what's called an
adjacency list and I don't know how
useful these are I never really saw them
much but again I didn't take a
tremendous amount of graph theory so
that doesn't mean that they don't get
used all the time and I just haven't ran
into it but all an adjacency list is
exactly what you think so all we do is
just list vertex that our vertices that
are adjacent so for v1 it's adjacent to
v1
excuse me fee one's adjacent to v2 v3
and v4
so we'll list those v2 v3 v4 vertex V 2
is only adjacent to v1 v3 is only
connected to v1 v4 is connected to V 1
and V 5
v5 is connected to v4 and v6 and v6 is
connected to v5 and again it's just
another way of summarizing you know so
this is Jason C list this set V in the
set E and this graph again are telling
me all the exact same information
another way that I know gets used all
the time is instead of doing an
adjacency list we'll make what's called
an adjacency matrix okay so I'm going to
imagine v1 v2 v3 typically people won't
even write these but you know this is
what makes sense to me so a lot of times
I used to always stick them in there v1
v2 v3 v4 v5 v6 all we do is if there's a
loop if there's a connection from a
vertex to another vertex we'll put a 1
and if there's not we'll put a 0 so
since there's not a loop from v1 to v1
we'll put a 0 there but v1 is connected
to v2 v3 and v4 so V once connected to
v2 v3 and v4 but it's not connected to
v5 or v6 there's not an edge present
likewise v2 is only connected to v1 so
we'll put a 1 there and then we'll put
zeros everywhere else
let's see v3 is also only connected to V
ones we'll put a 1 there and zeros
everywhere else v4 is connected to v1
and also to v5 so we'll put ones there
zeros everywhere else v5 is connected to
v4 and v6 so put ones there zeroes
everywhere else
lastly v6 is only connected to v5 so
we'll put a one there
and zeros everywhere else so this is
nice because you can do math of major
Z's ok so definitely there's a lot of
study done with you know matrix
representations of graphs you can do
stuff with them two less things just
maybe two last ideas notice for any
vertex here if you you know so imagine
maybe these are islands now and there's
a little bridge connecting the islands
notice in this this graph if you ever
were to leave an island suppose I was at
Island v1 and I went to Island v4 the
only way I can get back to Island v1 is
the sort of backtrack you know I could
go all the way to v5 and v6 but
eventually to get back I have to take
you know the bridges back so there's no
loops or what are called circuits if
there are no loops or circuits we say
that this is an example of a what's
called a tree and the idea with trees is
you can always sort of rewrite them and
the reason why we call them trees is we
sort of can rewrite them you know so
here's v1 it's connected to V 2 V 3 V 4
V 4 is connected to V 5 and V five is
connected to V 6 so again these would be
isomorphic graphs but now it's kind of
if you flip it over and maybe it had
some more branches the idea that starts
to look like a tree trees get used all
the time for example you know imagine a
chess algorithm you know it's the first
move you know maybe you've got one two
three reasonable reasonable moves that
you're disposable at your disposal not
disposable at your disposal
you know and then maybe you know once
you consider this move maybe there's
only one logical move from that and then
from that there's only one logical move
so trees can help sort of represent sort
of searches you know a computer search
so definitely one place I know for sure
that they get studied again if a graph
so maybe this is a whole separate little
graph over here this graph we would say
has a circuit and the idea is a circuit
you know for example if I met this
vertex I can leave that vertex and still
manage to get back to it without really
ever backtracking through through an
edge or a vertice I don't have to visit
the same place twice as all it says ok
so this would be an example of a graph
that does have a circuit so graph theory
I think is really interesting you know
there's tons of open problems if you're
a budding math person out there and what
some challenging problems
there's definitely tons of open graph
theory problems that are very simple to
understand you know definitely you've
got to learn some of the techniques to
be able to attack things but a lot of it
is very sort of intuitive and I think
open you know sort of it's very user
friendly because what I'm trying to say
there's still some reasonable open
problems out there for people to tackle
for sure so if you are interested in
kind of getting your hands wet and doing
some harder problems
I say graph theory is a great place to
start maybe I can even post some open
questions so all right I hope this
little introduction makes some sense you
get nothing too heavy I definitely plan
on doing some more you know detailed
stuff but again hopefully this is a good
little warm-up and just a good little
intro to some of the ideas
