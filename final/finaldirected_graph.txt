in our previous lesson we introduced you
to graphs we defined graph as a
mathematical or logical model and talked
about some of the properties and
applications of graph now in this lesson
we will discuss some more properties of
graph but first I want to do a quick
recap of what we have discussed in our
previous lesson a graph can be defined
as an ordered pair of a set of vertices
and a set of edges we use this formal
mathematical notation G equal V II to
define a graph here V is set of vertices
and E is set of edges ordered pair is
just a pair of mathematical objects in
which order of objects in the pair
matters it matters which element is
first and which element is second in the
pair now as we know to denote number of
elements in a set that we also call
cardinality of a set we use the same
notation that we use for modulus or
absolute value so this is how we can
denote number of vertices and number of
edges in a graph number of vertices
would be number of elements in set V and
number of edges would be number of
elements in set E moving forward this is
how I am going to denote number of
vertices and number of edges in all my
explanations now as we have discussed
earlier edges in a graph can either be
directed that is one-way connections or
undirected that is two-way connections a
graph with only directed edges is called
a directed graph or digraph and a graph
with only undirected edges is called an
undirected graph now sometimes all
connections in a graph cannot be treated
as equal so we label edges with some
weight or cost like what I'm showing
here and a graph in which some value is
associated to connections as cost or
weight is called a weighted graph a
graph is unweighted if there is no cost
distinction among edges okay now we can
also have some special kind of edges in
a graph these edges complicate
algorithms and make working with graphs
difficult but I'm going to talk about
them anyway an edge is called a self
loop or self edge if it involves only
one vertex
if both endpoints of energy are same
then it's called a self-loop we can have
a self-loop in both directed and
undirected graphs but the question is
why would we ever have a self-loop in a
graph well sometimes if edges are
depicting some relationship or
connection that's possible with the same
node as origin as well as destination
then we can have a self loop for example
as we have discussed in our previous
lesson interlinked web pages on the
internet or the world wide web can be it
presented as a directed graph a page
with a unique URL can be a node in the
graph and we can have a directed edge if
a page contains link to another page now
we can have a self loop in this graph
because it's very much possible for a
web page to have a link to itself have a
look at this web page my code school
comm / videos in the header we have
links for workouts page problems page
and read your age right now I'm already
on videos page but I can still click on
videos link and all that will happen
with the click is a refresh because I am
already on videos page my origin and
destination are same here so if I'm
representing world wide web as a
directed graph the way we just discussed
then we have a self loop here now the
next special type of edge that I want to
talk about is Multi edge and edge is
called a multi edge if it occurs more
than once in a graph once again we can
have a multi edge in both directed and
undirected graphs
first multi edge that I'm showing you
here is undirected and the second one is
directed now once again the question why
should we ever have a multi edge well
let's say we are representing flight
Network between cities as a graph a city
would be a node and we can have an edge
if there is a direct flight connection
between any two cities but then there
can be multiple flights between a pair
of cities these flights would have
different names and may have different
costs if I want to keep the information
about all the flights in my graph I can
draw multi edges I can draw one directed
edge for each flight and then I can
label
and edge with its cost or any other
property I just labeled edges here with
some random flight numbers now as we
were saying earlier selfloops and multi
edges often complicate working with
graphs the presence means we need to
take extra care while solving problems
if a graph contains no self-loop or
multi edge it's called a simple graph in
our lessons we will mostly be dealing
with simple graphs now I want you to
answer a very simple question given
number of vertices in a simple graph
that is a graph with no self loop or
multi-edge what would be maximum
possible number of edges well let's see
let's say we want to draw a directed
graph with four vertices I have drawn
forward DC's here I will name these
vertices v1 v2 v3 and v4 so this is my
set of vertices number of elements in
set V is 4 now it's perfectly fine if I
choose not to draw any edge here this
will still be a graph set of edges can
be empty nodes can be totally
disconnected so minimum possible number
of edges in a graph is 0 now if this is
a directed graph what do you think can
be maximum number of edges here well
each node can have directed edges to all
other nodes in this figure here each
node can have directed edges to 3 other
nodes we have 4 nodes in total so
maximum possible number of edges here is
4 into 3 that is 12 I have shown edges
originating from a vertex in same color
here this is the maximum that we can
draw if there is no self loop or
multi-edge in general if there are n
vertices then maximum number of edges in
a directed graph would be n into n minus
1 so in a simple directed graph number
of edges would be in this range 0 to n
into n minus 1 now what do you think
would be the maximum for an undirected
graph in an undirected graph we can have
only one bi-directional edge between a
pair of nodes we can't have two edges in
different directions so here the maximum
would be half of the maximum for
directed
so if the graph is simple and undirected
number of edges would be in the range 0
to n into n minus 1 by 2 remember this
is true only if there is no self loop or
multi-edge now if you can see number of
edges in a graph can be really really
large compared to number of vertices
for example if number of vertices in a
directed graph is equal to 10 maximum
number of edges would be 90 if number of
vertices is 100 maximum number of edges
would be 9900 maximum number of edges
would be close to square of number of
vertices a graph is called dense if
number of edges in the graph is close to
maximum possible number of edges that is
if the number of edges is of the order
of square of number of vertices and a
graph is called sparse if the number of
edges is really less typically close to
number of vertices and not more than
that there is no defined boundary for
what can be called dense and what can be
called sparse it all depends on context
but this is an important classification
while working with graphs a lot of
decisions are made based on whether the
graph is dense or sparse for example we
typically choose a different kind of
storage structure in computer's memory
for a dense graph we typically store a
dense graph in something called
adjacency matrix and for a sparse graph
we typically use something called
adjacency list I'll be talking about
adjacency matrix and adjacency lists in
next lesson ok now the next concept that
I want to talk about is concept of path
in a graph a part in a graph is a
sequence of vertices where each adjacent
pair in the sequence is connected by an
edge I'm highlighting a path here in
this example graph the sequence of
vertices a B F H is a path in this graph
now we have an undirected graph here
edges are bi-directional in a directed
graph all edges must also be aligned in
one direction the direction of the path
part is called simple path if no
vertices are repeated and if what
disease are not repeated then edges will
also not be repeated so in a simple path
both vertices and edges are not repeated
this path a bfh that I have highlighted
here is a simple path but we could also
have a path like this here start vertex
is a and end vertex is D in this path
one edge and two vertices are repeated
in graph theory there is some
inconsistency in use of this term path
most of the time when we say path we
mean a simple path and if repetition is
possible we use this term walk so a path
is basically a walk in which new
vertices or edges are repeated of walk
is called a trail if what disease can be
repeated but edges cannot be repeated I
am highlighting a trail here in this
example graph ok now I want to say this
once again walk and path are often used
as synonyms but most often when we say
path we mean simple path a path in which
vertices and edges are not repeated
between two different vertices if there
is a walk in which vertices or edges are
repeated like this walk that I am
showing you here in this example graph
then there must also be a path or simple
path that is a walk in which what
disease or edges would not be repeated
in this walk that I'm showing you here
we are starting at a and we are ending
our walk at C there is a simple path
from A to C with just one edge all we
need to do is we need to avoid going to
be e H D and then coming back again to a
so this is why we mostly talk about
simple path between two vertices because
if any other walk is possible simple
path is also possible and it makes most
sense to look for a simple path so this
is what I'm going to do throughout our
lessons I'm going to say path and by
path L mean simple path and if it's not
a simple path I will say it explicitly
our graph is called strongly connected
if in the graph there is a path from any
vertex to any other vertex if it's an
undirected graph we simply call it
connected and if it's a directed graph
we call it strongly connected in
leftmost and rightmost graphs that I'm
showing you here we have a path from any
vertex to any other vertex but in this
graph in the middle we do not have a
path from any vertex to any other vertex
we cannot go from vertex C to a we can
go from A to C but we cannot go from C
to a so this is not a strongly connected
graph remember if it's an undirected
graph we simply say connected and if
it's a directed graph we say strongly
connected if a directed graph is not
strongly connected but can be turned
into connected graph by treating all
ages as undirected then such a directed
graph is called weakly connected if we
just ignore the directions of the edges
here this is connected but I would
recommend that you just remember connect
it and strongly connected this leftmost
or undirected graph is connected I
removed one of the edges and now this is
not connected now we have two disjoint
connected components here but the graph
overall is not connected connectedness
of a graph is a really important
property if you remember intra-city road
network road network within a city that
would have a lot of one-ways can be
represented as a directed graph now an
intra-city road network should always be
strongly connected we should be able to
reach any street from any street any
intersection to any intersection ok now
that we understand concept of a path
next I want to talk about cycle in a
graph a walk is called a closed walk if
it starts and ends at same vertex like
what I'm showing here and there is one
more condition the length of the walk
must be greater than 0 length of a walk
or path is number of edges in the path
like for this closed walk
that I'm showing you here length is five
because we have five edges in this walk
so a closed walk is walk that starts and
ends at same vertex and the length of
which is greater than zero now some may
call closed walk a cycle but generally
we use the term cycle for a simple cycle
a simple cycle is a closed walk in which
other than start and end vertices no
other vertex or edge is repeated right
now what I'm showing you here in this
example graph is a simple cycle or we
can just say cycle a graph with no
cycles is called an acyclic graph a tree
if drawn with undirected edges would be
an example of an undirected acyclic
graph here in this tree we can have a
closed walk but we cannot have a simple
cycle in this closed walk that I'm
showing you here our edge is repeated
there would be no simple cycle in a tree
and apart from tree we can have other
kind of undirected acyclic graphs also a
tree also has to be connected now we can
also have a directed acyclic graph as
you can see here also we do not have any
cycle you cannot have a path of length
greater than 0 starting and ending at
the same vertex or directed acyclic
graph is often called a dag cycles in a
graph caused a lot of issues in
designing algorithms for problems like
finding shortest route from one vertex
to another and we will talk about cycles
a lot when we will study some of these
at one still go our thumbs and coming
lessons for this lesson I will stop here
now in our next lesson we will discuss
ways of creating and storing graph in
computer's memory this is it for this
lesson thanks for watching
in this presentation we're going to look
at diagraphs and relations so consider
the problem T is the set comprised of
the sets a and B a B and a B and C R is
a relation to find on T as follows X or
Y if X is a subset of Y where x and y
are elements of T draw the relationship
diagraph of RNs and state whether or not
r is reflexive symmetric or transitive
so what we're going to do is draw the
diagraph and go from there so first off
we have the four vertices here now it's
very important to realize that we have
four distinct vertices here for each of
these subsets for each of these sets so
this is vertex one this here is vertex 2
this here is vertex 3 and this here is
vertex 4 and there we have them there
now R is a relation defined on T as
follows X are Y if X is a subset of Y
just to be clear that means subset now
consider first off let's do consider the
example a a is a subset of a and B so
we'll have an edge going from 8 a and B
and also a is a subset of ABC so it is
going to have an edge going there
also a is a subset of itself so it is
going to be a age going there like that
that leads back on a and in fact for
every vertex it is there's going to be
such a loop
okay because everything every set is a
subset of itself now let's look at B
here as well B is a subset of a B so
narrow and pointing in that direction
and B is a subset of a B and C so again
an arrow pointing in that direction a
and B is a subset of a B and C and that
accounts for all the relations I'm going
to change the color a bit actually just
to make it a bit more easier to look at
so I'm going to make the vertices green
so the next question is are these
relations reflexive well in each case we
have to check out the following those X
or X hold for example is something a
subset of itself and as I just stays
there previously that all in all three K
in all four cases we have a the size
being a subset of itself we have these
arrows pointing back towards themselves
so yes it is reflexive so that's the
first question done now the next
question is is it symmetric well if it's
symmetric and we would have initially X
or Y and symmetric
if Y are X now let's consider what this
means here if X is a subset of Y that it
would symmetric if Y is a subset of X
now in that case that does not hold
because for example a is a subset of B
or C a is a subset of a and B but a and
B is not a subset of a so it is not
symmetric and in this particular
instance so that is the second one it's
not a symmetric lastly we're asked to
determine if it's transitive
so transitive works on the following
basis so we have X or Y and Y are z 4
vertices x y&amp;z it is transitive
if
we could start say X or Z now in this
case yes it is transit why would I say
that
for example a is a subset of ABC but we
can also say as far as the following a
is a subset of ABC or is a subset of a
and B which itself is a subset of ABC so
it actually works in that basis as well
just to be clear about that
letting a correspond to X Y correspond
to a B and that correspond to ABC X is a
related to Y because what X is a subset
of Y and cars more furthermore X is
related to Z because X is a subset of Z
and that concludes our presentation
all right and welcome back to our next
module in the power bi custom visuals
course and this module we're going to be
looking at the force directed graph now
the forth directed graph is developed by
Microsoft and this is a really
interesting one that allows you to look
at relationships between different
entities that you have so say for
example you wanted to analyze how many
emails that you have between coworkers
if you could get that email data in
which you do have the ability to do with
power bi you could then see what kind of
relationships you have between each of
your co-workers and your emails so the
thicker the line that you have would
indicate the more or the stronger the
relationship that you have between the
two entities so maybe you ain't email
between yourself and one of your
co-workers Jim most often and then maybe
for me I do a lot of strange things like
I email myself a lot mainly when I think
of interesting things and I want to know
or remember at work I email myself and I
might see a strong relationship between
myself and so you can take that kind of
data and use it inside the force
directed graph to be able to see what
kind of relationships that you have
alright so let's go ahead and take a
look at how you can use the force
directed graph and where to go download
it and how to get started with it
all right so your first step as always
is to go to the power bi custom visuals
gallery which you can find by going to
visuals power bi comm and as you scroll
down in the gallery you'll find the
force directed graph right here and
you're gonna go ahead and select the
force directed graph and download the
visual now I've already downloaded it so
I'm not gonna bother doing it again but
this is where you can go find it
now just to point out here we have
looked at a ton of these their visuals
now at this point this one if you want
to compare it to one of the other ones
is kind of but not completely similar to
the chord graph that we saw before the
chord chart and the way that it's
similar is that it shows relationships
between two entities that's the main way
that it's similar to the chord all right
let's go ahead and now take a look at
once now that we've got the visual
downloaded let's go over to the power bi
desktop and show how to use it alright
so the first thing I want to do with you
is to go ahead and get the data that
we're going to be using for this example
now to set the stage for this one the
data that we're gonna be using is my
blog data at least pretend blog data and
we're gonna be looking at where people
started on my blog and what did they
click to next meaning which are the blog
posts that are most interesting for
folks and where do they start at before
they actually clicked on anything so
let's go ahead and go up to the get data
section here and the power bi desktop
and we're gonna select excel as a source
just to make this simple for us and
you're going to find this is a available
where you can click below to download
the data source but the one that we're
going to be using today is gonna be
called log visits so I'll select blog
visits here and click open
now once the navigator pane opens up you
should see the spreadsheet that we're
going to be using called page visits and
we'll see each of the location so this
is the source location where the user
started which is either on my home page
or the archive section or they might
have also started on the about me page
and then we have which blog they went to
from there I also have the number of
views so how many times they viewed a
particular blog and which are my most
popular blog so it's like the hyper-v
blog is most popular all right so I'll
go ahead and now and hit load I don't
need to make any changes to the data so
I'll hit load to take this and add it to
my data model and we should see once
that's done loading that it shows up in
the field list on the right hand side
all right so my next step then is to go
ahead and import the visual that we want
to use for this example which is the
force directed graph to import that
visual you'll go to the visualizations
section here and select import from file
and import a custom visual
go ahead and hit import past the little
warning sign here and we're going to
select the custom visual here that we
downloaded just a moment ago called the
force graph so I'll select the force
graph and hit open all right so it's
successfully imported that once I hit OK
you'll see it now show up in my
visualizations list and before we use
that though I want to show you a little
bit of the data just by bringing it into
a table so I'll select a table here
first and from there we'll go ahead and
bring in our source or target in our
number of views into the report and we
can easily increase the text size on
that table just by going over to the
format section here and bumping up the
text size a little bit so you can read
the data a little bit better there we go
alright so you can see what kind of data
we're looking at this has the source
that we started at which could either be
my home page or my about me page and
then where do people go after the fact
and then the number of views that they
had for each now what I'd like to do is
take this data that you've seen what it
looks like a little bit and go ahead and
put it into the force directed graph
which we just import at a moment ago
right here so I'll select the force
directed graph
and you can see that it does change it
does indeed change my table into a force
directed graph here now we're gonna add
and change a lot of things with this but
just to point out to you how this thing
works as you grab things you can move
them around if you wanted to you can
kind of play around with the placement
of these items I can move them around
shift them around if I'd like you can
also hover above any one of these to get
a tooltip that hovered that pops up and
tells you what the source and what the
target was and what the total number of
views are so it's nice that you can see
the relationships again the thicker the
line is the stronger the relationship
between the two is that's the number of
views is represented by that but there's
a lot of other things that we can do in
here as well let's let's show you a few
of the things that you can do and modify
if I want to modify this visual a little
bit more you can select the chart or the
graph here and go to the paintbrush or
the format item here and we're going to
work our way from the top down going
through and showing you the different
types of ways you can customize the
force directed graph let's start by
looking at the data labels section here
for a moment so I'm going to expand data
labels and inside the data labels
section here you can see that you can
indeed increase the text size of the
data labels that's the text you can see
it increasing as I make the adjustment
here in the format section you can also
change the color of the labels if you
wanted to rather than meeting that gray
color you can make it a more clear black
if you wanted to and that's looking kind
of funky there because the movement I'll
flip it back over to the gray alright so
you can play around with those things a
little bit that's what's underneath the
data label section you can also if you
go down to the links section this is
where you're allowed to actually modify
how the visual looks from the the arrows
or the links between each of the
entities that we have here so for
example if you wanted to you can turn on
this arrow capability which shows you
all of these are kind of outgoing values
meaning I don't have anybody going from
a blog to the home page everyone's going
from the home page out to a blog and
that's what the arrows are representing
there you can also turn on the labels so
if you flip on labels here what that
will do is actually show you the values
on top of each of those arrows or each
of those entity relationships and it'll
show you how many views that we've had
for each so you can see indeed here
there's 592 showing for this one here if
you hover above it above it you'll get a
tooltip that shows that same number
alright next you can also do a few
things here with the links so again the
links are the lines between the two
indicators I'm going to turn off the
arrow for a moment we don't need
but what I will show you here is how you
can change the color so you'll notice
here that right now it's set to
interactive interactive means that it's
based off of the data elements that you
have so if I go back over to the field
well here if I change the link type if I
have another field in here that
differentiates the different
relationships I have and I add it to the
link type that would actually change the
color of the lines between them now if
you don't have any field to put in the
link type like meet me in this case I
don't I can actually manually change the
color here by going underneath this
color property here underneath links and
I can change it to by weight for example
and I can adjust it so that I can see
that the ones that have the this color
here is actually gonna have a different
color that basically the ones that are
closer to that color have the most
values associated with them there's a
few other things here you can also
change the formatting or the display of
those numbers and again we have those
numbers that are showing right now
because we turned on the labels you
could change those values so if you
wanted to see it in millions for example
that's kind of a bad choice here because
now it's showing all of them is zero
million really Auto was the best choice
there if you have the data labels on you
can also change turn off the thickness
so if you don't want to see the
thickness adjusted at all based on
something you can turn off the thickness
and it's just plain lines here basically
so you have some ability to modify that
there as well I'm gonna turn the
thickness back on I think that would
make sense
all right the next thing that we're
gonna look at then is we'll go and work
our way a little bit farther down you'll
see underneath a node section here that
you can actually turn on an image for
each node so right now the node is kind
of the endpoint that we have at each of
the different categories that we have
and if we wanted to we can turn on an
actual image to appear there and by
default it kind of shows this little
Home image but you have the ability to
actually change it from that home image
to an image of your choosing and I
happen to have an image here for us to
use and I'll expand this to you so you
can see it it'll also be in our
follow-up blog but here is the you can
pop of course plot pause the video if
you'd like to see this and type it out
but we'll have this available for you to
find somewhere else but you can get that
URL and plug that in and notice what
happened when I use that URL instead is
now I can see the image that's being
based off of it often each node is based
off of that URL and not just the little
indicator that is there by default you
can also change a few other things here
if you want to adjust the length of the
name that's used for each node so the
labels on each node right now it's set
to 10 character Lang
but you can adjust that and say well
really I want to see 20 character links
and then gives you a little better idea
of what each of those blogs are now you
want to be careful with that of course
if you go too long like say 200 then it
gets a really messy to read here it's
kind of difficult to understand what's
going on so I'll leave it at something
like 20 all right then the next section
here that you have is the size section
underneath the size section this is
where you're able to adjust how much of
the size or how much of the canvas it's
actually taking up so you can see here
the outline that we have is the the
graph should be taking up this entire
section here but it's not and that's
because of the size property the size
property has a setting in here called
charge and based on what you set in the
charge section it'll take up more or
less of the space on the chart area or
the graph area and so what I might want
to do is adjust this to something like
negative 40 and you'll see it takes up
much more space in the design surface
and it's actually using more of the
space that we have available to it now
when you do this you might also want to
change things like the data label size
or the node label size you can adjust
some of those things based on how much
space you're giving it inside the graph
area okay so kind of a nice thing to do
here gives you some neat capabilities
now one of the things that's really
common to do with the forest graph is to
bring in some of the form of a filter to
be able to work on and by the way before
we do this I should mention there are
all of the typical types of formatting
that you can do on here if you wanted to
turn on a title you of course can do
that but I'd have to give it some kind
of name here I can call this my force
graph example and so that's going to add
a label up here in the top and you can
Center that and increase the text size
so you have the ability to do things
like that just like you can do in any
other chart that we've looked at you can
can add a border around this if you'd
wanted to that's that's fine all that
same things these last five properties
here exist in just about every one of
the visuals that you'll use but the last
thing I want to show you the third
common to do with the force graph is to
bring in some form of a filter to use
with it so for example let's say we want
to bring in a slicer I'll select a
slicer here and I'll tell it that I want
to do a slicer based on the source so
where the user came from and I'll
increase the size of this so we can read
it a little bit better
let's go underneath the item section
here and bump up the text size a little
bit so we can actually read that and
then what's nice about this is now it
allows you to actually filter down the
force graph and use it a little bit more
cleanly so for example if I wanted to
see just everything that came from
the homepage I can select a home page
option here and you'll see now it's
focused me in on just that area or if
you wanted to see everyone that came
from the about me page I can select just
about me
and now we're seeing just the about me
page you could of course multi select
those and you see both of them again so
both of them appear there but using some
form of a filter really makes it easier
to be able to clearly view this data and
it makes a very interesting way of
viewing the chart
so I recommend whenever you use the
force graph it to also have some form of
a filter to really filter down the data
especially when you have many different
nodes that you're working with here
alright so that is it for the force
graph I hope you guys enjoyed this one
and we look forward to showing you our
next custom visual
so we now turn our attention to a very
interesting and important class of
graphs called directed acyclic graphs or
DAGs so to motivate this class of graphs
let's look at a problem where we have a
bunch of tasks to perform with some
constraints suppose we are going on a
foreign trip then of course we need a
passport we need to buy a ticket we
require a visa probably we want to buy
some travel insurance we probably need
some foreign exchange as well and
perhaps you want to buy some gifts for
our hosts now these tasks are dependent
on each other in certain ways without a
passport you cannot buy a ticket
nor can you buy any travel insurance for
the visa you need both the ticket and
the insurance to be available and
without a visa the bank will not give
you foreign exchange and finally you
would not like to buy gifts for your
hosts unless the trip is confirmed so
unless you have all these things
including the visa in hand you do not
want to invest in the gift so our goal
is that given these constraints in what
sequence should we perform these six
operations getting a passport buying a
ticket getting insurance getting a visa
buying foreign exchange and buying gifts
for our hosts what sequence should we do
it so that whenever we want to approach
a task the constraints that are required
for that task are satisfied so as you
would expect we will model this using a
graph in this graph the vertices will be
the tasks and then we will have an edge
pointing from t1 to t2 if t1 must come
before t2 in other words t2 depends on
t1 you cannot do t2 unless t1 has been
completed so as an example getting a
passport must come before buying
netiquette so t1 is getting a passport
t2 could be getting a T similarly
you must by have a visa before you buy
foreign exchange right so there will be
an edge from getting a visa to buying
foreign exchange
so if we look at the constraints that we
wrote this is the graph that we had
right so we add a constraint which says
you need a passport to buy a ticket you
need a passport to buy insurance you
need both a ticket and insurance to get
a visa so there are two constraints
pointing to visa then you need a visa to
buy foreign exchange and finally you
said we will buy a gift only if the trip
is confirmed and at some point at this
stage when all these operations are done
we can assume the trip is confirmed
because nothing is blocking us getting
on the plane right so this is a graph
that we have and now our goal is to
sequence these six operations in such a
way that whenever we want to perform a
task whatever it depends on is already
been done so we can see that you need a
passport to do anything so we always
need to start with getting a passport
now there is no dependency between
buying a ticket and buying insurance as
per the constraints we have so far so
after a passport you can either buy a
ticket first and then buy insurance or
you can buy insurance first and then buy
a ticket so there is a different
ordering possible which does not violate
the constraints on the other hand for a
visa you need both so visa must come
after both ticket and insurance but
again having done your visa then there
is no constraint between buying the
foreign exchange and buying gifts so you
could do the foreign exchange before the
gift or the good for the foreign
exchange so there are in this particular
example there are two possible ways of
reordering the ticket and the insurance
and there are two possible ways of
reordering the gifts on the foreign
exchange so overall there are four
different sequences which are compatible
with these constraints so this class of
graph is an important class and it has
two important features one is of course
it is directed because these
dependencies are from one task to
another task it is not a symmetric
dependency and there are no cycles so if
you add a cycle it would mean that a
group of tasks depend on each other so
there is no way to start because each
task depends on something else in the
cycle so you have to break the cycle
somewhere in order to get started but
you can't break it anywhere because each
task depends on something else in the
cycle right so this graph will have
directions on the edges and there cannot
be any
in this graph so we call such a graph a
directed acyclic graph and so a directed
acyclic graph is just a directed graph
in which there is no directed path from
any vertex back to itself so if I start
at any vertex V it should not be the
case that I can follow a sequence of
directed edges in the same direction and
somehow come back to B so this should
not be there so they should not be any
cycle we abbreviate the named directed
acyclic graph as back so very often for
simplicity we will call these graphs
bags so the problem that we had
addressed in our example is that we are
given a set of tasks and we want to
write them out in a sequence which
respects the constraints the constraints
are nothing but the edges so in general
we are given the set of vertices these
are our tasks abstractly 1 to n and we
want to rewrite out 1 to N in a such a
way that the constraints are respected
what this means is that we will write
out a sequence of numbers which is a
permutation of 1 to N in such a way that
whenever there is any constraint of the
form JK that is that there is an edge JK
then in the enumeration that we have
performed J must come before K right so
it cannot be that we have to do before K
according to our Penn State but in the
sequence that we produce K happens
before G so that the C the order of
vertices in the final sequence must
respect the constraints given by the
deck so for various reasons this is
known as topologically sorting the deck
so the first observation is that if the
directed graph had a cycle then you will
not be able to topologically order it
because if it had a cycle then for
instance supposing J and K are vertices
on the cycle then you will have a path
from J to K and apart from K to G now it
is easy to see that the topological
ordering constraint extend two paths
that is if I have J before K as an edge
I know that J must appear before K in
the final sequence also it was the path
from J to K then there is a sequence of
dependencies from J to K so J must
appear before T now if I have a cycle it
says that Jamis come before
and Kay must come before J so there is
no way to break this this dichotomy so
we will end up with a situation where we
cannot order this set of tasks to
respect the constraints so the graph has
cycles then it is clear that there is no
toka logical order impossible so what we
claim however is that for DAGs
that is if there is no cycle that graph
is actually a cyclic then we can always
order it topologically so the strategy
is to order the vertices as follows you
first list all the vertices which have
no dependencies in our earlier example
the vertex which had no dependencies was
getting a passport we did not need to do
anything before getting a passport so we
can do that first now once we have
knocked off the dependency you see any
vertex which all its dependencies are
now satisfied and then we can numerate
that so we can systematically list out
vertices with no incoming edges then
vertices all of those incoming edges
have already been accounted for around
enumeration and so on so to formalize
this notion we introduce some
terminology so recall that for an
undirected graph we use the term degree
of V to refer to the number of vertices
connected to me so if we is connected by
an edge to four vertices then we would
say that the degree of V is 4 now since
we have a directed graph we have
directions on these edges we have some
edges which are coming in and some edges
which are going out so we separate out
the degree into the in degree and the
out degree so the in degree is a number
of edges pointing in to be directed into
V the out degree of V is the number of
edges pointing out of so our first claim
is that every dag has at least one
vertex within degree 0 in terms of our
example the vertex within degree 0 is
something which has no dependencies
nothing it does not depend on anything
with nothing pointing into it now how do
we prove this well supposing we start
with any vertex V such that it has in
degree greater than 0 since it is in
something pointing into it then it must
have some
edge coming into it so let us call that
v2 now supposing this does not have in
degree zero then it must also have
something pointing into it so then I get
a third vertex so in this way if I keep
finding that the vertices I am
encountering have in degree greater than
zero
eventually I must enumerate all the
vertices in my graph now if there is
still not the case that the N through
vertex
if there are n vertices the nth Witek
still does not mean degree zero then it
must have an incoming edge but that
cannot be from a new vertex so it must
point from one of the existing vertices
which I have already seen before right
so therefore if I have a continuous
sequence of vertices all of which are
pointing to each the previous one with
in degree not equal to zero then I will
end up with a cycle but this is a
contradiction because we have an acyclic
graph right so in any directed acyclic
graph they must be at least one vertex
within degree 0 which corresponds to a
task with no dependencies from where we
can start our enumeration of the tasks
so this is a more elaborate version of
the algorithm that we described earlier
so we pick a vertex within degree 0
recall that such a vertex has no
dependencies now we enumerate it because
it now has its available for enumeration
and then we delete it from the graph so
when we delete a vertex within degree 0
from a graph so supposing we have a dag
like this then so supposing we pick this
one and we delete it then clearly what
remains is a dad because it is still
directed and we have not introduced any
cycle so it was already IA cyclic and by
deleting an edge we cannot introduce a
cycle so clearly incident so we can
apply the same criterion this new dak
must also have at least 1 degree with
vertex within degree 0 so we can
numerate that and keep going right so we
keep enumerated vertices within degrees
0 until the dag becomes empty each end
vertex will enumerate we will delete
from the tack so let us apply the
strategy to this tack
so we first begin by labeling every
vertex by its in degree so in red we
have indicated the integrative every
vertex so for instance one and two have
no incoming edges so they are in degree
zero vertex three has two edges coming
in so it hasn't agreed to vertex eight
has four edges coming into it as in
degree four and so on now we have to
pick a vertex of in degree zero
enumerate it and eliminate it so we have
a choice between one and two so let's
suppose we start with one so we start
with one we eliminate it and now when we
eliminate it we also eliminate the edges
going out of it so the edge is coming in
two three four and five will reduce by
one because the vertex one is gone so
they're just coming in to them reduced
by one they're in degrees also reduced
by one so what happens when we eliminate
one is that we enumerated and we reduce
the in degrees of three four and five
from 2 1 1 2 1 0 0 so recall that before
that the in degrees were 2 1 and 1 now
these edges which are coming in to them
have been deleted right so when we
delete this we also delete the incoming
edges so now we have 1 0 0 now we have 3
choices to the original one which are
ending 0 and we have now two new
vertices 4 &amp; 5 which correspond to tasks
if you want to call them whose
prerequisites have been completed so
task 1 was a prerequisite only
prerequisite for for task 1 was the only
prerequisite for 5 it has been completed
so 4 &amp; 5 are now available so we can
choose any of 2 4 &amp; 5 it doesn't matter
so let's suppose we choose 4 then again
these two edges will go so this will
reduce to 1 and this will reduce to 3 so
we can do that we eliminate 4 and reduce
the in degree of 6 from 2 to 1 till
degree of 8 from 4 to 3
now perhaps minton decide to eliminate
thus 2 so when you do for us to then the
in degree of 3 reduces and the in degree
of 8 again reduces so notice that 8
still has to pending in 2 requirements
namely 5 &amp; 7 so it cannot be done yet
but 3 &amp; 5 are available so perhaps I do
5 so now it's less 1 and now I have no
choice the only tasks with in degree 0
is
three so then I do three so now I can
see that this is actually a the way it
is drawn is just a sequence I must do
three before six six before seven seven
before eight so I have no choice at this
point
I must enumerate it as three then six
and seven and then finally eight at this
point my graph is empty and I have
obtained a sequence of vertices which is
a valid topological ordering because
every pair of vertices which occur as an
edge in my original graph is ordered so
that the source of the edge appears
before the target ovh so let's look at
some pseudocode for the algorithm which
we just executed by hand so in this
particular algorithm we first start by
computing the in degree so in order to
compute the in degree we need to find
out how many for a vertex I we need to
find out how many J satisfy the property
that AJ I is equal to one because this
corresponds to an edge from J to I so in
an adjacency matrix this corresponds to
looking at the column containing I
because in the column containing I we
will have entries of the form a 1 I 8 2
I and so on right so we will have these
entries and we want to scan all of these
and then add up all the ones so we start
by setting integral equal to 1 in degree
I equal to 0 and then for every row J we
add AJ I
so it's either 0 or 1 and so we
therefore collect all the incoming edges
which point into is the in degree of L
now we start a humidity so we know this
is a dad so we know there is at least
one J within degree 0 at every point so
we choose any such J ok choose a J which
has in degrees 0 enumerated and when we
enumerate we want to eliminate it from
the graph rather than going and actually
modifying the graph itself we will just
work with in degree as a kind of
approximate version of that modified
graph so we first set the integral to
minus 1 for this particular vertex so
minus 1 means it cannot be in the graph
because you cannot have minus 1 it is
fine you can have at least 0 edges or
more right so this will effectively
means that J is not going to be
considered henceforth and now for every
outgoing edge from jail so wherever we
have J pointing to K we want to be
increment this because we are going to
eliminate the sage baby eliminating J we
eliminate the sage so for every K from 1
to n we scan all the outgoing neighbors
of J and if JK is an edge a JK is 1 we
reduce the in degree of K by 1 so what
is the complexity of the algorithm is
fairly easy to see that for this
adjacency matrix representation is N
squared as we saw initializing the in
degree itself takes time N squared right
because we have 1 outer loop from 1 to n
and then for each outer loop we have an
inner loop from 1 to n so this is an N
square and then if we when we enumerate
the vertices again we have an outer loop
which will enumerate every vertex once
ok and then for the inner loop we have
to enumerate or check all its neighbors
and in decrement it so we have 2 n
square roots and therefore this whole
thing takes order n square now we can as
we saw with BFS and DFS and if we use an
adjacency list we can be a little more
clever and we can bring down this time
to linear from n square we can bring it
down to order n + n so how do we do this
well we have these lists right so we
have lists
say 1 2 and for each of these we have a
list of its neighbors so if you go
through this as we said each edge in
this now this is a directed graph so
each edge is represented only once if
there's an edge from I to J it will
appear as an entry J in the list for I
right so if you scan these lists every
time you see a J we know there is an
edge pointing into J and we will
increment so we start off by setting all
the in degrees to 0 we scan all the
lists and every time you see an entry in
a list we increment its in degree so in
one scan of the list that is in time
order n we can find the in degrees now
we have the list of in degrees so we can
put all the in degree Burton C's into a
queue this makes it easy to find which
vertex to enumerate next ok so at the
end of the scan we have done an order M
scan to find all the in degrees now in
an
can we can put all the zero degree
vertices into a queue now we can do the
rest pretty much as we did before we
enumerate the first vertex in the queue
and then we go to its list which is now
explicitly available to us in this
adjacency list is outgoing neighbors
decrement it's in degree and if any of
those in degrees become 0 we can add it
to the queue so we know its it is to be
processed now so this becomes overall it
takes order M time two scans in this
takes order n time to start the queue of
and then this is a loop of order n where
across all the updates we will overall
update the in degrees order n times so
it is order n plus L so here is the
corresponding pseudocode okay so the
first step is to initialize the in
degree to 0 for every vertex in our
graph then we go through all the edges
so we do this by looking at each edge a
since a list for each vertex we look at
each neighbor IJ in the adjacency this
and we for each of these we increment
the in degree of J because we are
looking at edges pointing into J not
pointing out of height so this is
pointing into J will come in different
lists but as and when we encounter them
for each of them will account for them
and add one to it now we go through the
list one more time a list of vertices
and every time you see an integral 1 0
we add I to the queue and now we do this
loop till the queue becomes empty we
know there's at least one at every point
remember as long as the graph a tag is
not empty we know there is at least one
in degree I vertex into your vertex
within degree I is 0 so they must be it
must be in the queue because we added
them all originally to the queue and
each one we generate we will add to the
truth so as long as the queue is not
empty we take off the first element of
the queue then we look at its adjacency
list decrement the degrees of all those
vertices and if any of them happens to
now become in degrees 0 we added to the
so this becomes now a linear
implementation of topological sort using
adjacency list and a queue to process
the elements because the problem with
the reason why we need this queue is
that otherwise if we have to scan all
the vertices every time to determine
whether a vertex has become in degrees
zero then that becomes an order n scan
within this so it becomes order n square
again so we need the queue to make sure
that we don't spend time trying to
identify the next vertex to enumerate we
don't have to go through all the
vertices and check the in degrees when
we see the N degree zero we put it in
the queue so automatically it will come
out without having to do any further
check so it gets absorbed in this order
M work that we are doing
welcome to our 26th video with data
structures and algorithms let's do an
example of breadth-first search so we
have our graph here it's a little longer
than this okay so same same graph as we
used for depth-first search we're going
to need a queue to to do this and so we
are going to denote that we're going to
DQ from this left side and we'll NQ from
the right side or into the right side
you'll see what I mean
as we go along so we're just going to
start from one okay and we'll do things
numerically okay in order so we're going
to start here and the first thing we're
going to do is we're going to mark this
as 0 the distance from our starting
point is 0 so far right so 1 is 0
distance away from itself if that helps
so let's draw our queue at first okay
it's empty at first and we're going to
NQ 1 right so let's put one in the queue
okay and there we go
now what we do is we pop or not pop
that's the stack we DQ 1 and we will NQ
its adjacency list so 2 and 6 and like I
said we're going to do it in that order
numerical order so the next thing that
we have on here is 2 and 6 okay now we
have to write let's look at 2 so the
distance as well it will increase right
so this is 1 and this is 1 right there
one node away from the starting point so
2 is up next in the queue so we're going
to DQ 2 and we will NQ its adjacency
list which consists of 10 so now we have
6 and 10 you can kind of see how it's
how the queue is moving along and this
is a distance of 2 right away from
that's a starting point so keep going
here actually I need to be drawing these
as well so we're going to draw that we
took this path right here all right we
also have searched this path so far just
this one edge also this edge right we've
searched okay so now six is up next in
the queue so let's take six
let's dq6 and we will NQ its adjacency
list all right which is nine and eleven
so here right we have a distance of two
in a distance of two so now we have ten
at the front of the queue we have nine
and we have eleven okay so let's do that
okay and we're good so far
next up is ten let's do Q 10 and push on
it's a days adjacency list so we've got
nine eleven and thirteen has now been in
queued okay and that is a distance of
three away next up is nine
let's DQ 9 and NQ 12 this is a distance
of three so now our queue looks like
this 12 all right next one is 11 so
let's DQ xi and we will NQ 14 this is a
distance of three away so we have 13 12
and 14
okay now 13 is up next
so let's DQ 13 and NQ 15 which is now a
distance of 4 12 14 and 15
all right next is 12 and when we DQ 12
10 has already been discovered so we are
not going to end give anything we're
just going to take this off the queue so
now our key looks like this 14 and 15
okay next up is 14 right so we DQ 14 and
15 is already on the queue right it's
already been discovered so we just DQ it
and that's it so 15 is now in the queue
and so we DQ 15 and we NQ 18 right which
is the distance of five so now 18 is in
the queue and with DQ 18 and 17 is here
that's a distance of 6 so 17 is now in
the queue so when we DQ 17 right there's
nothing that's going to be include so
our queue is empty now so we are done
with our search from the first node ok
we still have other things going on that
have not been discovered yet so we need
to go to the next node
it's 2 now 2 has already been discovered
so we're not going to start there
anymore right we're done with that one
so let's try the next one 3 has not been
discovered yet you'd see that it's using
colors that the color would be white
right it has not been discovered yet so
we're going to have a new starting point
here with a distance of 0 and we were
going to put that into our queue right
so now 3 is in the queue let's DQ that
and we will push or we will NQ its
adjacency list this is both a distance
of 1 right so we have 5 and 8 I could
put into the queue when we pop when we
when we DQ 5
it has no adjacency list right it's
empty so we just DQ it and that's it we
have 8 here right same thing here
it's adjacency list has 10 but 10 has
already been discovered so now we DQ a
and there's nothing in the queue so we
finished up with our search from node 3
now let's search from the next node
which is node 4 so 4 has not yet been
discovered so let's give it a distance
of 0 we've got 4 in the queue and when
we dequeue this right we have 6 and 7 6
has already been discovered so we're
just going to in queue 7 so 7 will be in
the queue and when we dq7 we check its
adjacency list it's there's a 9 there
it's already been discovered right we'd
have a color of black or yeah it would
have a color of black in this case so we
DQ 7 and our queue is empty now you
start from 8 8 has already been
discovered so we're good 9 discovered 10
discovered 11 12 13 14 15 and 16 so 16
is our next one right so we in queue 16
okay and when we DQ 16 14 has already
been discovered right its adjacency list
so we do nothing so that's there and we
have finished our breadth-first search
welcome to our 25th video with data
structures and algorithms let's do an
example with depth-first search of
graphs so our legend over here it just
tells us what color each node is going
to be so if there's nothing next to it
right the color means that it's white so
all of these are white there's no
numbers out here on the outside if
there's a number and a slash then that
means it's gray and if it's a number and
a slash and another number then that
means that it's black and this would be
discovery time right D and this would be
finished time F so let's start at one go
let's start here and we're going to go
in order of the numbers okay as we
search through this so for one we have
two paths we're going to choose this one
first right because we're going to go in
order like I said so let's take this
path or actually sorry one so discovery
time one is one and this also means that
it's gray
can you see a slash so let's take this
path and we've discovered this at time
to slash now there's only one path from
here so let's take that draw all these
lines okay and we've discovered node ten
at time three so let's keep going
there's only one path out of ten so this
is a time for out of 13 there's only one
path so let's take that time five we
discovered this it's the fifth thing
that we've discovered and then we'll
take the only path from 15 to 18
discovered at time 6 and then again the
only path from 18 is to 17 and this is
at time 7 now there's nowhere to go
all right there's no other paths so you
have finished this at time 8
we'll go back to the last note there's
there's no other paths out of this so
this is finished at time nine same thing
up here time ten is finished back up to
13 time 11
let's scroll up no more out of 10 so
this is the finished at time 12 same
thing with two time thirteen and one has
another path so let's take that so we're
going to take this path and we've
discovered six at time fourteen now
there's two paths again remember we're
going to go in order so nine comes
before eleven so let's take this path
nine was discovered at time fifteen okay
the only path out of nine is to twelve
here discovered at time sixteen and this
path goes to ten but it's already been
discovered right it's a black node so
we're done there's nothing else to do so
this is finished at time seventeen go
back to nine finished at time eighteen
go back to six there's another path so
let's take that path okay I discovered
at time 19 just scroll down okay
let's take the only path 14 discovered
at time 20 and this path here right the
only path out of 14 is to 15 and this
has already been discovered so this is
finished at time 21 let's go back up
finished at time 22 we'll go back up to
6 this is finished at time 23 we'll go
back to node 1 there's no more paths out
of 1 so we have finished searching from
node 1 at time 24 now we go to the next
node right - it's already a black node
so we're done with that one
let's go to node 3 and start discovering
here
so this is discovered at time 25 and
again we're going to go in order so
let's go here right discovered a time 26
is node 5 no paths out of 5 so finished
at time 27 back here let's take the
other path from 3 to 8 discovered at
time 28 and the only path out of 8
points to 10 which has already been
discovered right it's already finished
so this one is now finished at time 29
and node 3 is finished at time 30 so I
would finish with that let's go to the
next node which is node 4 this has been
discovered at time 31 now all right
because it's white already there's no
number there we would take 6 first but 6
has already been discovered so let's
take 7 discovered at time 32 it points
to 9 right which is already been
discovered so this is finished at time
33 and then time 34 4 is finished so
let's see let's go to the next one 5 has
already been discovered 6 has already
been discovered 7 8 9 10 scroll down 11
12 13 14 15 all those that are
discovered 16 has not been discovered so
this is time 35 and it only has one path
out to 14 which has already been
discovered so this is done at time 36 we
go to 17 that's already been discovered
18 has already been discovered and we
have completed our search
hello friends welcome back in this
tutorial we will study about the
adjacency matrix of a digraph the
adjacency matrix of a digraph having n
vertices is up and cross and binary
matrix in which entry at at row and jth
column is 1 if and only if there is an
arc from vertex a to vertex G each
diagonal entry in the adjacency matrix
of a digraph is 0 for example see this
diagraph this is the adjacency matrix of
this diagraph order of this matrix is 4
cross 4 because there are 4 vertices in
diagraph ndaya graph there is an arc
from vertex 1 to vertex 2 therefore in
adjacency matrix of this diagraph entry
at first row and second column is 1
similarly there is an arc from vertex 1
to vertex 4 therefore in adjacency
matrix the entry at first row and fourth
column is 1 there is an arc from vertex
2 to vertex 3 therefore in adjacency
matrix the entry at second row and third
column is 1 there is an arc from vertex
3 to what X 1 they
for in adjacent C matrix the ant react
third row and first column is one there
is an arc from vertex four to vertex 3
therefore in adjacency matrix the ant
react
fourth row and third column is one thank
you very much
hello friends my name is Tushar and today
i'm going to talk about how to detect a
cycle in a directed graph. In another
video, I talked about how to detect a
cycle in undirected graph. Today, we're
going to talk about directed graph. So
the idea is to use a depth first search.
While doing a depth first search, we're going
to maintain three sets: a white set, a
gray set and a black set. White set has
all the vertices which have not been
visited at all
Gray set has all the vertices which are
being visited right now and black set
has all the vertices which have totally
been visited meaning that all its
children have also been visited.
so while doing depth first search, if we
encounter a vertex in a gray set, it means
that we found a cycle.
Why? because when a vertex is in gray set,
it means that its neighbors, or its
neighbor's neighbors or somebody in that
hierarchy is still being explored and
that vertex found a path back to the
vertex in the gray set, indicating that
there's a presence of a cycle.
So next let's try to apply this
algorithm on this graph here.
So first thing we do is we put all the
vertices in this white set here, then
we're going to continue to do depth first
search till either we find a cycle in this
graph or we have moved all the verttices 
from white set to black set. if
all the vertices have been moved to black
set, it means that there is no cycle in
this graph. So let's start from any
random vertex, so let's say we start
from vertex 1, so first thing we do is, we
move this vertex to gray set and
also in this DFS map, i am going to
indicate that one got introduced by null
because there is no parent of one because
one is a start point. Then we're going to
to explore neighbors of one. So one neighbor
of one is two. Two is not there in the black
set
Two is not there in the gray set
but two is in the white set so then
we're going to take two out of the white
set and then add it into the gray set
because now we're going to explore two and
also indicate here that two got
introduced by one. So now we're going to
explore neighbors of two. One neighbor of two
is three. Three is not in the black set. It means
that it's not visited. Three is not in the
gray set, so there's no cycle yet
but three is in the white set, so again we're
going to move three from white set to
gray set, indicate that three got
introduced by Two and explore neighbors of
three. Three has no more neighbors it
means that three is totally explored.
which means that we can move three from
gray set to black set.
remember black set has all the vertices 
which are totally visited.
now we're going to go back from three to
two and explore other neighbors of two but
has two more neighbors to be explored.
so we're going to move two from gray set
to black set and go back to one. One has one
more neighbor three to be explored but three is
already in the Black set. It means that
there is no reason to visit three again
so one doesn't viist three and at this
point
one has no more neighbors to be explored so
we'll move one to black set. Now at this
point we are done doing the DFS starting
with one so we have to go back to the
to the white set and see
that white set is still not empty
so pick another random vertex in the
white set. So let's say you picked four
and now we're able to do our DFS around
four, so we're going to move four from
white set to gray set
so now we'll explore neighbors of four.
so first we're going to say that four
got introduced by null because in DFS
four doesn't have a parent
so one neighbor of four is one but one is
already in the black set. So we're not
going to explore one again
so we're going to explore other neighbor
of four. So another neighbor of four is five
so five is not in the black set, five is not
in the gray set but five is in the
white set.
so again we're going to move five to gray set
because now we'll explore five and here i am
going to say that five got introduced by
four. Now
one neighbor of five is six. Six is not in black
set, six is not in gray set, six is in white set
so we're going to move six from
white set to gray set and say that
six got introduced by five and now we're going
to explore neighbors of six. One neighbor
of six is four. Four is not in the
black set but four is in gray set
it means that we found a cycle in
this graph. So to figure out that what is
that cycle, we can retrace our steps back.
So we know that 6 5 4, so edge 64 is in the
cycle then we go to six and see who
introduced six. So six got introduced by
five, so edge 56 is in the cycle and then
we're going to check who introduced five and
five was introduced by four so edge
45 is in the cycle and four is the point at
which we stopped, so this here is
indicating our cycle. Four to five, five to
six and six back to four. So now for
suppose that we did not have this edge 64
if we did not have this edge 64, in that case
what would happen was that six would
have no more neighbors to be explored, so we
would move six here and then five would have
no neighbors to be explored, so we move five to
black set and then four would have no
neighbors to be explored, so we would move four
to black set and in that case we will not
find any cycle. So if this edge six to four
does not exist
this graph should return false because
there is no cycle and if this edge 64
exists then this graph has a
cycle and it should return true.
The time complexity for this algorithm
is O(E+V) and the space complexity
is O(V). So next let's look at the code
for this algorithm.
main function here is hasCycle, it
takes in a graph. First thing we do is
we initialize whiteSet, graySet and
blackSet. Then we're going to add all
the vertices to white set. So white set
here has all the five vertices.
then while the whiteSet size is greater
than zero, it is greater than zero
we are going to take any random vertex
from the whiteSet, so let's say we got
one.
So in DFS now we're going to go into
DFS with current as one and passing
whiteSet, graySet and blackSet.
So in the DFS first thing we do is we
move the current which is one from
whiteSet to graySet because now
we're going to explore one. You're
going to get neighbors of one so. one neighbor
of one is two. So two is not in the black
set so first thing we check is two in
the blackSet and it's not which
means that two can be explored
Two is not in the graySet which means
that we haven't found a cycle
yet.
Then we're going to go into the DFS and
check and explore two.
So again we go into the recursion, this
with value neighbor and neighbor is two
so we come back to the top here
so first thing again we do is we move two
from whiteSet to graySet, then we're
going to explore neighbors of two.
So two has no neighbors
so what we're going to do is we're done
exploring two. So we're going to move two
from graySet to blackSet.
so two moves to black set and then
we're going to return false
so when we go back in recursion, we reach to
the point here where we went to the
recursion to the two and now the current
is one
so if DFS, so since we got false from two
it means that there is no cycle with
two involved so we're going to go back
to the top of the for loop and again
current here is one and now one has no more
neighbors to be explored
so we come out of the for loop and we're
going to move one from graySet to blackSet
and one is also going to return false.
so this returns false to this DFS here.
So again since this is false, so we
don't go into this if condition and
then we're going to go back to the top
of this while loop. Now the
whiteSet still has three more elements to go
so again we're going to randomly pick
another element. let's say we picked four
so then our current becomes four and
we're again going to go into
the DFS with four and see if we can
find cycle with four as a starting point.
so here first thing we do is we move four
from whiteSet to graySet
so here four moved from white to gray and
then we're going to explore neighbors of four
one neighbor of four is one, so we come to
this if condition but one is already in
a blackSet so we do nothing about one
and continue and look for another
neighbor, so another neighbor of four is five.
Five is not there in the black set, five is
not there in the graySet so
now we're going to explore five
and to do that, we go into the DFS. So now
our current is five. So first thing to do
is move five from whiteSet to graySet.
so this is what happens and then now we're
going to explore neighbors of five. So one
neighbor of five is six and six is not in
blackSet, six is not in graySet so again
we're going to do a DFS with six as the
current so we go back to the top of this
function. First thing we do is we
move six from whiteSet to graySet
so that's what happens here and now we're
going to explore neighbors of six. One
neighbor of six is four. So four is not in
blackSet but four is in graySet. Four
here is in graySet which means that
we found a cycle because four was being
explored. So this returns true immediately
so what this means that it returns true.
so six returns true to its calling
function and six was called from five so five
we return to the point here and this is
true so five returns true to its
calling function and five was called
from four, so we come to this point where
current is four and this since this is
true so four returns true to its
calling function which was here, so we
come to this point and since this is
true
this returns true. So since this graph has
a cycle it returns true saying that this
has cycle. So this is all I have to talk
about this algorithm, link to this
code, Java code and Python
code is in the description section of
the video. Please like this video comment
on this video, check out my facebook page
and check out my github link. Thanks
again for watching this video.
hey what's everyone thanks for checking
out this tutorial today I'm going to
show you how to do a forced layout graph
in d3 now these types of graphs are
probably a bit different than things
like line charts and bar charts and the
usual ways that you visualize data so I
wanted to just break this down for you
as simply as I possibly can so I'm going
to switch over to my browser now and
I'll walk you through this okay so here
on cloud9 IDE I have my environment and
it's just the HTML environment if you've
never set one up before you can just go
create an account at c9i oh it's free
you can sign in with github and all that
there's other ways to do it but this is
just a way I like to teach because it
kind of takes away the environment
configuration and worries about that so
just simple web stuff so the first thing
to do in this example is just kind of
setup our HTML document so put in my
doctype HTML set up my charset utf-8 I'm
going to actually put in some styling
info later we could have done this but I
just want to not have to come back and
type it so the way that force layouts
work is that they have kind of two
things nodes and links and a node is
something that's represents an entity
like a row of your data so if you have a
CSV file every row essentially could be
or probably is going to be a node for
you then you have links and ways that
they connect so that's what we're going
to draw and I'm going to add of two
different style options here so the
first one is just a class of node and
with that I'm going to put in a fill of
this kind of light gray and I'll give it
a stroke of white and a stroke with
of two pixels so you can set up whatever
you want these are just some kind of
examples here and then the next one is
the link so the line between them so
here we're going to do stroke and we'll
just do kind of a dark gray pound 777
and stroke width of two pixels as well
so again you can play with that change
it however you want all right I'm just
going to save this quickly as demo
simple layout dot HTML okay cool
all right so we got my style info now I
need to actually kind of build some
stuff so I'll create my body tag and I'm
going to reference d3 here so I just do
a script source equals and it's
whack-whack d3.js org slash D 3v3 minjae
s by the way version 4 is almost here if
it isn't already by the time this posts
so get ready for that I'm going to have
some stuff coming out on that because it
is quite different than how D 3 version
3 works so I want to make sure you guys
have everything you need to kind of
convert it and all that and I'm kind of
digesting all the changes right now
there's quite quite a big list ok so now
we're going to set up our variables are
so width will just do 640 for this
example height 480 and links so remember
there's two things here there's the
links and the nodes and the way I like
to do this is to basically just have one
data set because while I'm just going to
show you how to punch it in and type the
data in manually often what you'll have
is a CSV file in I'll even point you to
an example here some other code I have
that demonstrates that but for right now
what we're going to do first is just set
up the links and then we'll tease out of
that the nodes and remember the nodes
are the rows and the links actually are
the 4 from and the two the source and
the target is what it comes out to be
and that tells d3 in our layout how to
draw stuff between one node and the
other okay so for links this is going to
be an array so just set it up there and
somehow my autocomplete got turned off
in my environment so a lot of extra
typing all right so I'm going to set up
some
source and I'm going to do some fun game
of throwing stuff let's do the Baratheon
x'
and the target here would be the
Lannisters and close that out and
basically rinse and repeat let's do I
don't know maybe four of these five of
these let's actually just do three for
now so let's see a Baratheon and then
Stark and then how about lannister and
stark Baratheon and Lannister Baratheon
stark okay so we can kind of play with
that so there you go so I've got just a
couple example there's just three nodes
essentially that it'd be drawn with
links then from there what I want to do
is actually set up my notes so I'm going
to just create a simple variable of our
nodes basically give it a blank node so
there's really nothing in there then I
need to parse things out so here's where
it actually is some code that has to
parse out what are in the links and
create the nodes from that this is a
little snippet I found on one of Mike
Bosse socks examples so I'm going to put
an O there parse links to nodes and
we're just going to do link stuff for
each so it gives us a little loop here
and inside there we'll have a callback
function with the link so we're going to
reference it that way and what do I need
one more these guys and then that guy
again without autocomplete that sucks so
link dots or so we're going to take the
source from our links array above and
then we're going to do something we're
going to say nodes and then link dot
source so we're essentially going to add
that right because this is going to give
us that link that name Baratheon and
Lannister or nodes link dot source
equals name linked source so if we have
the same one repeated we're not going to
get extra nodes so this is just a little
kind of clever snippet here to add them
and not duplicate them now we're going
to link target so for each target in our
a list we do nodes and do link dot
target so now if you weren't in the
source but you were in the target we're
going to add you as well and basically
rinse and repeat the same stuff we did
before so nodes link target yeah I could
type pressures on when you're filming
and that equals link that target as well
so basically the idea there again is
that if these already exist update them
or you know it's good don't worry about
it otherwise Adam so that's how we're
going to actually parse out our links
into our nodes so we have both of our
data structures and d3 wants to kind of
different data structures here of course
you could have things more complex but I
like to keep them simple because there's
enough complexity in how this stuff
works to begin with so I want to keep it
as simple as possible now we just need
to add our SVG to our body so this is
when we actually start to do the d3
stuff and we're going to do var SVG
equals D 3 dot select body dot append
SVG so this gives us our place to draw
stuff instead of some attributes width
is the width that we specified above
height is the height that we specified
above good to go okay now let's create
our force layout so we get to use the
force and if you watch my Pluralsight
course I abuse that term so apologies in
advance so we set up d3 layout for so
this is the actual constructor that
creates it and then we need to specify
all the parameters so the first one is
size give it an array of width comma
height then nodes now this is where we
actually pass in our data set so you'll
see a lot of examples online where they
just pass in a separate data set but
here because we created it a little bit
differently we're actually going to
devalue 'z and nodes so inside of the
nodes array basically the values that
are in there and they're just each just
like the links one kind of a flat data
set the links are good we just pass
those directly in so we specified the
nodes and the links
now we have something here called on tik
and this is when the force layout
renders and then you do something in it
I like drag something around or even
just hovering or clicking or anything
any of those things that happen this
this function will execute here so you
need to specify that so then we have
link distance and I just put 300 here
link distance is how far apart the nodes
are in my course I go deeper into things
like charge and gravity and link
strength and all these other things but
for now just don't worry about it let's
just keep it simple and then we actually
have to tell it starts this is a like
you know how the actual layout starts to
render so we've got our fourth layout
now we've got now that that's created we
need to add our links and then our nodes
so we'll do VAR link equals SVG dot
select all and we're going to do dot
link we haven't added in yet but if we
did we would get them then we pass in
our data so data and we got our links
enter this is what actually binds the
data in that links array to the SVG it's
kind of one of the main things about d3
then we're going to append a line
there's other ways to do this like if
you wanted a curved line which is common
you actually have to append a path which
is a way to draw different types of
shapes or different kind of polygons in
d3 or an SVG rather so you could do that
there separately and there's other
examples online as well as my course I
go deeper into it for here though let's
just add it like that then we're going
to add a class of link so this way we
get our CSS styling okay cool so links
are set up now it's the nodes turns
nodes this turns is so node equals SVG
dot select all similar to what we did
before this time dot node dot data and
here it's actually me force dot nodes
it's just an easier way to reference it
because the nodes are already in the
forest layout enters to bind it and now
we're going to append this time a circle
so we're giving a getting a SVG circle
out of this
specify the class of node and I'm also
going to specify the radius here so the
how big the actual circles are I'm do
the width of the SVG times 0.03 you can
adjust that and of course that could be
more dynamic all right good to go
now we need to create our tick function
so what actually happens when something
in the individual do function tick you
get this eeper ammeter which has things
like the position and all that kind of
jazz we're actually not going to really
use that but it's just good to have in
case you want to modify this so we need
to specify for the node the C X and the
C Y so the C X is the relative x
position of the node so we'll have a
function here and this is part of the d3
stuff as well and in that function we're
going to return the actual D dot X all
right got that one then oops
autocomplete decided to start working
now we'll specify the C Y and sim as
before function except we're going to do
return D Y all right that's good for our
nodes with the exception of call and
we're going to add forced drag so with
this one that's actually going to let us
drag things around in the VIS which is
really cool it's part of the fun stuff
with forced layouts it's funny - I may
be I'm the only one that talks about
four slats being fun but they're just
they seem really cool ways to visualize
data and they kind of tell stories in a
different way so I like them for that
reason so now for the links as things
dragged around what we're going to have
to do is actually adjust their starting
and ending positions and because a link
is a line and it has two points
essentially an x1 and a y1 think back to
your calculus days using your your
calculator there and in your college
class so basically similar to above with
some exceptions so we're going to do
return d source x
and I'm actually just going to copy this
save some typing and so x1 and y1 is the
beginning and so it's going to be
sourced x and y and then x2 and y2 are
the ending points so it's going to be
instead of source it's going to be
target
close out our script tag and we should
be good to go let me just go ahead and
save this bad boy and hit preview don't
we got an error where is it this is kind
of nice because I get to show you how I
troubleshoot errors I opened it up in a
new tab there and then I hit inspect and
it'll give me the JavaScript console
oops I had an extra parenthesis there on
line 37 so back over here let me go I
don't think I have the line numbers on
there we go I see and if I did I would
have known that was Nair okay cool so I
messed something up there let's take a
look I'm missing that guy save that
render it here now and the other thing
that I had to fix here was it's not
links dot source it's linked out source
because that's the function we're
referencing and up above I had to add
this for my doctype okay so if you cut
those errors good for you
and here we go I'll refresh the page now
and bam there you have it so a really
simple way to draw a force layout
remember the basic steps are you get
your data and again you can use a CSV
and I'll put a link down there you can
look at another example you parse out
that data into the nodes then you add us
Viji
you build your forest layout passing in
the links and the nodes then you add the
links in the nodes themselves
interestingly enough if I were to swap
these out so if I were to cut that guy
and paste him above the other one and
save it now and refresh notice how the
links are on top of the nodes
it's literally like that because of how
its drawn because it's inside of an SVG
window kind of the first things that you
know are drawn to kind of like layers on
top of the other one so there's not
something like a z-index or a CSS
property or something you can set there
it's just how it's actually rendered or
how the code is written here okay so
then add your links add your nodes and
then do the tick function this is again
is what lets me drag it around and have
it up
date and see how the the everything
stays in sync as it goes that's kind of
the deal there alright I hope you've
enjoyed this tutorial and come back for
more I'll have a lot more d3 stuff
coming out on my blog as well as I have
a course specifically on force layouts
on Pluralsight coming out soon
hello friends and welcome to geeks or
geeks in this tutorial we are going to
cover cycle detection in a directed
graph using node coloring technique so
the problem statement is that we are
given a directed graph and we have to
check whether it contains a cycle or not
we need to just print
true if there are one or more cycle or a
false if there are none let's break down
the problem statement further and
understand what do we mean by few key
word used here in our previous videos on
cycle detection we have covered these
keywords so let's quickly see what they
mean first it says that the graph is a
directed one so what is a directed graph
here we see a directed and an undirected
graph the edge of a directed graph is
having a direction from one node to
another while the edge of undirected
graph is directionless next term we used
was a cycle cycle is basically a closed
path where we have a sequence of nodes
starting and ending on the same node
here we have an acyclic and a cyclic
graph in cyclic graph we have a cycle as
if we start from 0 we come back to it
after going through node 1 and 2 however
in this a cyclic graph if we start from
0 it goes to 1 then 2 and then there is
no path that lead back to the node 0
that is in this graph we do not have a
cycle let's now look at the solution to
the problem statement in this approach
we will use node coloring technique and
depth-first search if you are not aware
of DFS traversal you can go through the
tutorial that we have covered earlier so
the basic idea that we will use here is
first
we will color all nodes into three
colors white gray and black white color
nodes would be the one which are
unrelated or unprocessed gray color node
would be the one that are being visited
or processed in other words we can say
those nodes whose descendants are being
processed finally the black nodes would
be the visited nodes one whose all
descendents are processed this was the
coloring technique now if while doing
DFS we get an edge from current vertex
to agree vertex then we see we have a
cycle and this edge as a back edge a
package is an edge that is from a node
to itself or from a node to its ancestor
node the presence of that edge
determines the presence of a cycle this
is the cyclic graph that we are going to
use forever algorithm we will also
require these three sets the unvisited
white set the under process grace it and
the visited black set initially all
nodes are unvisited so they will be in
the white set these start over DFS from
node zero we put this node into our
reset and start processing its
descendant nodes the neighbor of zero
are 1 and 3 since none of them are in
gray set we choose one we put one into
our gray set the neighbors of one are
two and three both of which are in white
set we chose two and put it from white
to gray set now since there are no
neighbors of node
be say it to be explored and put it from
three to black said this to in black set
means that it has been visited now we go
back to note one one of its neighbor to
is in black set and the other neighbor
three is in bite said the chose three
and put it into our gray set now we see
neighbors of three zero and four are its
neighbor but we see that zero is
increase at two since both current node
three and its neighbor zero are in gray
set we see that this is the back edge
and that we have found a cycle here our
algorithm would stop let's assume that
this edge was not there so the only
neighbor of three would have been four
we would therefore go ahead and put node
four into gray set now at node 4 we have
a self loop and while covering this edge
we can say that this is again in gray
set and that we have found a cycle let's
look at the implementation of this
algorithm this is the code snippet taken
from geeks or geeks we start by
initializing the color of all nodes as
white and then for all the nodes that
are white we call our DFS function if it
returns true we say that we have a cycle
else we see that there are none now this
is the TFS function that finds a back
edge it takes a node and the color array
it marks the current node color to gray
it then checks all the neighbor of this
current node if any of it has grey color
then it returns true if neighbor
is not processed and while recursing we
have a Bacchus then also it returns true
if all descendant of current vertex are
explored we mark it as black and also
return false let's now look at the
complexity of this code the code will
run in Big O of v plus e this is same as
we have in depth-first search here V are
the number of vertices and E are the
number of edges with this we come to an
end of this tutorial if you have any
doubts or suggestions please leave them
in the comment section below thanks for
watching
hello friends my name is Tushar and
today we're going to talk about how to
find all simple cycles in a directed
graph using Johnson's algorithm so what
is the cycle a cycle is a path in a
graph such that the first and the last
word existed what is the simple cycle a
simple cycle is a cycle in which no
vertex is repeated twice except the
first and last vertex so in this graph
here we have bunch of simple cycles
example h98 or 1 2 3 1 so the idea is to
find all such simple cycles using
Johnson's algorithm so there are five or
six other algorithms to find simple
cycle but I found out that Johnson's
algorithm is the fastest of them also
for Johnson's algorithm I expect my
beavers to know how strongly connected
components work in another video I
already talked about how to find
strongly connected confident using cosas
Rajas algorithm and I am also going to
create another video about how to find
strongly connected component using
Tartans algorithm but just for revising
it quickly so a strongly connected
component is a subset of vertex in a
graph such that all the vertices are
reachable from each other so in this
graph here we have three strongly
connected component one is H 9 because 8
&amp; 9 are both reachable from each other
another one is 7 and the third one is
consisting of the remaining vertices
because all these vertices are reachable
from each other also for the purposes of
Johnson's algorithm I have numbered
these vertices going from 1 up up all
the way to 9 it is not strictly required
but this is how the algorithm is
described in the paper so this is how I
am going to explain it in this video so
next let's see how a Johnson's algorithm
works first thing we do is we divide
this original graph into sub graphs
where each sub graph consists of
vertices and edges which are for a
strongly connected component since we
had three strongly connected component
there we have three sub graphs here so
why we do that because a cycle is always
going to be restricted with a strongly
connected component there is never going
to be
cycle it stands for multiple strongly
connected component so for example this
edge here is never going to be part of
any second why because if it was it
means that either from 8 or 9 there is a
way back to 1 and which which would have
matched that 8 and 9 would be the parts
a strongly connected component as the
rest of this vertex and since they are
two different strongly connected
components which tells us that there is
no way back to one which means that
which means that edges like this this
and this would never be part of any
cycle so once you have done divided into
three sub graphs then we look for the
least number H least number what X so
the least number what X here is one so
first we are just going to work on this
sub graph this is this strongly
connected components of graph also I
have stack blocks set and block map map
data structure and as we run through the
algorithm I'll show you how this data
structures are you so what started what
X will be 1 which was the least numbered
vertex in this strongly connected
component so basically we are looking
for all the cycles which start and end
at 1 so then we do a DFS starting at 1
so we add 1 to the stack and 1 to the
block set and now you're going to
explore neighbors of 1 so 1 neighbor of
1 is true who is not say the start
vertex which means that we have not
found a cycle 2 is not part of the block
set which means that we can explore 2 so
we put 2 into the stack and 2 into the
block set then be able to explode
neighbors of 2 so 1 neighbor of 2 is 3
so again 3 is not same as start vertex
which means that we have not yet form a
cycle and 3 is also not part of block
set so we can explore 3 so we put 3 into
the stack and 3 into the block set then
they explode any course of 3 1 neighbor
of 3 is 1 and that table is same as
start vertex which means that we form 1
cycle and the content
the cycle is the contents of this tab so
let's record this cycle so the cycle
will be 1 2 3 1 then we come back to
three and then we explore other
neighbors of C 3 and see if we can find
more cycle so one neighbor of 3 is 2 but
2 is already part of this blocked set
and since we are just looking for a
simple cycle anything other than 1
cannot be repeated so we cannot continue
in this path of 2 so we come back to 3
and then explore another neighbor of 3
so one more neighbor of 3 is 4 so 4 is
not going to start vertex 4 is not part
of block set so we are going to add 4 in
woods tag and block set and explore
neighbors are for
one neighbor of 4 is 5 so 5 is not same
I start vertex and 5 is not in block set
so we will add 5 into stat and block set
and then explode anywhere is a 5-1
neighbor 5 is 2 not 2 is not same a star
vertex but 2 is in this block set which
means that we again hit a road black
road block and we cannot proceed in that
direction because to gain on what X 2
cannot be repeated again in the same
cycle so we're going to come back to 5
and explore other neighbors of 5 but 5
have just 1 over 2 so what that means is
all the way are going to recur start
from 5 I am NOT going to remove fry from
the block set why because the way things
says stack is set up correctly there is
no way in the current DFS traversal that
you could find a cycle which starts
which which has 2 in it and also which
goes to 5 because 5 is going to h2 but I
am going to record that if we ever
unblocked to then I am going to unlock 5
so basically if we look for
neighbors of five and add five to their
unlock to the block map so if two ever
gets unblocked at that point of time
island block five so as you see I left
five in the block set then from five we
come back to four four has no other
neighbors and we did not find a cycle in
this current path so similarly just like
before we leave for in the block set
will remove it from the stack and once
you find the neighbors of 4 which is 5
and add 4 to the blocked map so just
saying like if five ever got unblocked
then be able to also unlock 4 and then 4
we come back to three now three has one
more neighbor 6 so be able to traverse
there 6 is not same a start vertex and
sticks is not same as block side so we
add 6 to both of them now 6 has one
neighbor for now 4 is not saying a start
Ward expert 4 is times this block set
which means that we should not explore 4
and this is how we do optimization since
we did not remove 4 from this block set
which means that we save this acceptable
cell where we go from 4 to 5 and 4 5 to
2 and then realize the 2 is already in
the current stack and then come back so
by not removing 4 and 5 from the block
set we provided this optimization so
anyways but we have to note that if
forever gets unblocked then we should
also have lock sets so 6 has nobody else
will we go back to 3 so we remove 6 from
the stack but not from the block set now
equal to 3 so 3 is done exploring all
its neighbors and it did find a cycle in
one of its neighbors so 3 be able to
block 3 because there is a possibility
that there could be a future cycle going
from 3 to 1 since 3 found attached to 1
it means that there could be some other
path which could lead from 3 to 1 so we
have to
three so I had removed three from the
stack and I'm also going to unblock
three and then I'm going to check this
dog Mac to see if by blocking three do I
have to block any other vertices and
none because there is three is not part
of any key so then from three we go back
to two because that's where it came from
now two has no more neighbors so now
since we did find a cycle from 2 all the
way to 1 which means that we have to
unlock two to open up the possibility
for future cycle so we will go to unlock
two and since now that we've unlocked -
we have to go and check is anyone else
waiting to be unlocked because of two so
five was so we go to 5 and see if anyone
else was waiting to be unblocked because
of 5 and 4 was to recursively go to 4
and if it was anyone else ready to be a
block because of 4 6 was and no one was
waiting for 6 so first we remove 6 from
here unlock 6 and remove this particular
entry then you go to 4 remove flow from
this unblocked block set and then delete
this particular entry and then we go to
2 and 2 is already removed from the
block set but we also got to remove 5
and then remove this particular entry so
as you can see by the time we were done
with 2 and then also going to move two
from the stand so by the time we were
done by 2 now we have to unblock 4 5 6
all this other vertices why because now
that 2 is no one in this tab there is a
possibility of a cycle going through 6 5
and 4 and leading to 1 so now we come
back to 1 and 1 has another vertex 5 so
we are going to add and find it's not
part of this block set and why because
since to garden not removed 5 which
means that we open up a possibility for
another cycle going through 5 and now
that 5 is not part of block set we can
explore
five so we add fire to the stack five to
the block set and then you have an
exploding where's a five so neighbor of
five is two and now we'll repeat the
process like before so neighborhood five
is two and two is not Paris attack and
true is not same and start word X we add
to here to here and then here of 2 is 3
so 3 + 3 + 1 aber of 3 is 1 it means
that we found a cycle and and the
contents of the cycle will be this 1 5 -
3 1 so we found cycle here so now we
explore other neighbors of 3 1 neighbor
of 3 is 4 &amp; 4 is not exploding 4 is not
saying start node X so we add 4 here
another neighbor of one neighbor of 4 is
5 but 5 is already colored blocks set
which means that we cannot exploring the
direction of 5 because 5 is already part
of this time and it's a simple cycle we
are looking for so we go back to 4 leave
for in the block set but mark that if 5
ever gets unlocked then we will unlock 4
then 4 for big and then we go for from
this tack but not from the block set
from four we go to 3 3 has another
neighbor 6 we add to the stack and to
the block set 6 has another neighbor for
but 4 is already the block set so we did
not find a cycle from 6 all the way to 1
so but we are going to mark that if
forever gets unlocked then we will
unblock 6 so leave it says in the block
set and remove 6 from this tag and go
back to three now three has explore 3
has another neighbor 2 but 2 is already
caught a block set so we come back to 3
so now 3 has explored all its neighbors
and it did find a cycle going so it did
find a cycle leading to 1 so we have to
unlock 3 if you never find a cycle so
ever find a path leading to the start
vertex yes that block that vertex to
open at the possibility for future work
future cycles so we remove 3 and you can
got 3 and then we check doesn't doesn't
one else needed blocking because of
three no one else does so we go to two
now since we found a cycle in this path
from two so we able to unblock to remove
two from the stack and see does anyone
else need Sun blocking and no one does
so from two we go back to five and we
unblocked five and remove fry from the
stack and also see if anyone else needs
unlocking because of five yes we do
because for was dependent at fight then
locked which means that we will remove
four from here and then we will see who
is dependent in four and six was so we
will remove six from here and we'll also
remove these entries so finally we come
back to one and now one has no more
neighbors to be explored so basically
after all this we found all the cycles
which starts and ends at one and so
there are two cycles with start and ends
with one so after we are done dealing
with one the next thing we do is we
remove one from my original graph as if
one never exists existed before so we
remove one we move all the outgoing and
incoming edges from one and just delete
one and acts like one ever existed and
then repeat the entire process again so
let's do that quickly now that one is
not part of the graph we still have
three strongly connected component we
again look for the list numbered vertex
which is two so where new start vertex
will be two and will repeat the entire
process again so let's do that very
quickly
so two into the stack two into the block
set neighbors of two will be explored so
definitely three three will be go here
will be going here and three will go to
the block set neighbors are three will
be explode one neighbor is 2 so it is
say the start vertex so we found one
cycle which will be two three and two
then you go back to three and then
explore another neighbor of three which
will be four so we add flow to the stack
and four to the block set and explore
equal to 4 which will be 5 so we add
five stack and
and then fry the end up at two so again
you find another cycle and the contents
that cycle will be two three four five
two and then be records back from five
since you found the cycle from five
there's a possibility of future cycles
if we remove from the block set and
stack and then you go back to four since
we found a sec on this path we remove
four from both blocks set and block and
stack and then we go back to three three
has another three has another vertex
another neighbor 6 so we explored that
so we add 6 to here and 6 to here and
from 6 we go to 4 and 4 is not a block
set and now you can see why the moving
forward was so critical because if you
had not removed four from the block set
we would have never found this this
cycle going wire 6 so we remove the S 4
is not X is not a block set to be high
it we add it then for from for a good 5
it's not there so we added and then 5s
neighbor is 2 so we found one more cycle
so the content of that cycle will be 2 3
6 4 5 &amp; 2 &amp; then makers back so we found
a cycle so we unblocked 5 for the
possibility of future cycle then we go
to 4 then block 4 for the possibility of
future cycle then we go to 6 we unlock 6
for the possibility of future cycle then
we go to 3 so at this point of time we
have explored all the neighbors of 3 so
we're and since we found cycles be able
to unblock we haven't unlocks 3 and we
will remove from the stack and then we
end up at 2 and now to has no more
neighbors so again we are done finding
all the cycles which starts with 2 which
is 2 3 2 and this one and this one so
now again we go back to this
you know original graph act like to
doesn't exist and then repeat the entire
process again let's do that very quickly
with two gone these are the remaining a
strongly connected components here so
there is no reason to pick a sub graph
with just one vertex because there is
the possibility of the cycle because
we're assuming there are no self loops
in this graph so then next we pick the
least number what X which has at least
two vertices in the sub graph and there
will be eight so with eight we'll repeat
the same process so it goes into the
stack and blockset and explode neighbors
of it which is 9 so 9 goes here and here
and then explode any person mine which
is one of them is 8 and it is also
starting vertex so we found another
cycle and the second will be 8 9 8 and
then and then we removed them from the
stack as where occurs back and then we
are done with it
so once you're done with it will will
act like it doesn't exist in this graph
so then we will just be left with then
we'll just be left with a strongly
connected components or with the sub
graphs whose size is just one at this
point of time we are done with the
algorithm so in this graph here we found
six different simple cycles let's
analyze the time complexity so the time
complexity is o of e plus v into c plus
1 where c is the total number of cycles
in the tour number of cycles in the
graph so we can find strongly connected
component in a plus we time which is why
we can guarantee that between every
cycle the worst time which will pass
will be e plus we but remember we can
have exponential number of cycles which
means that the total time complexity can
still be exponential so but the only
guide is that
recycle the worst time which will pass
will be II trust V and the space
complexity also will be e plus we so
next let's look at the code for this
let's first look at all the data
structures used in this algorithm one of
them is block set which is a set of
vertices which when blocked will not be
explored another one is blocked map
which is a map of vertex to the set of
vertices so when this vertex in the key
is unlocked then all the vertices in the
values should also be unblocked and then
stack holds the current DFS tag and then
all cycles is a list of list of vertices
so in this inner in this inner list is
is going to is representing one cycle
and then the outer list is the list of
all the cycles so basically all cycle is
going to store my final result the main
function is simple cycles it takes in a
directed graph and then first we are
going to do is initialize all the data
structures and then our start index will
be one and you remember or the index
indices or the vertices are valued
numbered from 1 all the way till Hauser
many vertex we have then we are going to
use stargell algorithm to find strongly
connected component
so while start index is less than the
total number of vertices we have which
initially will be true first we do is we
create a sub graph from the original
graph such that it only consists of
vertices which are numbered greater than
or equal to start index so anything less
than start index will be ignored so
initially start index is 1 so we will
include the entire graph then in this
sub graph we are going to find all the
strongly connected components using
target's algorithm then we are going to
pass this SCC s and the sub graph to
least index SCC so basically finding for
the least index vertex among all the
strongly connected components so this
method here first creates a graph for
each of the strongly connected
components and then among them looks for
the least index vertex also it ignores
any graph which has just one vertex in
it because it will never have any cycle
so this might or might not return a
this might or might not be present so if
the least index vertex is not present
then we break and then we are done with
algorithm and return all cycles
otherwise if it is present then we get
the least index vertex clear the block
set and block map because they may be
populated from the previous iterations
and then find all the cycles in this
particular in this particular strongly
connected component graph which list
index least vertex is part of so this is
the start vertex and then this is the
current vertex and then finally we look
at this method in a bit and then finally
we increase our start index to be at
least least index plus one so when we go
back here and then when we create a sub
graph next time we are going to ignore
everything which is less than start
index and this is also we discussed
previously in the video so let's look at
find cycles in s e-g which is the main
part of the algorithm so here the first
is the start vertex and second is the
current vertex so first we do is we do a
DFS here phone cycle is false we push we
push the current vertex into the stack
and then we also push the current vertex
into blocked set then we are going to
explore all the neighbors of current
vertex so we get one neighbor at a time
if this neighbor is same as start vertex
it means that we found the cycle so we
are going to push the contents of the
stack into this list cycle and add this
list cycle into all cycles because all
cycles is storing our final result and
then we are going to mark the found
cycle as true because we found a cycle
in this particular path by going wire
this current vertex
otherwise if neighbor is not same as
start vertex and if also if neighbor is
not in the blocked set then we can
explore this neighbor so we again go
into the recursion with fine cycle in se
G keeping the start vertex s same and
for the current vertex passing neighbor
and then we and then we what and then it
repeats the same process and then if we
did find a cycle in this
then we then we sent the found cycle to
be true so basically if for a current
works a current vertex if any of its
neighbors finds a cycle in its path then
found cycle will be true for the current
vertex so once we are done with the for
loop and all the recursion
if found cycle is true then we unblock
the current vertex and this unblocking
is not just an drawing the current
vertex but it is also checking the
blocked map and recursively unblocking
all the other vertices which are waiting
on the current vertex so let's look at
unblock very quickly so we remove vertex
u from the block set and then records
and then getting all the vertices from
the block map which are waiting on you
and then going through one each of them
and removing and recursively and
blocking them as well so as we discussed
in the video this is recursively
unlocking all the vertices so once we
are done and blocking if then we are
done unlocking and if the found cycle is
not found so basically if there is no
cycle in this path then we are not going
to end block this vertex this current
vertex but we are going to add we are
going to find all the neighbors of the
current vertex and add this current
vertex to the blocked map so this is
because if they ever got unblocked
then we are going to unblock the current
vertex as well and this is also we
discussed in the video before and after
this we are just going to remove the we
are just going to remove the current
vertex from the stack and then if cycle
was sawn divisionary will turn to and if
cycle was not found then widget Falls
and this happens recursively
so finally fine cycle comes here and
then we come back to here and then the
increment over start vertex and all and
then all cycles will have the final
result let's quickly run this code so
this is the same graph as we discussed
previously in the video so let's look at
the result of this graph so here this is
the list of all the cycles found in this
graph so I can totally endure
and this video is little in this code is
little involved so I would recommend is
you copy this code and run it and see
how the entire code is working so
finally the time complexity for this
algorithm is o of e plus we into c plus
1 where c is the total number of cycles
the reason we have a strong bound here
is 2 because 1 we can find strongly
connected component in o e e+ we time
and second because we are doing all the
blocking of the vertex and unblocking it
only when required
we are saving on the useless fruitless
and needless searches and also the space
complexity is o of e plus v so this is
all i have to talk about johnson's
algorithm please like this video share
this video comment on this video check
out my facebook page facebook.com to
sharra 25 and check out my github link 8
sub-commission peace interview wiki
thanks again for watching this video
hi I'm Joe James in this video we are
going to apply Dijkstra's algorithm to
this directed graph now just as a
reminder Dijkstra's algorithm can be
applied to either directed or undirected
graphs and it can only be used with
non-negative edge weights so if we have
any negative edge weights we cannot
apply it to this graph in this case we
have one zero edge but no negative edge
weights so we can apply Dijkstra's
algorithm on this graph to find the
shortest path to each vertex from a
single source in this case we'll call
that source s on the top left here so
the first thing we need we're going to
use a table to track the distance of
each vertex from the source and we're
going to initialize those distances all
to infinity with the exception of the
source itself since that's where we're
starting and we'll use another variable
called PI to track the predecessor
vertex or the vertex we just previously
visited to apply Dijkstra's algorithm we
will start at the source and we will
relax each of the outgoing edges in
alphabetical order so we have two
outgoing edges from the source we are
going to start with s to a and with a
distance of two so since we currently
have a distance for a of infinity we can
now reach a in two with the predecessor
of s so we'll update our table to
reflect that we can reach a in two
coming from the source and we're going
to mark this two as already finished and
next we're going to relax edge s D so
now we can reach vertex D with a
distance of 20 previously our best was
infinity so 20 coming from the source
now we'll mark this edge as completed
now we're done relaxing all the outbound
edges from vertex s will mark vertex s
as completed and we'll move on to the
next vertex a why would we choose a well
because that is the closest vertex to
the source at a distance of only two as
we could see in the table here D is at a
distance of 20 and all the other
infinity so we'll jump to vertex a will
relax all of its outbound edges in this
case we only have one edge going to e at
a cost of three so if we can reach a and
two and we add 3 to that we can reach e
in 5 so we'll put a 5 under E and what
is E's predecessor a we just came from
vertex a now we're done with vertex a
well mark that as visited now let's mark
edge a e as already completed we'll
visit vertex E which is the next closest
vertex to the source as you can see ease
only 5 from the source he has 3 outbound
edges to G H and B will visit B first
because it comes first alphabetically so
edge e B has a weight of 1 so we can
reach e in 5 we can now reach B and 6 by
coming from vertex E will mark this edge
is visited now we need to look at ease
next edge which is e G with a weight of
well it takes us 5 to reach e it would
take us 11 to reach G we currently have
infinity so we'll accept that well mark
E is the predecessor for G and then
we'll mark this edge as completed and
lastly we have eh with the way to 4 you
currently don't have a route to H and it
costs us 5 to reach e so we can reach H
now in 9 coming from vertex E will mark
edge 4 as complete and then we'll mark
vertex E as visited now we're going to
choose the next vertex to visit which
one is nearest to the source that we
haven't visited yet well B is 6 so
that's the next closest so let's go to
vertex B B has only one outbound edge B
to C at a weight of 7 we currently can't
reach C at all so anything's better than
that so 7 plus 6 is going to give us 13
to get to vertex C and we'll mark B is
the predecessor then we can mark this
edge as visited and we're done with
vertex B so we'll mark B is finished and
we can move on to our next vertex looks
like H is our next nearest vertex
so let's visit vertex H H has to
outbound edges H II with the weight of 2
and H G with a weight of 1 will visit
them alphabetically first edge which is
H e we can already reach a and 5 we can
reach H and 9 so if we add two more to
that we can get to e + 11 if we wanted
to that doesn't benefit us so we can
mark this edge as complete and now we
can look at HS other edge
so getting to H in 9 and we add 1 to
that to reach G we can get to G + 10 so
we found a better route to G by going
through vertex H so we'll update G's
predecessor as well and we'll mark this
edge as complete we have no more
outbound edges from H so we can mark
vertex H as complete next we'll visit
vertex G which is the next closest
vertex to the source with a distance of
10 G has only one outbound edge going to
D in our current distance to G is 10 we
can add 2 to that to get 2 D with this
edge weight of 2 now we can reach D + 12
that's better than what we currently
have at 20 so let's update DS distance
from the source to 12 DS predecessor is
now going to be G and we can mark this
edge complete now we have no more
outbound edges from G so we can mark G
complete the next nearest vertex from
the source is vertex D so we'll visit
vertex D which has no outbound edges we
can mark D is complete the next nearest
vertex from the source is C with a
distance of 13 so we'll go to C and we
only have one outbound edge which has a
distance of 5 to F so we can reach F in
13 plus 5 or 18 so update s distance and
S predecessor to C we can mark this edge
is complete and then we have no more
outbound edges from C so we can mark
vertex C is complete and our last vertex
to visit is vertex F which currently has
a distance of 18 f has one abound edge
with a weight of 0 that's definitely not
going to help us on B because we already
have a distance of 6 where f has a
distance of 18
so that does not give us a shorter path
to be by passing through F so we can
mark this edge is complete we have no
more outbound edges from F so we can
mark vertex F as complete then then
we're finished now we've applied
Dijkstra's algorithm on a directed graph
to find the shortest distance of each
vertex from the source if you enjoyed
this video please give me the thumbs up
and click the subscribe button I'm Joe
James thanks for watching
so for this example we'll be looking at
a directed graph so the directed graph
is a little more complicated or a little
more complex than our undirected graph
so for this graph we will have edges but
we also will have directions of which
way the edge is actually going so for
our directed graph our rows and columns
are labeled and ordered ordered vertices
so what we need to do is we need to be
able to fill in the table by writing one
if there is one outgoing edge between
the row vertex on the column vertex and
0 if no edge exists between them so
let's just pick one as an example and
let's go between a and B so between a
and B so you can see here it is a there
is an edge and that's actually going
from A to B so from A to B should give
us 1 but if we're dealing with from if
someone asked is there an edge between B
and a we're going to say it's zero
because the it isn't going in the
outgoing direction is not going between
B and a the edge is going between a and
B and that's the basis of our population
so let's run short between a and a from
a to a ok there's no loop so that's
going to be very straightforward zero
between a and B so you can see here that
there is an outgoing edge from A to B ie
the edge is pointing in this direction
so that's perfect
that's going to give us a 1 between a
and C ok there's nothing so we can
pretty quickly put can are zero so zero
between a and D there is an edge but
it's going from D to a so the answer for
this one will be zero between a and E
there's no link between a and E so we
put them in as zero
I'm just going to quickly make one quick
change to our graph if I were on the fly
and we're just going to say that between
a and D that is going in this direction
okay okay and the last edge we're going
to do is between a and F so let's
quickly look back on top of our graph so
we have a to F so a is going from A to F
and the edge is going in that direction
so that's absolutely fine so we can put
in our 1 ok so we keep our iteration
going so it's sorted between a and B
there is an edge between a and B but
it's going from A to B not from B to a
so the answer for this one is 0
is there an edge between B and B ok very
quickly here we can see there's no loop
back on it so the answer is 0 between B
and C now there is an edge between B and
C but it's going from C to B not from B
to C so the answer for this one is 0
is there an edge between B and D there
is and it's going from B to D so the
answer is one instr 1 between B and E so
there's not so the answer is 0 and instr
1 between B and F so you can see here
there's no direct link between them so
the answer is 0 so we keep going let's
say between C and a so no direct link no
edge zero between C and B so let's
reline between C and B there is from C
to B and it's an in an outgoing
direction so the answer to this one is 1
let's try and make it look a little bit
like a 1 okay
so between C and C 0 between C and D so
where is D so there is one between C and
D but it's going from D to C not from C
to D 0 is the one between C and E so you
can see here yet or is an edge and its
outgoing from C to e
so we've won and then between C and F no
direct link zero okay so between D and a
D and a okay we have an edge and it's
outgoing so it's going from G to A one
okay
this handwriting is getting worse what
is during edge between D and B there is
what is going from B to D not from D to
B so the answer is going to be zero
is there an edge between D and C there
is and it's going from D to C so in one
it's turn edge between D and D there's
the third answer is zero in stir one
between D and either is what it's going
from E to D not from D to e so 0 and
it's Devon from D to F there is what is
going from F to D not from D to F the
answer is 0 so that's fine now the last
edge we're going to look at is between e
let's say e and a so no direct link
which is zero instead one between a and
B E and B no the answer is zero is there
one between E and C there is but it's
going from C to e not from E to C so
it's zero
and so let's just double check so we're
going from E to C now hold on oh I've
just missed one so I'm going to erase
this very quickly and we've said is real
link between E and C so there actually
is so I've been looking at this edge
here from C to e but there is one
between E and C so the answer for this
is one for the very reason that we have
an edge here going from E to C so
between E and D there is an edge so we
put in our one try and put in our one
and between E and E the answer is zero
between E and F the answer would be zero
as well so for the last line between a
and F subject from there is one from A
to F but not from F to a so we're going
hero between F and B beads on the other
side no edge zero between F and C okay
no direct link zero between F and D
there is here's F here's D it's going
out going so that's an answer 1 between
F and E no direct link zero and then
we're going from F to F so there's no
loop back on it so it's zero so that is
our main point now what we're going to
do is very quickly just to show that
some of the edges that we've actually
put in that they are only one
directional in so were you know it is
actually a directed graph there can only
be a link between between two between
two vertices or actually going to say
that the direction will be from one to
the other so it's not both ways it's
only one way so if we looked at a and B
as our example it's going from A to B
not from B to a so you know B if we're
taking this edge here we're looking at a
to B and we're going in this direction
so it's from A to B not from beach
so just be careful with it okay so
that's an example of our directed graph
hello friends and welcome to King's for
gigs in this tutorial we are going to
cover cycle detection in undirected
graph so the problem statement is that
we are given a directed graph and we
have to check whether it contains a
cycle or not we need to just print true
if there are one or more cycle or false
if there are none let's break down the
problem statement further and understand
what do we mean by few key word used
here first it says that the graph is a
directed one so what is a directed graph
here we see a directed and an undirected
graph note how the edge of a directed
graph is having a direction from one
node to another while the edge of an
undirected graph is Direction less next
on P use was a cycle so what do we mean
by a cycle in our graph cycle is
basically a closed path where we have a
sequence of nodes starting and ending on
this same node here we have an in cyclic
and acyclic graph
in cyclic graph we have a cycle as if we
start from zero we come back to it after
going through node 1 and 2 however in
this acyclic graph if we start from 0 it
goes to 1 then do and then there is no
path that lead back to the node 0 that
is in this graph we do not have a cycle
[Music]
let us now look at the solution to the
problem statement this cycle detection
can be done using depth-first search
technique if you are not aware of it you
can go through the tutorial that we have
covered earlier also we will see the
algorithm with the help of this cyclic
graph the algorithm is a modified DFS
such that we are required to check the
existence of any back edge now package
is an edge that is from a node to itself
or from a node to its ancestor notice
this edge is a back edge as it forms a
self-loop and this edge is a back edge
as it leads back to its ancestor node
now to detect a back edge we can keep
track of vertices that are currently in
our recursion stack of DFS traversal if
somehow we reach a vertex that is
already in the recursion stack then we
say there is a cycle in the graph let's
quickly do a depth first search on this
graph we use a stack to store the nodes
currently in our recursion also notice
the color representation of visited and
visited nodes we start from node 0 since
it is not visited be visited and also
put it into our recursion stack next we
see the adjacent nodes of 0 1 and 2 are
the HSN node we choose the numerically
lesser and go with node 1 since 1 is not
visited V visit it and also push it into
our recursion stack next
see the nodes in Jess n21 only node to
is there we therefore visit it and also
push it into our recursion stack now we
see note it is n 2 node 2 node 0 and 3
are such nodes we choose node 0 now here
we find that node 0 is already visited
since it is already visited we check if
it is also in our recursion stack here
it is part of our recursion stack now
this is the condition of the presence of
a cycle and therefore we can stop and
say that our graph has a cycle the
algorithm stops and this package as it
lead to its ancestor node let's see the
implementation of this modified BFS this
is the code for it and it is taken from
geeks or geeks here we create two
boolean arrays to mark node visited and
part of our recursion stack initially we
mark or load as unvisited and not part
of our recursion stack be dense in the
starting node and the arrays to power
cycle detecting DFS function this loop
helps in case of a disconnected graph
now this function go depth wise and mark
nodes visited and part of recursion
stack for each node we check its
adjacent nodes with they are not visited
we make a recursive call else if they
are already visited it checks if it is
in our recursion stack if it is a part
of recursion stack it returns true that
is we have found a cycle
if no such cycle found it returns false
now let's look at the complexity of this
code the code will run in Big O of V + e
this is the same as we have in
depth-first search here B are the number
of vertices and E are the number of
edges with this we come to an end of
this tutorial if you have any doubts or
suggestion please leave them in the
comment section below thanks for
watching
Hello friends, my name is tushar and today I m going to talk about topological sort.
So given a directed acycle graph
topological sort is ordering
of vertices of this graph such that for every edge
u, v going from u to v, u should always appear before v in the ordering.
so for this graph here, one topological sort
could be A B C E D F G
another ordering could be
B D A C
E F and G
so the point here is that C should never appear be
A and B in the ordering or D should never be before B or E should never be
before C
and so on. So one of the application of topological sort
is in the build system. Suppose these were the
packages of a build system saying that
C has a dependency on A &amp; B package and
D has a dependency on B,  E has dependency on C and so on
so how would build system know which package it should build first
so what it does is it builds a graph of packages and then applies topological sort
on them
like create one of these ordering and then
builds the packages in this
order so A &amp; B build first, so C has dependency on A &amp; B,
so then C can go next, and then E and D can go next
F can go next, and G can go next and so on
lets see how we are going to do topological sorting.
so we have 2 data structure set and stack
set has all the visited vertices while
stack has all the vertices in topological sorted order
so what we are gonna do is we are going to start from any node.
so lets say we started from E. So first thing we do is
E is not in visited
set we put E into the visited set so we put it here.
then we are going to explore the child of
E, children of E, so we go in direction of
H, so H is not visited so
we put H into the visited set and then we are going to explore children of
H, H has no children it means that H has been totally explored
at that point we put into the stack. So only when a vertex totally
explored it means that
all its children has been explored at that point you put that vertex into the
set, so I H into this stack.
then we go back to E and then E has another child F
and F is not in this visited set, so first we put into this visited set
and then we go to F and then F
has a child G so and G is not visited set so we first put it in the
visited said and then go to G and then
at this point G doesn't have any
children
so G is we are done exploring G so we going to put G into
sorted stack so we will put G into the stack
and then we back to F and then F has
no children no more child to explore so we are going to put F
F into the stack and then we go back to E
explore all its children so we going to put E into the stack
so now what we are going to do is
we are going to pick
any other vertex which is not visited lets say we picked
B so first thing we do is put B to set
then we explore
a child of B so lets say we picked C C is not in the set visited set
so we gonna put C into the set then explore children of C C has
one child
E and E is already is into the visited set so we dont do anything
and then C has no other child at this point C into this
stack and then we go back to B
B has another child D and D is not in the visited set so we put
D into the visited set
and then we go to D and D has a child F
which is already in the visited set so we dont go there
and we stay at D and D has no more child to explore
so we put D into this stack and then we go back to B
at this B has explored both its children
so we are done exploring B so we put B into the stack
and at this point let's take another
unvisited node, the only unvisited node at this point is A so we go
to A
and put A into this visited set and then explore child of A
which is C, C is already into this visited set so we dont do anything about it
come back to A, A has no more children to explore
so we put A into this stack, so at this point
this stack has topologically sorted
order of vertices of this graph
so its A we pop elements one by one from this stack
A B D C
E F G
H remember there are multiple
topological sort orders possible for this graph
it's just the order in which you pick
this vertices
decide which one of them will show up
but all of them have this property that if a vertex
if there is a vertex u and v going from u to v
u will always show up before we in this
ordering so in the next section lets quickly
look at the code. So the main function is topsort
in this I initialize a stack and a
a set and then we start iterating through the vertices of this graph
lets say first vertex I encounter is D so then
so I go into so visited doesnt contain D so I go into
topsortUtil
in topSortUtil
first thing I do is add D to the visited
then I explore neighbors of D so
there is only one neighbor of D which is
F and visited doesn't contain F
so we go into topsortUtil again
and go to top of topSortUtil in recursion
and again we add F to the visited and then
we explore neighbors of F
and F only has one neighbor G and it also is not there in visisted
we dont go into this
if condition we go here topSortUtil again top of this function topSortUtil
and in there we add to G to the
visited then we explore neighbors of G, G doesnt have any neighbor
so we are done exploring everything in G
so we put G into the stack then we roll back into recursion
and we reach topSortUtil where F was the vertex
and F is done exploring all its
neighbours
so we add F to the stack and then we
roll back in recursion
and similarly add D to the stack because D is done exploring
neighbours
then I let's say
and then we go back to this topSort here in the for loop
let's say we pick a another
vertex say B so  B is
not in the visited so we again call topSortUtil with B
and then we going to topSortUtil first thing we do is we add
B into the visited and then explore neighbors of
B so lets say we explored C first so C is not in the visited so
call topSortUtil with C
and then we add C to the set
visited set and then C we explore Cs neighbors C has a neighbor D
and D is already in the visited so
we go continue into not explore this neighbor at all
go back to top of the for loop for C, C doesnt have  any more
neighbors will break out of this for loop
and we add C to the stack then
we roll back in recursion and reach the point where vertex is
B and we were in this for loop B has another child
E and E is not in the visited so
we call topsortUtil as E as the vertex
and then go there so first thing we do is add E
into the visited set then we explore neighbors of
E E has only one neighbor F and F is
in the visited so we do continue and then
go back to the top of the for loop
at this point E  doesnt have any more neighbors to explore so it comes here
adds
E to the stack then we go back into the recrusion
to B so B has done exploring both its neighbors in the for loop
so it goes here and adds itself into the stack
at this point we go back to the top of this
topSort in here
we again iterate through vertices
if we encounter any other
vertex other than A then we will just continue because they are all in
visited
as soon as we hit vertex A its not in the visited so we call
topSortUtil here
add into the visited and then
we explore neighbors of A A has a neighbor C
but C is already in the visited so just do continue
at this point A doesn't have any
other neighbors to explore so
we go to the stack and add into the stack and then
back to
top of  topSort now we dont have any more vertex to
explore so we just return this stack
all you have to do is pop elements out of the stack and  thats topological sorted
order so let me write that quickly A B E
C D
F and G this is all I have to talk about topological sort
please like this video share this video  comment on this video checkout my
github link github.com mission peace interview wiki
check out my facebook page thanks again for
watching this video
Hello friends my name is Tushar and
today I'm going to talk about how to
find strongly connected component using
Kosaraju's Algorithm.
So what is strongly connected component?
So here I have a directed graph and a
strongly connected component in a
directed graph is a compliment such that
all the vertices in that component is
reachable from every other vertex in
that components. So here I have 4
different strongly connected components.1
of them is a ABC so A is reachable both
from B and C and C is reachable both from A and B
and B is reachable both from A and C.
Similarly DEF is a strongly connected
component, GHIJ is a strongly connected
component and then K is a strongly
connected component. So what  are possible
applications of strongly connected
connected component. One of them could be
in Facebook for example Facebook is
graphs of people and then Facebook
would be using this algorithm to find
all the strongly connected people
with each other and then could be
looking for common interests or
something like that in that component. So
how do we find strongly connected
component. There are couple of
algorithm to find it. One of them is
Kosaraju algorithm which we are going to
discuss today. It's a 2 pass algorithm
Basically it goes through this graph 2
times. So in the next section let's see how
this algorithm works, why it works and
then we'll in the end look at the code
As I said it's a 2-pass algorithm. So
let's see what we do in the 1st pass.
So we do a DFS on this graph and then we
order the vertices of this graph by
finish times in decreasing order. So we
need 2 data structures, a set to keep track
of all the vertices we have visited
and a stack to order the vertices by
finish time. So we can start from any
vertex. Let's say we start from B. So
we, first thing we do is we put
B in visited. Then we explore the
children of B. So B, let's say go to C
so C is not in visited so we go to C
put C
in visited. Then explore the children
of C so there's only one child A and
A is not in visited so we put A in visited
and then explore children of A and that's
B but B is already in the visited. So we
don't go to B. So at this point we have
we're done visiting all the children of A so,
which means that there is, A is done,A is
finished. So A is the first vertex
to finish. So let's put that in stack. Then
go back in recursion and go to C and
C has no other children so C
is done so we're totally done visiting C. So
we push, we push C into the stack. Then
we come to B and then B has
another child D so we go in the
direction of D and D is not in visited so we'll
put D in visited. Then D has another child
E and E is not in visited so we'll put E
in visited and then E has another
child F and F is not in visited so we'll
put F in visited and then F has child d
but D is already visited so we go back
to F. F has no more children to be explored
so we'll put F into this stack and then we go
back to E and then E has no more
children to be explored So we put E
into this stack and then we go back to D
and then D has no more children to be
explored so we put D into the stack and
from D we go back to B. So at this point B
has explored all its children. So we'll put B into
this stack. Then, then we pick another vertex
which has not been visited. So let's say
we picked I. So I is not visited so first
thing we do is we put I in visited. Then
we explore children of I. So there's only
one child of I, that's J and J is not
visited so we'll put J in visited and then
we'll explore children of J so let's
say K and K is not visited so we'll
put K in visited and then K has no
more children. So K is done. So we'll put
K into stack and then we go back to J
and J has another child G so we go to G,
put G in visited and then G has another
child F but F is already visited so we'll
do nothing. At this point J has another child
H. So we'll go in the director of
H, put H into stack and then
H has a child I but I is already
visited so we'll not go there
so at this point H is done visiting
all its children so we'll put H into stack. Then
we'll go back to G. G has done visiting
all its children so we'll put G into stack
Then we'll go back to J and J has done
visiting all its children so we put
J into stack and then finally we put I
into this stack. So this is the first pass of this
algorithm and I have this
stack in which the vertices are
ordered by finish time in decreasing
order basically the vertex which finished
last
for example I is at the top of the stack
and the vertex which finished first for example
which in this example was A which is at the
bottom of the stack. So next let's see
how we do the second pass. So first thing I
did was I reversed my graph then in the second
second pass I'm going to pop elements out
of this stack and do a DFS
on this reversed graph. So let's pop out I
and since I is not visited I put I in visited
and this is my first strongly
connected component starting with I. So
from I, I go to H so H is not in the visited 
so we'll put H in visited and then also
add H as a part of this strongly
connected component and from H we go to
G and G is not in visited so put it in
visited and add it as a part of
strongly connected component and from
G, I go to J, J is not in visited so add
there and add it here and from J we go to I but 
I is already visited so J has no more children
to be explored, G has no more children to be
explored
I has no, H has no more children to be explored
and then I has no more children to be
explored
So basically we are done exploring all
the nodes from, vertices from I so
basically this is our first component.
So at this point we're going to go back
into stack and pop out the next
element but this,this strongly connected
component, the first strongly connected component is done.
So then I pop out J but J is already part of
visited so I do nothing. Then I pop out G. G
is already part of visited so I do nothing.
Then I pop out H, H is already part
of visited so I do nothing. Then I pop out
K. K is not in visited so I add K here then
I start the DFS from K. So this is
start of our 2nd component,strongly
connected component. From K we can go to J but J is
already in visited so we come back
to K and then K has no other child to
be explored in this graph so this
this second stronly connected
component is just one vertex. So at this
point we'll go again into this stack and pop
out next element so that's B so B is not
in visited so I'm going to add it in the
visited and this is going to start my
third component. So from B i can go to
A. So A is not in visited so I add
here and then I add it here and then
from A I go to C. C is not in visited
so I add it here and then I add it here
from C I can go back to B but B is
already in visited so I go back to A. A
has no other children and then B has no other
children so at this point we are done
exploring all the vertices
vertices of this strongly connected
component. So then we're going to start
the next component. So we pop out D. D is
not in the visited so we add it here and we'll
start a new component here D and D has a
children F and F is not
visited so we add F here and add F here
and then F has a child E and E is not
in visited so we add E here and then we add E here
and then E has a child D but D is
already in visited so we go back to E and
E has no other child and F has no other
and D has no other child so this is
the 4th component and D has, D
has another child B but B is already visited so
we'll not go there
So this is it. So D,so this is DFE is our
4th strongly connected component. Then
I'm going to pop out E but E is already
visited then I'm going to pop F and F
is already visiteded and then I'm going
to pop out C and C is already visited and
then I'm going to pop A and A is already
in visited. So these are our 4 strongly
connected components.
IHGJ, K, BAC and then DFE. So let's
analyze the time complexity and space
complexity. So the, time complexity is
we did, in the the first pass we did the DFS so
that will take O(E+V) time where E is number
of edges and V is the total number of vertices
and then we reversed this graph and that
will take another (E+V) time
probably depending on how the graph,how
you have represented your graph and then
we did another pass on this,on
this graph, on the reversed graph and then
we take another O(E+V) time. So the total time
complexity will be
O(E+V). Space complexity is pretty
simple.
The total number of elements in the stack
is total number of vertices and in the visited
set is also total number of vertices.
So the space complexity is O(V). So in the
next section let's try to understand why
this algorithm works. CLRS book has a
mathematical proof on why this algorithm works
but let's see some intuition behind it.
What I'm going to do is I'm going to
combine my vertices of a strongly
connected component into one vertex and
create a new graph. So this ABC is one
vertex and then DEF is one vertex
and then GHIJ is one vertex
and then K is one vertex. Then
there's an edge from this side of
this strongly connected component to here
so we'll create this edge. There's an edge
from here to here so we'll create this
and then this.
So what I'm saying is this graph is
guaranteed to be directed acyclic
graph. Why? Because if there was a cycle here, for
example if there was this edge from here
to here it means, for example there is an
edge
from here to here. Then this combined
together would be 1 strongly connected
component so we won't have,we would not
have this edges as two different edge
we won't have this as 2 different
vertices but we would have this 1
combined vertex. The fact that we are
having this 2 different vertices it
means that there is no cycle and it
means that this edge is not possible. So
that shows why this is going to be a
directed acyclic graph. Now we did the
ordering of vertices based on their
finish times. What that meant was
that when all the children of, when all
children of a vertex are explored then
put in a stack. So there's a
guarantee that at least 1 vertex from this
set is going to finish after this guy
because there's an edge from here to
here there's a guarantee that there
will be at least 1 vertex here which will finish after all this
guys are explorered. So let's say that guy
was B. So in the, in the stack A and C went
down then all this DEF goes on top of that
but at least 1 vertex from this set and let's say
that's B will always fell on top
of this guy because there is a
there's a edge from this side to this
side. Similarly there's a guarantee
one vertex from here will finish
after all these guys are explored. Let's
say that guy was G so and then there's
also guaranteed at least one vertex
here will finish after K and let's say
that guy was G. So then what we did was we reversed
this graph. So when we reversed this graph this
will pretty much end up looking something
here will finish after K and let's say
that guy was G. So then what we did was we reversed
this graph. So when we reversed this graph this
will pretty much end up looking something
like this. So by reversing this doesn't
change because all the vertices are
vertices are reachable from
each other. They're continue to be, they
will continue to be reachable from each other
because it's strongly connected component. Similarly
for these other strongly connected
component. But this vertex
this edge will have a different direction now
because we reverse this direction.
So then what we did was we did a DFS based on
the finish time
so what we, what guarantee we had was that B and G will
be picked before this, any of the
vertex here or any of this vertex here is
picked. So when B got picked first we
explored everything here so ABC got
explored and then we and then we finished
and B could not explore anything here
because this, this, there's an edge from
this side to this side and then when G
got selected next G explored everything
here so GHIJ and then by the time
K got selected or any of the edges
any of the vertices in this group got
selected these 2 guys, all the
vertices in this were guaranteed to be
explorer which is why when DEF got
selected DEF could not explore,explore
any further because all these guys were
already explored by either B or G and
similarly when K got selected K could not
explore further because these guys were
guaranteed to be explored before K
got selected. So that is how we ended up
having four different strongly connected
components.
Hopefully this gives you some intuition
why this algorithm works. Anyways as I said
CLRS book has the full explanation
of the proof. So in the next section let's
quickly look at code for this algorithm. So we're going
find strongly connected components. So my main
function is scc which takes a graph and
then it returns a list which is a list
of set where each set represents a
strongly connected component consisting
of vertices. So first I initialize the
stack and then I initialize a set. So what
I'm going to do is in the first pass
is go through all the vertices, do a
DFS and order the vertices by the
finish time in decreasing order. So let's
say we start from vertex 2. So visited
doesn't contains 2 so we go into this
DFSUtil with 2 as the vertex so the DFSUtil
is a very simple function. All it
does, it does a DFS and puts the vertex
in a stack when it's done exploring all
its neighbors. So we go, we start with 2
we add 2 to visited. Then we explore
neighbors of 2 so we get 3.3 is not
visited so we call DFSUtil with 3,add 3 to
visited and then explore neighbours of
3 so let's say we get 1.1 is not
in visited so we go into DFSUtil
with 1 so we add one to visited and
then explore neighbors of 1 so we get
2.2 is in visited so we continue and then
there is no more neighbors of 1 to be
explored so we add 1 to the stack. Then
we go back in recursion,go back to
3,explore another neighbour of 3
that's 5.5 is not in visited so we add 5 to
visited then explore neighbour of 5
which is 6 so 6 is not in visited so we add
6 to visited and then explore neighnour of
6 which is 4.4 is not in visited so we add
4 to visited and then explore number 4.4,
his neighbor is 5 which is in visited
so we continue and so we're done
exploring all the neighbors of 4. So
at this time we add 4 to the stack and we
roll back in recursion where 6 was
the vertex and 6 has no more neighbours to
be explored so we add 6 to the stack and
then we roll back in recursion and
then add 5 to the stack and then come
back to 3 and 3 has no more neighbours to
be explored so we add 3 to stack and then
come back to 2 and 2 has no more neighbours to
be explored so we add 2 to the stack. Then
we go back to the top
our main function and then we explore
another vertex which has not yet been
added to the visited so that vertex is
7 so we again call DFSUtil
with 7 and add 7 to visited. Then
explore neighbours of 7 that's 6.6
already is in visited so we don't 
go into recursion with 6 and then at
this point 7 doesn't have any more
neighbours to be explored so we add 7 to the stack.
and then we go back to the top of, to
the main function. So at this point we
have populated this stack and with the
with the vertices in a finished time in
decreasing order. So next let's reverse
the graph and do the second pass.So I
reversed this graph and then I'm going to
do a DFS on this graph based of the
vertices coming out of this stack. So
we cleared our visited set and then
I create my result list where I'm going to
store all the strongly connected
components. So while stack is not empty I
poll out the first element, first vertex from
this stack. So 7 comes out of the stack
and then we do a DFS on 7 so visited
doesn't contain 7 so we create a new
set for storing this strongly connected
component and go into this recursion
DFSUtil for reversed graph. So in DFSUtil
for reversed graph first thing I do is I add
7 to visited then I add 7 to a set and
then I explore neighbours of 7.7 doesn't
have any neighbour in this reversed graph
so we do nothing and we go back to our
main function and then in here we add this
set to our results list. So this is the
first set in my list. Then I go back here
while stack is still not empty
so I pop the next element out of the
stack and that's 2 and visited
doesn't contain 2 so we create a new
set and then again
call this DFSUtil
for reversed graph and in here first
thing I do is I add 2 to visited and then
I had 2 into this new set and then
I explore neighbors of 2 so first
neighbor I get is 1 so 1 is not in visited
so we called  DFSUtilForReversedGraph for
1. So first thing we do is we add 1
to visited and then add 1 to the same
set as we added 2 and then explore
neighbours of 1 so that's 3. 3 is
again not in visited so we again call
this DFSUtilForReversedGraph add 3 to 
visited and add 3 to this set and then 3 has
a neighnour 2 which is already visited so
we roll back in recursion, go back
to 1.1 doesn't have anymore neighbour so
we go back to 2 and then 2 has no
more neighbours so we'll go back to the
top of this main function. In here we add
this (2,1,3) set to our result and then we
pop out the next element from this stack
so that's 3.3 is already visited so we do
nothing about 3.Then we pop out the
next element from the stack and that's 5
So 5 is not in visited so we create a
new set and then we again go into the
recursion with 5 so we come here,we
add 5 to visited then we add 5 to
this set and then explore neighbours of
5. So the first neighbour of 5 is 3 but
3 is already visited so we do
nothing about it so then the next
neighbor of 5 is 4 so 4 is not visited
so we go into the recursion for 4.So
we add 4 to visited and add 4 here
and then 4 has a neighbor 6,so and
6 is not visited so we put 6 in visited
and add 6 here and then 6
has neighbor 5 which is already visited
so we do nothing and then 6 has another
neighbour 7 which is
also visited so we do nothing and then
we're done exploring all neighbours of
6 so we go back to 4 and then we're
done exploring all neighbours of 4 so we
go back to 5 and then we're done
exploring all neighbours of 5 so we
go back to the top of this,this main
function. In here we add this set to the
result and then we explore,we explore
the next,next element from the stack so
that's 6.6 is already visited so we do
nothing and then we poll the next
element from this stack so that's 4, it's
already visited and then 1 is also
already visited. So this is our
this is our strongly connected
components 7,213 and 546. Again the run
time complexity is O(E+V)
and the space complexity is O(V).
So that's all I have to talk about strongly
connected components. Please like this
video,share this video,comment on this
video,check out my facebook page,check
out my github link and the link,the link
to the code is in the description
section of the video. Thanks again for
watching this video.
I speak French for tobacco editorial village
historic district of the class c temple
Ivy adapted to contribute here Trophy
technology to wake up to the mark will en
xbox order entered glue and dust and to dust
be regular and ready to epe architect
diet corttex Adar more if the multi ruben
Saturday will be happening here said
max carro made by taxis in the woods
general fished within school patron
tax to text entered in a taxi and
car were rescued in time in general
made clove food center does not know
Frontex's former boss by taxi and
barracks sp former deputy is to provide target
It is the crossbar and went
terry nopa Baxy hall of the goal
technical lining 10 max 2012 sin
team overall did German carnation
the index is true alicia sticking this
for the last of our craft demonstrations
we're going to take a look at Dijkstra's
algorithm and we're going to apply
Dijkstra's algorithm to a directed
weighted graph first step we're going to
start out at a and we're going to figure
out where we can get to from a that's
better than what we've already got now
again all of these are infinite to start
out with so anything is going to be an
improvement over that so we take a look
at all the edges originating at a we
have an edge from A to B it cost 20 well
20 is better than infinity so we have a
new lowest cost path from A to B and
that's cost 20 and that's from vertex a
we have another one from A to G that's
cost 90 knots also from a and we have
another one from a to D and that's 80
and it also originates at vertex a and
all of the remainder are going to be
infinity because we have no path
standing those vertices yet in the next
step we're going to take a look at the
lowest cost path of all the ones we have
so far we have 80 90 a lot of infinities
but we have a 20 so 20 is the best we've
done so far so we're going to pick that
as our lowest cost path and we're going
to say that that one is now complete so
in our next round we're going to start
out the search at the place where that
lowest cost path has taken us which is B
now B we already know the lowest cost
path is 20 but we're going to see where
else we can get to from B that we
haven't been to before
well B only has one edge originating and
that takes us to vertex F and we haven't
been to F before so its cost is
currently infinity so the cost to get to
F via B is just 10 more than whatever
the cost was to get to B so in other
words 20 plus 10 is 30
and that's a pacifier be everything else
is unchanged so we're just going to copy
it down
in the next round we're going to take a
look at all of the pads we have so far
excluding the one that we've already
picked and we're going to find the
lowest-cost path well in this case it's
the newest one that we've added which is
32 F so f is going to be our starting
point for the next round now we have two
edges originating from f1 which takes us
from F to C at a cost of 10 now that's
10 plus the cost we have already of
getting to F 30 so 30 plus 10 is 40 to
get C 40 is better than infinity so we
have a path to C cost of 40 and it comes
from F we also have an edge from F to D
now the cost of that edge is 40 now 40
plus the cost of a 2 B 2 F is a total of
30 plus 40 70 now our path currently 2 D
is cost 80 70 is an improvement so we'll
take 70 instead and that's via F and
nothing else changes so 20 from a still
no way to get to e 30 from b 90 from a
and still no path to H either in the
next round we're going to pick the
lowest cost path of all the ones we
haven't completed yet and that's this
one over here so our path vertex C at
cost of 40 so C is going to be our
starting point for the next round
now there's several edges originating at
sea one takes us back to F it cost 50
now that would give us a total cost of
well 42 C plus 50 more is a total of 90
now 90 is not better than 30 which is of
course what we'd expect because we've
already found the lowest cost half but
we do have one from C to H and that's in
addition to the cost of getting to see
in the first place which was 40 so 40
plus 20 is 60 60 is a big improvement
over infinity so we'll take that one
pass to H cost of 60 coming from C we
also have an edge from C to D at a cost
of 10 now 10 plus the cost to get to sea
of 40 is a total of 50 which gives us a
path from A to B - f - C - D of cost 50
which is less than the cost of the path
we have so far so we have another
improvement 50 to get to D via C instead
and that's the only change so everything
else gets copied down
and that's still the best path to be and
that's still the best past path to see
and that's still the best path to F but
if we of what we've got left this path
to D is now the lowest cost path the
week so we finally settled on path to D
that's going to be the best that we can
get so that's at a cost of 50 so now
let's take a look at where we can get to
from vertex D from vertex D you get to
vertex G at a cost of well 50 to get to
D in the first place plus 20 from D to G
grand total of 70 70 to get to G well
that's an improvement over the direct
route from A to G which was 90 so 70 is
better than 90 so we pick 70 instead and
that's via D but that's the only new
path we have that's the only edge we
have originating into D so everything
else just gets copied down once again
and we're already done with this one and
this one and this one this one so now
our next lowest cost path is this one
2h at a cost of 60 so we're going to
pick that for the next round and we're
going to start exploring paths starting
from vertex H now vertex H is very
interesting because there is no edges
originating there so there's nothing
more we can do all we're going to do is
say that everything stays the same as
was before by copying everything down
and all the finished paths are still
finished kind of the remaining
unfinished paths the lowest-cost one is
this one over here it costs 70 so we're
going to mark that one is finished and
we're going to add that vertex G and
we're going to take a look at all the
edges starting from G now there's only
one edge originating a G that takes us
back to a at a cost to 20 grand total of
90 to do a round-trip back to a but we
weren't trying to do a round-trip in the
first place so that adds no new
information everything just gets copied
down
all of these are complete which leaves
us with one last value which is e has a
value of infinity now in this case value
of infinity tells us that there's no
path to he at all and in fact if we take
a look at the vertex E we can see of
course if there are no edges leading
into E which means that there is not
going to be any way of getting there and
having the value infinity left over as
our result shows us that there is in
fact no path to e so we can mark it is
done that's the best path we can get
none at all
and now our Dijkstra's algorithm finding
the lowest cost paths from a to all the
other vertices in a graph is complete
