in this presentation we are going to
look at weighted graphs as part of our
graph theory series now in particular
what we're going to do here is to write
the adjacency matrix for the following
weighted graph okay so we have six
vertices there they are all have degree
3 and so what we'll do is write out the
adjacency matrix for these and on the
adjacency matrix rather than the fact
that they are connected or not connected
what we're going to do is the weighting
we're going to indicate the weighting of
the between each of the edge between
each 40s for vertex so v1 v2 v3 v4 v5
and v6 not exactly necessary to put in
the row names and column names of
adjacency matrix but it actually just is
helpful when you're just getting started
again v1 v2 v3 v4 v5 and v6 okay
so let's look at vertex one it's not
connected to itself okay zero there it
is connected to vertex two and therefore
we're going to put a two there because
the weighting of that and edge is 2 so
it is the entry for the adjacency matrix
is 2 it's not connected to vertex trees
we're going to be zero there now it is
connected to vertex 4 and just you have
to just be a little bit careful when
you're reading the graph that this edge
here has is vertex or so it's going to
sort of indicate which of these are
connected to which so that tree is there
is connected to that edge that tree
there is connect to that edge enough for
hair is connected to that edge so that
is the weighting from v1 to v4 so
there's a four there so the next thing
we're going to do is is it connected to
v5 no it's not
and what about v6 yes it is connected v6
with a weighting of eight
okay now you seen previously that v1 and
v2 are connected to each other and with
with the edge of and that has with a
wage - and that actually works in
Reverse so v2 is actually connected to
v1 the same way again it's the one
raising a pair of the top and in fact
they all are so what I'm actually going
to do right now to save time is I'm
going to sort of write this row the
first row along the first column because
they there's a symmetric and quality of
what we're doing here zero two zero four
zero eight
so as symmetric quality means if V 1 is
connected V 4 that means V 4 is
connected to V 1 and V 5 is not
connected to V 1 V 1 is not connected to
VD 5 and so on so we have the first one
therefore V 2 so we're just going to
work on the second row now here and we
have the first one for you to V 2 it's
also connected to V 3 and it's not
connected to itself so zero there and
it's also it is connected to V 3 and
with this a 5 here so 5 it's now
connected to V 4 0
it is connected to V 5 without edge of
waiting tree this will here so that is a
tree and a 0 let's now connect the v6
and again what we can do is write the
second row along the second column so we
already is the first two entries there
so they will just have to be completed 5
0 3 0 and again it's to do with the
symmetric quality of an edge if V 1 is
connected to V 2 then V 2 is connected
to V 1 so V 3 we've already got V it's
now connected to B 1 it is connected to
B 2 with a degree 5 with an edge of
waiting 5 it's not connected to itself
it's connected to V 4 we're waiting on
edge waiting of 7 it is not connected to
V 5 but it is connected to B 6 with an
edge with weight 3 and once again write
that along the bottom or along the
column the third
on that things work out and start to
work very quickly once you recognize
that symmetry quality now we're going to
look at v4 it's connected to the one
with a rating of 4 v2 with nowhere edge
that's connected to v3 with a rating of
7 it's not connected to itself it is
connected to V 5 so we have a 2 there
because the waiting is 2 and it's not
connected to B 6 once again 2 and 0 now
v5 it's now connected to V 1 it is
connected to B - we're waiting of 3 not
connected to B 3 it is connected to B 4
we are waiting of at - it's not
connected to itself so we're going to
put in a 0 here and finally it's
connected to v6 rating of 6 and again we
put in 6 here
and finally v6 the only thing that we
have to do now is v6 connected to itself
and what so much so that is the
adjacency matrix for the weighted graph
what I'm going to do now is just sort of
present the answers but clearly more
clearly there is the adjacency matrix
there with the proper notation for the a
of G as well so that's what the answer
should look like okay and in terms of
proper presentation the v1 v2 thing I I
don't at the top of the last side was
just to sort of help guide the I those
column names and row names they were
just had to help guide the I they're not
actually really necessary okay that ends
our presentation
hi everyone today we'll be talking about
the bellman-ford algorithm and it is a
single source shortest path algorithm
which can also work on negative edge
negative edge graphs so according to the
algorithm firstly we initialize all the
vertices to infinity and we set the
source to 0 and then we relax the edges
according to accordingly so I'm showing
you the simulation I'm sure you I'm
certain you understand what I'm talking
about so let's get on with it so all the
vertex vertices are initialized to
infinity and the source vertex is
initialized to 0 and the pipe I array
which is a which is the find predecessor
array it is it is initialized to null
but I guess I don't need to write that
because initially it will be known
anyway according to the algorithm ok so
from the source we then go to the next
vertex adjacent vertex which is a and C
so we update the edges if I come to the
algorithm if DV is greater than D u plus
wuv see this that's the algorithm is D V
is greater than D u plus wuv then we
update the vertex so we write DV equals
to this Plus this if it's greater that
means we trying to find a shortest path
so we just be trying to elect if if if
there preserve the current value of the
crime distance is greater than the one
that then the added distance with this
one and this one then of course we'll
update the distance only if it's only if
the added distance is greater is lesser
than this one so the first is since it
was infinity at the beginning so we then
update it to 0
S is 0 and this is 5 so 0 plus 5 is less
than this one so of course we update it
to 5 since we're trying to find the
shortest path 5 ok so then for C as well
we do the same so we update it to -2 and
then we we write the predecessor as well
don't forget to write this is very to
keep track of what you're doing okay
now s is s is like we are we done with s
now we go select any one either one you
can go from you can start from a or C
we'll just go up you can alphabetically
as it's done we just put a mark here to
indicate that we're done with it then we
go to a from a there's just one which is
one our degree arrow arrow that which is
B with points towards B so a is 5 5 plus
1 is 6 so we updated to 6 and the
predecessor is a yeah so 5 plus 1 6
remember we have to add the current
value with this wuv weight so that will
that is the correct way anyway so then
we go from now that a is done we go to B
we select B or you could select C like
your wish we're going serial wise so
from B we have three outdegree arrows C
D and T so B is value is 6 6 plus 2 is 8
so go towards C oh sorry we don't update
C because C from B to C the distance is
6 plus 2 8 and 8 is greater than minus 2
so we shouldn't update it because we
want the shortest path number so minus 2
will still remain the same and then from
from D from B to D we updated because
infinity is of course larger than 6 plus
7 which is 6 to the 12 which is 13 and
we write the predecessor which is and
then from s to T is infinity we have
obviously updated and then B is 6 plus 3
is 9
ok and then from so we are done with B
now we go towards C we start we take C
as the source now from C we go to wave
or we start from go from minus 2 plus 2
we go to a and
since a is five and then minus two plus
two C from here C minus two plus two
will give us zero so we obviously update
it because it's smaller so new parent is
C and then from C you there is no other
or there is another arrow which which
goes towards D and C is minus 2 and D
this weight is 3 so minus 2 plus 3 is 1
so we obviously update this one as well
so 1 and then C so we're done with C now
we go to D and then from D we go towards
T and D has the new the new weight of D
a distance of D is 1 so from so 1 plus
10 is 11 we don't need to update it
because the current distance is smaller
than 11 9 is less than 11 so we don't
need to update this one okay so yeah so
this is this is the first iteration from
T there is nothing no out degree arrow
so would need to go here okay so this is
the first iteration now for bellman-ford
they're like v minus 1 iteration as in
if there are V vertices how many
vertices are there 1 2 3 4 5 6 so if
there's 6 vertices we go have 5
iterations so we have to do this 5 more
times until we get the shortest its
distance okay so let's do it let's do it
one more time
let's take from start from s s is 0 8
from 0 to 8 from s to a is 5 unit update
because 0 is smaller and s to C is -2
it's already there and then we take a
and from A to B is a is 0 and from 0
plus 1 is B so a 0 plus 1 is 1 so we
just update this one because the
previous it was 6 and the predecessor is
again a but since we're writing it
everything new again so this right we
just might as well write this as well ok
and then after that from now a is over
and then we go to
be from be the the new distance is 1 so
1 so from B to C 1 plus 2 is 3 used to
be still loan interpreted because minus
2 is obviously lesser and then 1 plus 7
is 8
we don't need to update it because it's
1 and 1 plus 3 is 4 so we do interpret
this 1 so 4 and then it still be this is
write it again and then B is over and
then we go to C and then C the the scene
in value is minus 2 minus 2 plus 2 is 0
we don't need to update the same thing
and minus 2 plus 3 is 1 we write update
is still the same ok and then G D the
value is 1 this time so 1 plus 10 is 11
we don't need to update it because 4 is
obviously lesser than 11 smaller than 11
and then TT there is no degree arrow so
we don't do it so I'm just showing you
this one the last time this is the third
iteration and then from s 0 and then s 2
a is 5 greater up there because 0 is
lesser and then s 2 C is -2 the same as
before and then from a a the new
distance is 0 so 0 plus 1 is 1 B we did
it update it and then there's no more
arrow and then from B there's 1 plus 7
for D now we need to update 1 plus 2 3 4
see later played updated and then 1 plus
3 4 40
we already have it from before and then
from C well it seems like it's not going
to change anymore so let me just like
finish with this iteration and then I'll
show you what happens if it doesn't
change
ok so third so from C there's it's not
going to change anymore again anyway
because it's been - - for a long long
time ok and then from D it's been 1 so 1
plus is 10 is 11 we don't update it and
then from T also there's no outdegree
arrow so no more updated anyway so till
the fifth iteration it is still again
the same since it's not changing in code
raishin as well so we can say that this
is the shortest path okay so that's
about it for the iteration now for
detecting the negative edge wait what we
do is we just go to this we just we just
go and check we just do the iteration
one more time since like I said there
are six vertices we do five iterations
right and in the sixth iteration we go
again do the sixth iteration and if that
terminal so if the still relaxes means
if the value the distance is still
change that means there's a we can we
can say that this is like the negative
edge cycle has been detected so for this
like the negative edge report there a
negative edge way negative weight cycle
exists only if in the sixth iteration it
still changes sixth iteration as in the
VF iteration the last vertex F iteration
if it still changes if the value of the
distance still changes if it still
relaxes again and again then we consider
the negative weight cycle exist now for
the complexity of bellman-ford see this
is order B because it's going from B the
whole loop is going up to V and then
this is order e this inner loop this is
obviously order one because it's just
one action that's doing it's an if
function so the total analysis the total
NASA shows that they hole at a whole
complexity of government for is out of V
into e because this is a nested loop so
we just take order of V and like this is
order B so last order V into E and since
out of ghee into E is greater than order
V we just take order being key as the
greater one so that's the final time
complexity so yeah that's about it about
bellman-ford I hope you understood I
hope you understood my explanation
properly and well please subscribe if
you want more tutorials and thank you
for watching
in this video we're going to be talking
about weighted graphs and spanning trees
and these are just two topics that will
sort of be introductory for some things
that are to come so first a weighted
graph is a graph in which each edge is
assigned a value or wait okay so let's
just take a look at this graph so here
we've got a regular graph for order five
right v1 v2 v3 v4 v5 and there are
various edges and so let's go ahead and
put a weight on each of these edges so
you can have integer weights like one or
three you can have fractional weights
maybe three force on this one or
negative weights and they don't even
have to be numbers I mean for this class
we will just stick to numeric weights
but they don't have to be numeric whites
and they can be decimals and we'll just
round this out with these okay so we had
eight edges until we have one two three
four five six seven oh this top edge is
missing a wait how about four okay so
this is an example of a weighted graph
now for us at least every time we talk
about a weighted graph every single edge
will have a weight so you're never going
to have a mixture of unweighted edges
and weighted edges if one way it has an
edge then the rest of them should have
an edge as well so this is an example of
a weighted graph and the way that you
talk about these things you might say
the weight of v1 v2 so remember v1 v2 is
that's how we do no edges is to list the
vertices so this edge is v1 v2 right so
the weight is going to be 1 so we use
this little W a lowercase W to represent
the way similarly how about the way v3
v4 what would that be well you find v3
you find before the edge connecting them
negative one-half and similarly
so nothing fancy here this is just the
definition of a weighted graph is every
edge you get some sort of value and
there are a lot of reasons where you
might be interested in doing this maybe
this represents the vertices our cities
and the weights represent the distance
between the cities now of course that
wouldn't work here because we have
negative distances but maybe the
vertices our customers and the weights
or how much profit you will get from
shipping X units of your product to them
so here you would lose money if you sit
from this customer to this customer but
you would get a lot of money from
sending this customer to this customer
so just like directed graphs having
directions on edges and having weights
on edges are just two ways that you can
get extra information into a graph okay
so that's weighted graphs the second
topic is a spanning tree and a spanning
tree so remember you should have read
the section on trees already but a
spanning tree is a connected graph or in
a connected graph is a sub graph so
remember what that means a sub graph of
the graph that uses every vertex and is
also a tree meaning it's connected and
has no cycles okay so let's just take an
example here in pink draw a three
spanning trees of G so here's G so the
first thing to remember is where I sub
graph means that all the vertices of our
spanning tree have to come have to match
up exactly with these vertices right
because it uses every vertex of G ok so
I've gone ahead and drawn three copies
of the vertex set one for each tree
right because we know it has to use
every vertex and then otherwise it has
to be a tree which means that all these
vertices need to be connected and that
none there's not allowed to be any
cycles in the edges that we choose ok so
for example let me just draw one here
this is a spanning tree right all of
these edges exist in the regular graph
right these for all the vertices exist
in the regular graph so that makes it a
sub graph
and this graph also is a tree because
it's connected with no cycles okay let's
try another one how about this one right
ok so again it's connected with no
cycles and each one of these edges is
present in the original graph which
means it's a sub graph ok so here are
two spanning trees so maybe you should
pause for a second if you want and try
and construct a third spanning tree
that's different from these two and when
I say different I mean non isomorphic ok
we're ready how about this one and there
are a lot of answers here but that would
also work right this edge this edge this
edge and this edge again it connects all
the vertices all these edges are present
in the original graph and if you wanted
to check that all of these are non
isomorphic you can just consider the
degree sequences so for example the
degree sequence of this is for 1111 the
degree sequence of this is two to one
long one right to 20 to 22 11 to two to
11 right and what's the degree sequence
of this 32 so three and then two and
then 111 right and not isomorphic graphs
right i mean if they've graphs don't
have the same degree sequence there
certainly no annoy some orphic so here's
an example of three non isomorphic
spanning trees all of which go with this
graph and there are more examples in the
textbook if you'd like to look at them
but this is an introduction to weighted
graphs and spanning trees
whew we're going to have a series of
lectures on shortest paths and one of
the big differences between this module
and the previous one at least from a
mathematical standpoint is that we're
going to be looking at graphs that have
weights on their edges so when Eric
talked about depth-first search and
breadth first search in the last couple
of lectures we had directed graphs and
undirected graphs but we didn't really
have attributes on the edges in
particular you have a much richer class
of problems and applications if you
allow for weights on graph edges and
these weights can be had you know
integers they could be a real numbers
irrational they could be negative what
have you and for a different classes of
graphs and and different restrictions on
weights there's really a set of shortest
path algorithms that we'll look at in
the next few lectures which are kind of
optimized for a particular application
so we won't do specific algorithms today
but they'll set up the problem we'll
talk about the general approach that
most shortest path algorithms take to
solve a particular instance of a problem
and then we'll close with talking about
that particular property that's pretty
important that's called the optimum or
optimal substructure property that is a
technique that most shortest path
algorithms are actually all shortest
path algorithms use to get efficient
complexity so asymptotic complexity I is
important obviously and we're always
looking for the best algorithm with the
best asymptotic complexity an optimal
substructure is is a hammer that we're
going to use to get that so the
canonical motivation of course
for shortest paths is now if you want to
steal or I guess borrow a cannon from
Caltech and and bring it over to MIT
then you want you know the fastest way
of getting here with with your I guess
your your illegal goods and you want to
find the shortest way or the fastest way
of getting from one location to another
so Google Maps go from point A to point
B that's a classic application of the
shortest path problem in this case you
could imagine that a distance would be
something that would be a very simple
metric that you could use for the
weights on the edges so for this entire
module we're going to be looking at a
graph G ve w and you know what V and E
are there the vertices and the edges and
w is a weight function that map's edges
to weights and so we're adding that in
here and said W would be e to our so the
set of real numbers we're going to be
looking at two different algorithms in
subsequent lectures and you'll implement
one of them in your problem set a the
simpler algorithm which we look at first
is called Dykstra after edgier Dykstra
who did some seminal work in concurrent
programming won the turing award but on
the side invented this cool algorithm or
at least gets credit for it I called
Dijkstra's algorithm that assumes
non-negative at Wade edges so I should
really say non-negative so read that is
non-negative and that has a complexity
of order we
e log we + e alright so this is you know
practically linear time and typically
you're going to be dominated in many
cases by E I what is in general if you
talk about a simple graph what's the
asymptotic relationship between e and we
can you relate etv and give me a bomb
sorry three squared thanks that's good
so you can think of e as being auto v
square and you could suddenly have
that's worth the worth of Christian and
so now you can kind of imagine a
complete graph and a complete graph is
something that has an edge between each
pair of vertices and that's where you'll
get evening in at eighth of a square
okay so when you say simple graph you're
saying you have at most one edge between
any pair of vertices a multi graph is
something that could have multiple edges
between pairs of vertices we won't
really be talking about multi graphs I
in this sequence of lectures in but
something to think about or keep in the
back of your of your mind as we go
through these algorithms and so the
dominating factor here in many cases
really is is e and Dykstra is a nice
algorithm because it's linear in the
number of edges okay so that's Dykstra
and that's the first of the algorithms
that will we look at next time though we
will see the general structure of
Dijkstra today and then there's the
bellman-ford algorithm that works on
positive and negative edges wait edges
and this has a complexity auto ve ok so
you can imagine a particular
implementation of bellman-ford running
in order we cube time ok because II
could be v square and you got this
additional efactor so its Auto V cubed
versus order V logged we so when you
have a chance use Dykstra right you know
when you're when you're stuck on you'd
you'd want to do a bellman Ford because
you have these negative wait ages and
one of the challenges and negative wait
ages and I'll say a little bit more as
we go along
is that on you end up having to have to
find cycles that are of a negative way
because they kind of throw off your
shortest path algorithm if you were just
assuming that a shortest path lengths
are only going to decrease but when you
have negative weights I you might you
know take a step and the overall weight
might decrease right so this is kind of
a longer path in terms of the number of
edges but the weight is smaller and that
kind of makes the algorithm more
complicated and has to do more work
right so that's really why there's a
difference between these two
complexities and I guarantee you you'll
understand this much better after we're
done with the lectures on Dykstra and
the lectures on bail bond for okay so
that's the setup for the problem that's
what we're going to be looking at let's
set I look at a couple of more
definitions beyond what i have here with
respect to just the notation and you can
think of pat p as a sequence of vertices
v-0 v1 etc to VK and this is a pad if we
I VI plus 1 belongs to e for 0 less than
or equal to i less than or equal to k
right so a path is a sequence of edges
and each of those edges has to be in the
graph has to be in the set of edges II
and W of P which is the weight of the
path we know that by the weight of edges
those are easy they're given by the W
function the weight of the path is
simply the summation of the weights of
the edges all right so fairly obvious
definitions but obviously we have to get
these right in order to to actually
solve the problem correctly and the
shortest path problem
is as you can imagine is something that
I tries to find a pat p that has minimum
weight okay so in general you have some
setup for the problem but it comes down
to fine p good and then many many
possible paths you have to understand
that they're potentially an exponential
number of paths in the graphs that we
would consider and here's a real simple
example where you'd have an exponential
number pats and we come back to this
example later in the lecture but let's
assume that all the directions go this
way and it's a directed graph well you
could have the path that goes all the
way here but you can have the fat that
goes on top and all the way this way you
have basically two choices on getting to
this vertex then you got you know given
the two ways you can have of getting to
this vertex you've got four ways of
getting here and then you have eight
ways of getting there so on and so forth
okay so there's an exponential number of
paths potentially the other thing that's
interesting here which is important in
terms of this complexity is what's
interesting about what you see here with
respect to the complexity and what you
see here all right anybody want to point
that out so so i have this complexity
here and an auto v ER there what you
know what's an interesting observation
if you look at this board here and the
two complexities anybody yeah back there
it's not a function of way great that's
definitely worth the cushion and i'll
let you throw this one all the way back
there all right right all right good
good good that was good those better
than what I could do no not really but I
would have been writing this hands right
there okay anyway so I that's a great
observation actually and I should have
pointed that out right up front but I
mean I'm glad I got it all to you aw
doesn't exist in the in the complexity
okay this is pretty important ok w could
be a large number I mean it could be 2
raise to 64 um the fact is that there's
only a square different values possible
for a weight right I mean roughly
speaking if you have a complete graph is
a simple graph it is order e square
possible weights okay but the range of
the weights could be exponential I could
have an edge weight of 0 point 0 0 0 1
and a different edge weight of 10 raise
to 98 okay there's nothing that's
stopping me from doing that or putting a
specification like that but the nice
thing about Dykstra and bellman-ford and
virtually all of the algorithms that are
useful in practice is that they don't
depend on the dynamic range of the
weights okay and so keep that in mind as
you think of shortest path algorithms
and we'll talk a little bit about this
in section tomorrow the tea is well as
to why Bret first search and depth first
search aren't directly applicable to the
shortest path problem ok and the hint
really is the the dynamic range of the
weights ok I so keep that in mind so a
couple of things why this is an
interesting algorithm I or interesting
problem to solve and harder than the
problems we've looked at so far like
sorting in surg is that you have an
exponential number of paths ok and then
the dynamic range of the weights can be
very very large and it's not linear by
any means all right so these algorithms
are going to
to have some smarts and the optimal
substructure property that we look at
towards the end of today's lecture will
give you a sense of how these algorithms
actually work in basically linear time
or ve you can think of that as being
cubic time in terms of the vertices so
keep that in mind let's talk a little
bit more about weighted graphs I want a
little bit more notation um and what i
have is v-0 using pat p 2 VK so i'm
going to write that to say that there's
a particular path of v02 VK sometimes
i'm searching for the pat p with a
minimum weight and that's how i'm going
to represent that V zero which is a
single vertex fat is is the path from V
0 to be 0 so it's really a zero-length
path and it has wait 0 all right so
that's one condition the other condition
that we need to look at which is the
other case is what is there isn't a path
so I want to put those two things
together the two extremes and of course
all of the cases in between in this
definition of the shortest path weight
and so I'm going to talk about the
shortest path the value of the weight of
the shortest path between you and we as
Delta u comma we and my goal is to find
Delta it's also to find the path it
doesn't help you very much if you know
that there's a way of getting from here
at Lexington I within 14 miles if you
don't know what that path is right so
that's one aspect of it which is you
want to get the weight but you want to
get the path as well and these
algorithms will do that for you and in
particular what we want is Delta u v
to be the minimum over all the pats w p
such that p is in fact a path from u to
V and this is the case where if there if
there exists as any such pad and the
last thing is you want this to be
infinity the way to be infinity
otherwise so if you're only talking
about roads are going from here to Tokyo
should have length infinity a little
matter of the Pacific Ocean in between
right so you see you so that's the setup
in terms of the numbers that we want to
see if you're starting from a particular
point you can think of the the shortest
path length from your source as being a
0 initially everything is infinity
because you haven't found any Pat's yet
and what you're going to do is try and
reduce these infinities down for all of
the vertices that are reachable from the
source vertex and it's quite possible
that you may be given a graph where
there a particular vertices or in your
set V that can't be reached from the
particular source that you started with
and for those vertices you're going to
have your delta u v if v is unreachable
from you it will stay at infinity ok so
let's look at an example let's take
it's going to be an iterative process
here of finding the shortest paths and
so let's take an example that
corresponds to a fairly complex graph or
at least a non-trivial one where that's
my source vertex and I've labeled these
other vertices I'm a through f and I
have a bunch of edges five
I got one more here so that's why it's
given to me and I want to find Delta s
plugged in for you and a B D etc plugged
in for wii for this graph and let's
let's just do this manually if you
rollin I just trying to do some kind of
you know breadth first search and we do
know a breadth-first search we know
depth-first search you can imagine
trying to use those notions to try and
find the shortest paths here so now we
have to prove afterwards when we are
done that these are in fact the shorter
spats and that's the hard part of it but
we can certainly try and fill in some
numbers associated with paths that we do
know about so I'm going to say that the
numbers that are inside each of these
vertices Saudi of you is the current
weight and so initially I'm going to
start with D of s being zero because I
that's the source and all of these other
ones are going to have I'm not going to
write this down but they're going to
have infinity for their their d of reefs
Saudi of a is infinity d of B is
infinity etc and what I want to do is
decrease this d number to the point
where i'm confident that all of the d
numbers that are inside these vertices
which are the current weights are end up
with that being the Delta numbers right
so my algorithm is done when my D
numbers shrink down and I got the Delta
values the correct Delta values but if I
wanted to do this sort of as you know
seat-of-the-pants approach just go off
and try and iteratively reduce these
numbers you say well this one was
infinity but clearly if I start from s
and I follow the edges in s I'm going to
be able to mark this as a 1
okay and similarly here I'm going to be
able to mark this is the two and now I
could arbitrarily pick this one here and
this a vertex and then start looking at
the edges that emanate from the a vertex
and I could go off in and mark this as a
six for example and if I start from here
at mark this as s3 now isn't is it in
fact true that I that six equals is is
Delta s comma C equals six no um what
what is in fact is that a better way of
getting to see and what what is the
weight of that what's the what what
expert X do I have to go through I mean
one way is to go from s to B to D to C
right and that would give me five right
so that's five can I do better than 5
i'm not in this graph okay so it's not
the case that the shortest length Pat
gave you the shortest way of the
smallest weight right I mean that was
one example of that and I can go on and
bore you with filling in all of these
numbers but you could do that on your
own and it's really not particularly
edifying to do that but you get a sense
of what you need to be able to do in
order to converge on the Delta and it
might take some doing because you have
to somehow enumerate in an implicit way
you can't do it in an explicit way
because then there'd be a an exponential
number of paths but you'd have to
implement Leah numerate all the
different ways that you can possibly get
to a vertex and discover the shortest
path through that process all right and
so we have to be able to
do that in the shortest path algorithms
and this is a simple graph that has
positive weights non-negative weights
for the edges I it gets more complicated
when you when you have negative weights
but before I get to that there's one
other thing that that I want to talk
about here with respect to discovering
the actual path right so what we did
here was we had Delta UV that
corresponded to the weight of the
shortest path but if you want the path
itself we need to have a way of finding
the sequence of vertices that
corresponds to the minimum weight path
and in particular we're going to have to
define what we call the predecessor
relationship and so what I have is D of
V is the value inside the circle which
is the current weight and as d is
something you're very interested in
eventually you want it to go to Delta
the other thing that you're very
interested in and this is really a
fairly straightforward data structure
corresponding to you know just the D
number and this predecessor number and
PI of V is the predecessor vertex on the
best path to be and you said x of s
equals nil right so and you can think of
this as as this is eventually what we
want but and this gets modified as well
so so right now when you're working and
chronic find the pad you have some
particular path that happens to be the
current best path and that's the
sequence of vertices that you can get by
following the predecessors so once
you're at a particular vertex
e you say all right right now I can look
at PI of E and if that points me to see
then that's good i'm going to look at pi
of c and that might point me to a and so
on and so forth in this particular
instance i pi of e is going to vend
you're finally done is going to point to
a and pi of a is going to point to s
alright because that's the the path that
that is the best part is this one like
so and like that and so those are the
two data structures you need to keep in
mind you need to to iterate on this
predecessor relationship and the current
distance and then this ends up being
Delta you're done and at that point your
predecessor relationships is correct
okay so that's the setup the last
complication i want to talk about here
there's negative negative weights and
it's i think appropriate to talk about
it when we have bellman-ford up here
which is really the general algorithm so
let's talk about so the first question
is why why does these things exist other
than making our lives more difficult
right so give me an example what's the
motivation for a graph with negative
weights no the best I mean I really
would like to know the best motivation
is definitely worth the cushion and then
I can use it next time yeah go ahead
sure yeah i mean i think that's it
that's a good motivation are you if you
know i think driving when you think
about distances and so on there's no
notion of a negative distance at least
physically but you can imagine that you
could have the case where you're getting
paid to drive or something or you it
costs you to drive right and that would
be one yeah go ahead ah or if you land
on something you have to pay rent or
sometimes you land on something you
actually get money takes you forward
backwards right yeah go ahead
so that that's an interesting notion
sometimes you may want to go and maybe
in this case you're saying it's better
to choose you know take your distance
metric and go further away in order to
get the best way of getting there or
something like that
right sure don't be good right Victor
you had your hand up
right yeah that maybe that's a good
example one of the things that we have
to think about is and this is something
that might come up by the way in the
problem set or a quiz which is I is
there a way of shifting these weights to
make them all positive right so the
examples we've talked about not here to
me that I in the particular settings
that we talked about that you can
somehow sort of create the base case to
be zero rather than being negative right
so I just may not may not be possible in
a particular scenario but if you can do
that and the reason I bring this up is
if you can do that suddenly instead of
using an order ve algorithm if you can
prove correctness of that the final
solution is exactly what you have gotten
for the initial problem specification
you want from an order ve algorithm to
an order V log V algorithm so that's a
wonderful thing to do so so keep that in
mind try and get rid of negative weight
edges if you can without changing the
problem specification I saw a hand back
there ok yeah so so that's something to
keep in mind one example that I think
it's come up here which you know came up
i think the last time i lectured was
imagine that you're driving and you know
they're all these advertisements and you
get paid to drive on a freeway so the
reversed all right I mean it's a divorce
stole because you get to go there and
you have to see all these ads right and
then yeah I guess you drive pretty fast
through those ads but but but you have
to go through and so you get it you get
paid to go through those those
particular roads and then what about
social networks you know I'm this you
know liking people and disliking people
I mean that sounds pretty you know
that's negative and positive one can
imagine that social networks would have
positive weights and negative weights
I'm surprised you know one of you I mean
I don't have an account on Facebook but
presumably you guys do so so think of
think of the what's the yeah that's
right well I'm not sure how this works
but you guys figure it out um so why you
know reverse Joel social networks
lots of things even if you're not
convinced by the motivation I will spend
the whole lecture talking about
bellman-ford okay so that just so that's
clear okay so the issue with the
negative weight cycles is something that
is worth spending a minute on and I
talked about the fact that you had an
exponential number of pats and that
causes a bit of a problem even in the
case where you have positive weights and
i will revisit that example but here's
the even worse problem that corresponds
to negative cycles so eventually you
want to terminate the faster you
terminate and if you can talk about
asymptotic complexity obviously that
means that you've terminated within a
worst-case bond of time and I if that's
exponential that's bad you'd want it to
be small but what if you didn't even
terminate right so suppose you have
something like like this where do you
have a graph that has negative weights
on some of the edges but others are
positive so this one is a minus 6 i
think i got those right I'm so to 4-6
over here 3 2 1 and minus 2 so one thing
that you notice from this graph is that
you got this annoying cycle here that's
a negative weight cycle and that's why
I've picked this particular example
minus 6 plus 2 is minus 4 minus 4 plus 3
is minus 1 so if you had something where
you can't depend on the fact that the
deltas the DS are going to keep reducing
and that eventually they'll stop
producing well that's true eventually
they'll stop producing because they're
lower bounded by 0 then you have
positive wait
edges are non-negative wait edges but if
you have a graph with a negative cycle
and this is a recipe for an infinite
loop right in your program potentially
above but maybe not even a bug it's not
a bug and implementation but a bug in
the algorithm because this the
termination condition isn't set properly
so you could imagine that you would get
to be and at the first time whoops I'm
missing wait here so you get to be and
you say well I I'm done I delta of s B
is for but that's not true because you
could get to be and then you could get
back to be with the weight of three and
then you can do it again with the weight
of two and so on and so forth alright so
that's the problem so what would you
like an algorithm to do what would you
like the bellman-ford to do here um it's
not the case that all of the Delta
values that is the shortest path values
are undefined for this graph some of
them are well-defined right um this one
you can't ever get back to it so clearly
Delta s s is 0 right everybody by that
right what about this one it's to write
Delta s a is to write and everybody buys
that because there's no way you can't
you don't touch a negative weight cycle
you in fact you don't touch a negative
weight edge but more importantly you
don't touch a negative weight cycle in
order to get to a and there's no way of
touching that on the other hand I'm
anything that's in here you could run
many times and you could end up with
whatever weight you wanted you know it'd
be at minus infinity weight right so
what you want an algorithm that handles
in particular negative cycles which are
the hard part here right negative
weights aren't the hard part if you
can't run through these edges more than
once it's actually the negative cycles
that are hard and the negative cycles
are going to make shortest path lengths
indeterminate but not necessarily for
every node in the
graph like this example shows so what
you want your bellman-ford algorithm to
do are your shortest path algorithm that
handles negative cycles to do is to
finish in reasonable amount of time auto
ve will take and give you the Delta
numbers for all of the vertices that
actually have finite numbers and then
mark all of these other vertices as
being indeterminate are essentially
minus infinity ok so that's your
termination condition it's it's it's
different from the termination condition
if you simply had non-negative edge
weights all right so so remember its
cycles that cause a problem not just the
edges and you have to do something about
the cycles but they may not affect the
entire part of the compensation so if
you don't know that you have a cycle or
not then you end up with having to use
bellman-ford and so that also tells you
something which is interesting which is
bellman-ford has to detect negative
cycles right if Bell and Ford couldn't
detect negative cycles then how could it
possibly be a correct algorithm for the
arbitrary case so Dykstra doesn't have
to do that and that's why I Dykstra is
simpler all right so let me talk about
the general structure of shortest path
algorithms and the two important notions
that I want to talk about here are the
notion of relaxation which we sort of
did already but I then we ran through
this example but I need to formalize
that and and then we'll go back and
revisit this exponential graph example
or so the general structure of shortest
path algorithms are as follows we're
going to initialize for all you
belonging to the vertex set we set DB to
be infinity and we said the predecessor
to be mill
and then we'll set V of s to be zero
they're talking about a single source
here we set that to be zero and what
we're going to do is essentially repeat
select some edge you come up we and I'm
not specifying how this is going to
result in a different algorithm
depending on the specifics of how but
the important notion is that we're going
to relax edge UV and what the notion of
relaxation is is that you're going to
look at it and you say well if D of V is
greater than B of you plus W you we then
I'm going I've discovered a better way
of getting to V then I currently know
Saudi of V is you know currently be
infinity which means I haven't found a
way of getting to V yet but I know that
d of you for example is a finite number
and I do know that this edge exists from
u to V which means that i can update the
value of D of V and that's what we call
relaxation of of the edge UV and so what
you do here is I in if the if is true
then you set DV to be d u plus W UV and
you'll also update the predecessor
relationship because the current best
predecessor for you I'm sorry for wii is
going to be you alright so that's the
notion of relaxation and I kind of ran
out of room here but I that you keep
doing this this repeat so what what is
the repeat while the repeat is until
all edges have D of V less than or equal
to D of U plus wuv okay and the
assumption here is that you have no
negative cycles but we need a different
structure the notion of relaxation is
still going to be relevant but don't
think of this structure I'm as being the
structure that bellman-ford uses our
algorithms that can handle negative
cycles use so hopefully you got the
notion of relaxation which is from a
pictorial standpoint it's simply
something that we did when we looked at
updating the value of 625 for example
right so we said I through this process
if I if I drill if I relax this
particular edge and D was already set up
let's say D the vertex here had three
and this was originally six and I look
at it and I say d of C is six on the
other hand a 6 is greater than D of the
vertex D which happens to be 3 plus 2
and since 5 is less than six I can relax
this edge and update the value of 625
all right and then I update the
predecessor relationship I do to have a
pie of C 2 BD ok that's the notion of
relaxation fundamental notion going to
use it in every algorithm that we talked
about when do you stop well then you
don't have negative cycles there's a
fairly clean termination condition which
says that you can't relax any of the
edges anymore ok you get to the point
where you have values that are
associated with each of these vertices
inside and it doesn't matter what edge
you pick you can't improve them ok so
I'm this termination condition
it could involve an order echeck okay so
you're not talking complexity here yet
but but in terms of being efficient but
you can imagine when I say until all
edges cannot be relaxed that you'd have
to look at all the edges and if any one
of them can be relaxed it's possible
that another one it could now be relaxed
right so you got to keep going until you
get to the point where none of the edges
can be relaxed all right so this is a
brute force algorithm and it will work
it just be slow ok it will work for no
negative cycles and if you just kind of
randomly select these edges and just
keep going I'll give you an example
where it works pretty badly I in in a
minute but but this is an algorithm
right so I guess I guess I lied when I
said we weren't going to give you an
algorithm it is an algorithm it's just
an algorithm that that you never want to
implement you do want to implement the
relaxation condition but not this random
way of selecting edges and having this
termination condition that it in and of
itself is an order echeck ok and one of
the reasons why you don't want implement
this algorithm is coming up shortly in
our exponential graph example but let me
make sure that people aren't bored any
questions about the general structure
relaxation anything I'll be good ok so
you guys you know I walk away from
lecturer thinking I've given the
spectacular lecture and everybody
understands and then Victor tells me
when he shows up in section in the
morning he says you know what do people
did people understand graphs and
everyone says no right or do people
understand X and people say no so at
least tomorrow tell Victor that you
understood ok whether you did or not ok
so then I feel better so yeah right so
good well you probably like hearing
stuff from Victor better than me anyway
that's that's the that's the secret here
right so
all right so um one of the reasons why
you don't want to implement this
algorithm is precisely this example that
I put up and this is a really neat
example that I like a lot because it
points out two different things it
points out that exponential number of
paths and exponential number of paths in
a graph could cause a problem with this
algorithm the other thing that is points
out is that we got issues with the
weights of edges one of the nice
observations one of you made earlier on
is that we had these neat algorithms
that did not depend on the dynamic range
of the weights so let's just say that I
in fact had an exponential range for the
weights and up for isn't exponential but
you know at some level you could imagine
that it's exponentially related to one
or two and the point here is that if i
created a graph that looked like this
where i have v4 v5 v6 e7 v8 and it had
this in this structure then i'm going to
end up having something like to raise to
n over 2 wait if I have n vertices in
this graph or at least the dynamic range
of weights is going to be 2 raise to n /
2 everybody by that right so so that's
an so think of this graph as being a
fragment of this large graph which where
n could be a hundred and the weights
could be you know to raise to 50 and to
raise 250 is in the number that we can't
handle on a computer right it's still
less than 64 bits right so so it's a
perfectly reasonable example right and
we talked about multiple precision
arithmetic infinite precision arithmetic
so if we can handle arbitrary numbers of
it arbitrary precision so there's
nothing that's that stopping us from you
know putting square root of two and and
all sorts of things we want to imaginary
numbers but yeah you can imagine putting
numbers with high dynamic range as edges
in a particular graph and expect the
Dykstra assuming that all of the edges
are non-negative that Dykstra should be
able to run on it okay so what happens
with this example well with this example
here's what happens let's say that I ran
this this algorithm and initially I you
know just follow this chain here okay
and I get you know this starts with 0
and this is a four because I get there
at four this one is eight and this is 10
and this is twelve thirteen fourteen
okay and that's the initials a pass
that's the selection I'm what ends up
happening is that I you you could not
relax at this you see 14 and let's say
you relax this edge you see that you
know 12 and 14 you turn that into 13
right and then when you relax this edge
this turns into 12 okay so that's you go
through that process now this one stays
12 but now you relax this edge and so
this 12 becomes 10 and then when this
changes you need to check if you relax
you know this edge first then this 13 is
is going to become 11 or it doesn't
really matter this becomes I guess 11
and is that right yeah this is 11 and
that's 11 as well it might start out
being 12 if you relax this edge and that
edge so you might go to 12 to 11 and so
on and so forth so for a pathological
ordering I won't belabor the point but
you see that you're going 14 13 12 11
with a bad ordering that corresponds to
the selection of the edges okay and so
if the overall weight here and overall
weight here when you start out with is
going to be ordered to raise to n over 2
okay and you could be in this particular
graph
relaxing edges an exponential number of
times in order to to finish okay and so
the number of times you relax an edge
could be of the order of the weights
that you start out with and that makes
this algorithm an exponential time
algorithm so clearly we have to do
better than that when it comes to
Dykstra okay our bellman-ford so how are
we going to do better than that yeah
question back there
Oh even that you're exactly right
there's an issue with the ordering that
we've chosen okay and but but what you
have to show is that for any graph that
at the particular ordering that you
choose will result in V log V Plus E and
so on and so forth so you're exactly
right I mean it's an issue with the
ordering we've chosen this is a
pathological ordering it's just meaning
to say that we have to be careful about
how we select ok if you select it wrong
you've got problems alright and so the
purpose of next week is going to be how
do we select these edges properly okay
and so I leave you with this notion of
very simple notion of optimal
substructure using you know two very
simple theorems that you can prove in
literally a line of text and the first
one says as sub parts of a shortest path
our shortest paths okay and all that
means is if I had v-0 and I went to be
one and i went to be too and these these
could not these are pads here so this
could be p 0 1 p 0 to p 0 3 and so that
many vertices potentially between V 0
and V 1 and if you tell me that v-0
through v3 the concatenation of T 0 1 p
0 2 and sorry p.03 are a shortest path
if this is an SP short ass pad then that
implies that each of these our shortest
shortest paths as well right and that
makes sense because if in fact there was
a better way of getting from v-0 to v1
that was better than p.01 why would you
ever put p.01 in here you would use that
better way right so very simple that's
what's called the optimum substructure
property and this notion that I of the
triangle inequality is also a
related to that and that simply says
that if I have something like this where
i have v-0 v1 and v2 then I'd up when I
look at the delta value of v-0 we won
and I compare that with the Delta values
of V 0 v 2 and v 2 v 1 then I this is
got to be smaller than or equal to this
plus that okay and that again makes
sense because if if this if this plus
this were smaller than that well you
know remember i'm talking about pat's
are here not edges and the better way of
getting to be one would be to follow go
through v2 rather than following this
path up on top amazingly these two
notions are going to be enough to take
this algorithm and turn it into
essentially a linear time algorithm and
we'll do that next time all right I'll
stick around for questions
writer graphs now here's where we place
a number on the edges so now we've got a
weight that's why it's called a way two
great examples of weighted graphs arise
from the breast vertices of graph our
towns on a map and the edges are the
rise between the towns so for example
that 12 could represent kilometres
that's right two towns whatever it is so
that's what the way that's what the way
is now a tree is a connected graph that
contains no circuits here is an example
of a tree there's no loops er no
circuits we can't go from either G we
have to go around the town's a tree with
has no multiple edges simplest tree is a
single vertex but is a tree yeah a tree
with n vertices has n minus 1 edges
another rule ok minimum spanning tree
here's where we try and minimize the
distance between these vertices quite
easy to do and there is the rule we
start with the smallest length on the
vertex in this case it was number three
and then we have to connect it so we
have to connect to either C or D and we
use again the smallest one that connects
in this case it's 55 or 60 it doesn't
matter choose one of the fives or chose
this one here and then again another one
that connects another verdict well we've
got only got a to go and see easiest way
to connect this one is through here
because that's a small swam so we get
this minimum spanning tree that's shown
in Figure twenty three point two three
ok a spanning tree is just a sub graph
that contains all the vertices of the
original graph into the tree so we have
to use all the verses a minimum spanning
tree for a weighted graph is a spanning
tree for which the son of the weights of
the edges is as small as possible that's
why we choose the smallest numbers all
the time all right here we have prims
algorithm is its which is a set of rules
to determine a minimum spanning tree
forever so I guess some you know these
are the three rules that you've got
you to use it but I don't think we need
to go through it you just be aware of
that you've got this Nikki Bella the
steps where you're just going to do it
with you as an example I've already done
will apply prims algorithm here to turn
the minimum spanning tree for this craft
so then it wants us to write down it's
white and can compare the way to the
original graph now the original graph if
you add them all up it all adds up to 50
okay so this adds up all 257 I see your
regional great all right my cell will
start at Point ay OH doesn't matter
where we said well now we should start
where there is a smallest number this is
the 202 on the other edges it doesn't
matter we'll start at either be ok so we
start here and then we go right we've
got to choose this one there we go we've
chosen that one now we need to connect
either I to something else or B do
something else with the smallest number
on it so I today it gives us five walk
connect that one there up there it is
and then the next smallest line mister
donut is number three doesn't matter
salgo d to see that connects each virtus
see see now we have to connect either e
or if there's no point going a to f
because that seeks we've got a five from
CD so we'll connect CD that's fine we
have to connect if eat if is only two so
we'll connect that one there and that is
our minimum spanning tree they want us
to write down its way in compared to the
original the original was 50 and if you
add all these are built that up to it I
think it embodies 7 and 3 is 10 and 5 is
15 and 2 is 17 so that's the minimum
spanning tree 17 compete to fit so in a
real-life situation we can just sort of
say that ok so these are let's say road
2 kilometers long we're going to like
cables there we need 17 kilometers of
cables that's right you know could be
internet cables or phone lines or what
about 187 m kays worth of cables for the
50k roads that's right we could do the
50 but that's going to put more cost us
more so rather do the 17 now their
recent note if you're ever asked to find
the maximum spanning tree you start with
a maximum weight and keep finding the
maximum one adding to it ok not the
minimum like we've just done 23 years
your questions thank you
our third presentation in this graphs
unit is on weighted graphs and directed
graphs let's go back to what we started
at the beginning of this unit when we
talked about trees and tree diagrams
originally you knew tree diagrams is
what we use in probability but now with
new concepts of paths and graphs we can
define an even better a tree is a
connected graph with no simple circuits
keeping in mind that a simple circuit
contains no repeating edges a simple
circuit just hits every edge just one
time a tree can also be understood as a
type of connected graph let's look at an
example the following graph can be
considered to be a tree notice how it is
a connected graph and it rip in is not
as it has no simple circuit meaning we
cannot start an edge at the start and
end at the same vertex without repeating
edges we need to repeat our edges the
following is not a tree because we have
a simple circuit here a b c d na is a
simple circuit we started under the same
vertex and we hit every edge just once
therefore this is not a tree now that
we've redefined our tree diagram in our
new language we can now introduce you to
what a directed graph is basically a
directed graph is when your graph has a
direction each edge in a directed graph
has an arrow given the edge some
direction these kinds of edges with an
arrow are called arcs in a directed
graph note the following a path is a
sequence of consecutive arcs that may or
may not repeat starting and ending at a
different point a circuit is a path that
begins and ends at the same vertex and
finally a path or circuit is simple if
it contains no repeated arcs
we're calling the marks in this case
because a directed graph has edges with
arrows and we call those arcs here's an
example of a directed graph notice how
is the same thing as a graph that you've
seen in the previous presentations
except now your graphs have arrows
there's a reason for these arrows if you
are going to make a path you have to
follow the arrows you can't go from D to
F for example it has to be from f.2d and
then to eat in this graph de MFD GF are
examples of Arc's f d e is an example of
a path and notice that it's FTE not ed f
and g f d going through the one here not
the two so g FD 1g is a circuit we're
starting and ending at the same vertex
and we're following our direction of the
arrows just to review gigi is a loop d 1
g and d 2g or parallel from our first
power point for this chapter test
yourself on this graph here it is can
you find an order path and maybe an
Euler circuit how can you tell whether a
graph has an Euler path can you find a
Hamiltonian path or a Hamiltonian
circuit let's talk about weighted graphs
now a weighted graph is a graph directed
or not we're a weight or unit is
attributed to each arc or edge the
weight of a path corresponds to some of
the weights of the arcs or edges that
make up the path let's see an example in
the adjacent graph here you'll notice
that regardless whether there's arrows
or not each of these edges have a weight
or a unit given to them the weight of
segments EE is for because you see this
for
here the weight of a d e and c is adding
all of their paths together so if we
start at a d is 9 to e is 82 c is for
adding them all together nine plus eight
plus four is 21 so the weight is 21 and
just to keep testing yourself k try
finding a oyler path or a hamel turning
our Hamiltonian path or circuit in any
of these graphs so it's good practice
for you to try and be able to analyze
what an Euler and what a Hamiltonian
path and circuit is so let's recap this
PowerPoint first we started off with a
new definition of a tree a tree is a
type of graph that has no simple
circuits and that all of its circuits
have edges that need to repeat you can't
go through a tree without repeating
edges we then learned about what a
directed graph is these are edges that
have direction and if the edges have
direction we now call them arcs past
need to go into the direction of those
arrows and finally we learned about
weighted graphs a weighted graph are
when edges have or edges or parks have a
unit or weight to them the weight
corresponds the sum of the weights of
the arcs or edges that make up the path
and that is the end of 3.3 directed and
weighted graphs
hello or learn the Solis from advanced
quantitative reasoning and we're lonely
taking a look at something called
weighted graphs now a weighted graph is
basically a graph that has edges and
nodes these are both nodes right here
this is an edge and that's a weight that
means it takes time to get through this
point to get through this line right
here
it's like treacherous terrain or really
hard to clean terrain or something like
that no I see it's treacherous or
whatever or minutes to walk that or
distance whatever you want to see now
right here this is snowplow operators in
this example and I really don't like
this because it has in ours now we live
in an area that doesn't have much snow
so I have no idea how accurate this is I
don't know how long it takes to go ahead
and go through roads and clean them or
anything like that so but we're going to
be calculating the most efficient time
to go through this graph so that way you
can go ahead and calculate that now this
is asking us to construct the to go
ahead and construct two snow plow routes
through each of the following season
cities and then it ate the time that it
will go ahead and travel each route and
do all that so it wants us to go ahead
and calculate this route now you can go
A to B to C and back to a and because
all we're doing is cleaning and it
doesn't matter how many times we go back
but we want to go back as little as
possible because we don't pay these guys
overtime quite frankly this is really
really tough work but we don't want to
go ahead and and pay these guys to more
than they deserve well they do good work
but all that stuff but you can see how
this is form fitting so it's the ABCD
and then it's back to a not only have
the only way we can go is B let's go
down to C again and then go to E and
then go back to B then we go back to D
and go back to e just to go ahead and
clean that street and go back to F and
then we go back to D they're all clean
but you know where's the Home Depot we
need to get to
back to the home depot so sometimes we
have to go back to where we started so
it's gonna be simply start over today
we're gonna have to go back to there we
have to go back through B and then back
to a and this is a long route and so
we'd be calculating that we'd be
counting all right what's it what's the
time between this one three and then
let's see this right here would be six
and then we went back to a so that's six
and then right here well you get the
point and then you add up all alone I
don't like doing that this is very
inefficient so first things first this
is gonna give me a really big amount of
time I don't want to do that I want to
make this as efficient as possible so
we're going to go ahead and modify this
so we can go ahead and do this
efficiently so first off we have to
determine if this is an Euler circuit or
path now just looking at this this has a
degree of two this has a degree of three
this one has a degree of four this has a
degree of four this has a degree of
three and this has a degree of two two
ways to determine if this is an Euler
path or circuit you can go ahead and
just take a look at thin numbers see
right here this one's odd and this one's
odd and those are the only two odd nodes
so if you see two odd nodes this is an
Euler path so we're gonna go ahead and
say well since this is an Euler path
there's no circuit to this but we're
gonna go ahead and modify this to go
ahead and do a circuit so right now the
time it takes the time it takes to get
from this point to this point is a total
of all these right here so right now
what I'm gonna do is I'm gonna take the
all the weight so I'm not gonna even
look at this right here I don't need to
worry about that so we have 3 6 7 2 3 3
and then let's see 6 3 4 so I just wrote
them all down really just make sure 3 6
7 2 3 3 6 3 4 so all of them are done
I'm gonna add them all together so this
is an Euler path
you can go ahead and try to traverse
this whole thing and up from one point
to the other so this makes up the Euler
path so 3 plus 6 plus 7 plus 2 Plus 3
plus 3 plus 6 plus 3 plus 4 so that's 37
hours just to do this right here so
sometimes I I skip numbers yeah yeah 37
hours now the way you're gonna do this
right here we're gonna have to do a
backtrack that's that's a given we have
to backtrack this is how you determine
your backtrack we look at for the the
paths from C to D since these are the
two odd nodes so first you get your odd
nodes and determine the shortest path
between those now it doesn't matter
where we go we can take C a B D or we
can take a few others so these are the 1
paths that I noticed first off okay so
we can go from C to B that's 7 and then
B to D that's that's going to be 9 so
here's the path that I have C BD which
has a total of nine okay
so now we're gonna do one more we're
gonna do two more actually silicate we
got CED so CED that right here is 9 also
so these are tied between those two so
far then we have C e BD so C e BD y is y
let's see we got it here so let's see
this is three this is also three and
then two so that's a total of eight this
is the shortest path we don't know the
reasons why this would be the shortest
path but it's a little bit out of the
way it could be that this is a straight
stretch or the terrain is really easy to
travel we don't know it may have less
traffic and we have a whole bunch of
stuff but you don't know this but you
know what this is how it was determined
so this is the shortest path so once you
the shortest path we do this we take the
path and we're saying alright once we go
over here we have to go back so we're
gonna go ahead and draw another line and
we're also gonna put its weight which is
three then right here this is where
we're gonna have a double back also
because along this path we're gonna
double it back so it's like going mm-hmm
and then going right back so right here
we're gonna put another line to go ahead
and state that we're going back along
this line we're gonna have to travel
this one this one at least twice and
then right here we're gonna have to
travel this one twice so now we just add
8 to the 37 so now it's 45 hours and
that's how you make this more
efficiently this is just practicing
looking for paths and finding them at
first but then we have these
instructions on how to construct the
shortest path so this is where the
instructions are so number three
determines this you're gonna copy this
into your notes make sure you have that
and that's about it
well thank you very much I'll talk to
you guys later
today we're going to create your own
Euler circuit convert a given graph to
an Euler circuit and solve weighted
graphs remember an Euler circuit can be
determined if all the vertices have an
even degree degree of a vertex can be
found by counting the number of edges
that meet at that vertex for an example
here we have this vertex with three
edges that meet at that vertex so the
degree of this vertex is three another
example here there are four edges that
meet at this vertex so the degree is 4
so now we want to create our own Euler
circuit with seven vertices and 20 edges
now on exactly 7 vertices and at least
20 edges you may need to use more than
20 so we have some vertices here just
want to make sure we have exactly seven
one two three four five six seven and
now we need to start drawing some edges
so we'll take these edges or take these
vertices and begin connecting them and
typically you connect them in ways like
this so we've gone ahead and connected
all these vertices with at least 20
edges and the second thing you need to
do is make sure you have at least 20
edges so you need to count the vertices
the best way to do this is to put
numbers on them or maybe to identify
them with a mark as you're counting then
that way you don't count one twice so
there are 21 edges as identified by the
number labels given and then the third
thing you need to do to make sure that
it's an Euler circuit is to make sure
that each vertex has an even degree and
the way that you do that is you just
count the vertices or account the edges
at each vertex so we have 1 2 3 4 5 6 so
that's an even number 1 2 3 4 5
one two three four five six
so this is an Euler circuit and actually
all the degrees are six that is kind of
coincidental but if you do notice the
number six is an even number so each
vertex has an even degree which means
that this is an Euler circuit next what
we want to do is convert this given
graph to an Euler circuit so the way
that we do that is we figure out if each
vertex is even or odd so we have four
for your degree for that vertex 3 for
that vertex so that means we're going to
need to highlight that 13 again 2 3 4 5
6 so that one's an even number 1 2 3
that one's a 3 this one's a 3-2 and two
if you notice each time there's one odd
degree vertex there will be a second one
and then we convert this to an Euler
circuit simply by creating another edge
that goes between the odd degree
vertices and that converts each one of
these degrees into the number 4 which is
an even degree
you can even be a little bit more
creative if you really want to
you want to connect these two and go a
little bit further do a little bit more
work this is less efficient but it is
still correct you connect that one and
then back down to the odd that changes
this into a six which keeps it even and
changes these into fours again and then
again you can do the same thing as long
as you keep all the vertices even these
change to force and these change to
force as well now since each vertex is
even this is now an Euler circuit that's
how you convert a given graph and make
sure that it is an Euler circuit and
then lastly we're going to be solving
weighted graphs the steps to solving
weighted graphs are number one add up
all the weights in the graph number to
identify all the vertices with an odd
degree number three find the shortest
route between each of these vertices
number four make a second copy of each
edge of that shortest route number five
add the total of the weights from set
number four to the total from step
number one to find the most efficient
total with that weighted graph so step
number one we got to add up all these
weights so when you add them all up
again just like when you count the edges
when you create your own graph it's
better to highlight or identify that
you've already used that number so when
you add them up you of six plus five is
11 plus 2 13 14 15 16 19 22 27 31 32 35
so the weights in this graph is add up
to 35 we need to identify all the
vertices with an odd degree so here we
have a degree of 5 because there's five
edges another degree of 5
another degree of five and because
there's three there will be one more
this one here has four which means it's
got to be this vertex so there's all
your vertices with an odd degree third
we need to find the shortest route
between each of those and because of
their weighted we need to find the
smallest numbers to allow us to get from
one odd vertex to the other so here we
can copy this number but we can also see
that it's connected here with the number
one so the number one is going to be the
fastest between these two and then
between the next two vertices with an AA
degree our quickest route again is a
weight of one number four we need to
make a second copy of each edge of that
shortest route so we already kind of
have made that copy but to be really
literal we want to make sure that we
have the weights copied as well and once
we do this we can add up the total of
all the numbers that we have written
down but since we've already added the
total in step one before making a second
copy we can then find the total of what
we added and then add that to 35 so our
solution to this graph is 35 + 2 and the
solution to this weighted graph is 37 so
the last thing we want to do is take
this way to graph and find the solution
for it I'm not going to put the steps up
I'm just going to walk through it pretty
quickly so we want to add up the total
numbers the total weights in this graph
we can get 182
then we need to identify the odd degree
vertices so there's one there's one
there's one looks like most of the
vertices in this picture are odd looks
like every single one of them so each
vertex has an odd degree and now we have
to find the shortest route to connect
each of these vertices we're going to
connect them two at a time and we're
going to start connecting them where we
only have to duplicate the smallest
numbers so if we duplicate this too
that's one of the smallest numbers and
then these two are now even and we can
move on to two others the next smallest
is this three so these two are now even
and now we have a little bit more of an
issue we can't connect this for because
that would cause us to make this vertex
odd again so we've got to skip the floor
and we're going to go to the next
smallest number which is five so we can
connect these two
and then we need to try to connect the
remaining four vertices with the
smallest possible total and here we have
a decision to make we can connect these
two and add 20 but we can also connect
these two and that's shorter or less
time or less weight then what we just
did with the 20 because 9+10 is 19 or we
can connect these 2 and 13 and of those
three options that we have this is the
shortest or the most efficient that we
have and then we have to figure a way to
connect the last two vertices the
easiest way to do that is to basically
take a look to see if there's any way to
do it that's less than a weight of 19
and anyway you go it looks like it's
going to be somewhere in the ballpark of
30 so 19 is going to be the shortest
route between those two vertices now we
have made every vertex even we have
duplicated the shortest path between odd
degree vertices and now we have to add
up all those weights that we just added
and I get 42 and when we add 42 to our
original 182 the solution to this
weighted graph is 224
now there may be a possible solution
with these weights that's slightly less
than 2 24 if anybody finds that solution
that's less than 2 24 and it's a
legitimate solution i'll give you an
extra 10 points on a homework assignment
guys that's solving weighted graphs
creating your own Euler circuit and
converting a graph that's not an Euler
circuit into one
the shortest path problem is essentially
the problem of finding the shortest path
between a pair of vertices in a given
graph and normally we assume that the
graph is connected so that there is a
path and then you just look for the
shortest one and often this problem is
stated in terms of a weighted graph and
we haven't really looked at edge
weighted graphs yet so let's start by
defining an edge weighted graph edge
weighted graph so it's basically a graph
G together with a function let's call it
alpha and the function will map the
edges of the graph to some numbers and
in this particular application we're
going to think of them as positive
integers so that's what this means
positive integers in fact the natural
numbers is denoted like this so really
this is just the set of all integers
including zero and then all the positive
integers like this keeps going so 0 1 2
3 all the way up to infinity any one of
those numbers gets assigned to each of
the edges so that's what this means and
practical example is going to be useful
right now I've prepared a drawing of an
example here we have it so we can see
that this is a graph on quite a few
vertices and what's happened now is that
every one of the edges of the graph has
been assigned with one of these numbers
one of these natural numbers so for
example this edge right here we would
say has weight 7 the practical aspect of
having a weighted edge graph like this
is that if you're thinking about this as
a transport network where maybe you're
delivering goods along roads or
something like that these weights could
represent either the distance or the
travel expense of a particular road or
the rate of flow the amount of traffic
that you're going to encounter
now if the network this graph actually
represents something like communication
network where each of these is either
or computer or something like that and
these edges are given weights maybe
based on the unreliability of the
ability to pass information between two
computers or the frequency of action
between between nodes all of this is on
possible reasons why we might want to
have weights on the graph now with the
weights on the graph we should be able
to define a couple of things the first
thing is that we want to say that the
weight of a particular edge is going to
be called the length so if we have this
function this weight function applied to
a particular edge UV this is called the
length of the edge UV and if you look at
some kind of a path through this graph
let's take a look here's a little
example maybe I'll use pink to do this
so we go maybe through starting along
here and then
maybe two here let's just take a look at
this path in bright pink so this path
right here P I'll call it in bright pink
we can also talk about the weight of a
path where we just sum up the weights of
the individual edges so we can actually
define alpha of P so alpha of P is the
edge weights of the entire path and
that's going to be the sum of all of the
weights of the edges where e is an edge
in the path P and this can also be
defined for any sub graph so just notice
that for any any sub graph H of G you
could define the weight of that sub
graph to be just the sum of the weights
in the edges of that sub graph so the
edges and then alpha of that so this is
in general for any sub graph but usually
we're interested in paths like this so
in this particular example we see that
alpha of P is equal to we'll just add
them up we get let's see six six is the
total weight and this alpha of P is
called the distance of the path the
distance of the path
so in fact distance and length have been
used before and if all of the weights in
this edge graph in this edge weighted
graph are labeled as a 1 then in fact
these definitions of length and distance
coincide exactly with what we've been
thinking of as length and distance
before it's just that now this is a more
general version of it where each one of
the edges may have a value assigned to
it that's bigger than 1 so now the point
is that for a practical application
we're usually interested in finding a
path through a graph that has a minimum
weight over the entire path so what we
mean is that maybe we want to go from
this vertex x over here to this vertex Y
and we want to do it using a path
of minimumweight or in other words
minimum distance according to our
definition of the edge-weighted graph so
you can think of this in terms of having
an unweighted graph where all of the
edges would just be thought of as having
a 1 as a label and then you can ask that
question or we can think about it in the
more general form like this which is
more practical for applications so this
actual function here that map's our
edges to the numbers the natural numbers
is actually called something special it
is called a weight function weight
function so that's what we're going to
call alpha and normally we actually talk
about the shortest path problem on a
connected graph with a weight function
so here we have shortest path problem
and we say it is given a connected graph
G so connected graph G with weight
function alpha
so alpha remember that takes the edge
set of the graph and it maps it to the
natural numbers so given this we want to
find the minimum distance between for a
given U and V so for given U and V
vertices of the graph we want to know
the minimum distance from u to V as a
path so that we differ we denote like
this D sub G with a superscript alpha of
U and V now this D of G means in the
graph G with the weight function alpha
of U and V and we're looking for this
minimum amount so really what that means
is that you're looking at all the
different paths from u to V and looking
at their weights and you want the
minimum among all those so you take the
minimum of the weighted path so the
distances of those weighted paths where
the paths are going from u to V and
that's exactly what we're looking for
the minimum weighted distance from u to
V in that graph G with the weight
function alpha so this is the shortest
path problem and in another video we
will take a look at us out of way a
method for solving this problem
welcome to the first in a series of
demonstrations on the graph data
structure what we're going to be
starting out with is a look at a graph
implementation specifically looking at a
graph implemented as an adjacency matrix
and trying to determine what kind of
graph that adjacency matrix represents
so we're going to draw out a graph
corresponding to this adjacency matrix
first thing that we're going to do is
we're going to try to figure out what
kind of graph we've got in the first
place now if we take a look at the
matrix the rows and columns are labeled
ABCD and E which means we have five
vertices which we're going to dry out
and label them a B C D and E now the
contents of the matrix itself are
numeric which means that there's going
to be some kind of weight associated
with the edges between each vertex now
if these have been boolean instead we
would say that it was an unweighted
graph but since we have numbers we're
going to associate those with the edges
the other thing that we can determine is
that by taking a look at the main
diagonal and the values on either side
the values on either side of the main
diagonal aren't identical so for example
evaluate Row one column two is not the
same as the value at Row two column one
what this means is the matrix is not
symmetric and therefore the graph is
bi-directional so we're going to have to
draw arrow heads as we go on each four
edges so let's start out with the first
row
and take a look at the edges that
originated a now there's two edges
originating at a one divert X B was
weight of three and another one to
vertex E with a weight of one now again
this is a directed graph so we're
drawing arrow heads on each edge as we
go there's only one edge originating a B
and that's an edge to D with wait to see
has three edges rigid a and they have
different weights we have one from C to
a with wait for one from C to B with
weight 2 and 1 from C to e with weight 5
there are two edges originating from d1
that goes to C with weight six and one
that goes to E with weight one
and then finally in the last row of our
matrix we have two edges originating at
row e1 back to a with weight one now
notice that we already have an edge from
A to E with weight one and the edge
going back will also have the same
weight so instead of drawing it in
another edge let's just draw in another
arrowhead indicating that this edge
happens to be bi-directional and the
other one is an edge from e to D with
weight three now although we already
have an edge from D to e we can't just
draw it in another arrowhead because
this new edge has a different weight so
I'll have to draw in another line with
an arrow going in the opposite direction
and label this one as having weight
three and that's our complete graph
based on that adjacency matrix for the
second demonstration we're going to take
a look at a different implementation of
a graph in this case a graph implemented
as an adjacency list there are six
vertices labeled a through F this will
start out by drawing our graph by
drawing those six vertices now we don't
know exactly where the best place to
draw these vertices are so we'll just
kind of take a guess and spread them
apart nicely so that we have lots room
to draw on edges the first item in our
adjacency list shows us all of the edges
originating at vertex a now a has an
edge going to see a soldier on that one
and in the absence of any evidence to
the contrary we're going to make this a
directed edge from A to C the second
item shows us the B has two edges
originating at B one to D and one to E
see has three edges one returning back
to a now in this case we don't have any
kinds weights so we'll just draw in an
arrow back to a 1/2 D and 1/2 e D has an
edge going to be well we already have an
edge from B to D so this is just now a
bi-directional edge and one back to C
again just another arrowhead on an
existing edge e has three edges one
returning back to be drawn another
arrowhead one back to C and one to F and
finally the last item in our Jason C
list shows us that there is an edge from
F returning back to e we take a careful
look at our graph we can see that all of
the edges that we've drawn in in fact
have arrowheads on both ends in other
words our graph is undirected now there
was no way for us to tell that from
actually looking at the original
adjacency list it's just something that
we had to discover as we went along
but that's our complete graph
greetings this is a short video to show
you how to create a weighted graph and
sage using an adjacency matrix remember
that we can create an unweighted graph
using an adjacency matrix and sage by
writing out the matrix and sage like
this and then using the graph command
with that matrix as the argument to
create the graph in ordinary adjacency
matrix the entry in the IJ position is
one if node I is connected to node J and
zero otherwise to make an adjacency
matrix for a weighted graph if two nodes
are connected with an edge that has a
weight we're simply going to use the
value of the weight instead of a one for
example let's make a weighted graph on
four vertices 0 1 2 and 3 I'd like 0 to
be connected to one and two with edge
weights 10 and 5 respectively also
connect 0 to 3 with wait 6 and then
finally I'd like to connect one to two
with a weight of 12 so let's make the
matrix that would represent this graph
let's call it m we're going to type M
equals then the word matrix then open up
a set of parentheses and then inside
that a set of square brackets for the
first row we're going to put in another
set of square brackets to represent the
row in the brackets for the first row
we're going to put the weights for the
connections the first entry is 0 because
node 0 is not connected to itself with a
loop 0 is connected to one and
ordinarily I would put a 1 here to
indicate that connection but since this
is a weighted graph I'm going to put a
10 there because that is the weight or
the cost of the edge that goes between 0
and 1 likewise I'm going to put a 5 in
this third position because 0 is
connected to two with a weight of 5 and
then finally a 6 in that last position
because 0 is connected to three with a
weight of six now in Row 2 which
corresponds to node 1 because we start
counting at zero I'll put a 10 in the
first spot because 1 is connected to 0
with a weight of 10 we have to put this
here because if zero is connected to 1
then 1 is connected to 0 since this is
an undirected graph and so we have to
have symmetry inside the matrix entries
there's going to be a zero when
second position because one is not
connected to itself one is connected to
two with wait 12 and so where I'll put
12 here and then finally I'm going to
put a zero in the last spot because one
is not connected to 34 row 3 which
corresponds to node number two similarly
we're going to put in five 1200 and then
finally in row 4 which corresponds to
node number three we're going to have
6000 now we'll use the usual graph
command here with a capital G to
construct a graph from the matrix just
like we did for unweighted graphs but we
have to tell sage that this is a
weighted graph by giving it a new second
argument which we have never used before
weighted equals true this will tell sage
what to do with the nonzero entries most
of which are not one that are in this
matrix so having done that we're going
to hit shift enter or click the evaluate
button and the graph is defined it
doesn't show up automatically so to show
this graph we're going to use the usual
dot show method if I do that notice that
the graph is shown but the weights are
not if you want to see the weights then
you pass the option edge labels equals
true with an underscore there between
the word edge and the word labels inside
the show method and then when you
re-evaluate the weights will show up
super impose on top of the edges and
that is how to make a weighted graph
from an adjacency matrix using sage
alright so we sold at Hamilton paths
Hamilton circuits oh how to look for
those in certain graphs and we saw that
you know the the circulant grass
circular graphs have sort of one
hamilton path or the reverse of itself
and we saw that the complete graphs had
lots and lots of hamilton paths that
that we could look at so oftentimes just
because a Hamilton path exists
oftentimes we want to do the the
optimization thing where we make sure
that we have the we spend the least
amount of time traveling so many
situations have these Hamilton paths and
circuits and a lot of times in the real
world a lot of things look to be like
almost complete or like complete graphs
and their connections for instance if I
was talking about cities well you can
take almost any city in the United
States and it's probably or any major
city in the United States and it's
connected by highways or at least a
series of highways to every other major
city all right but efficiency is needed
in many places so let me describe what i
mean by that if you have like the united
states right we have new york city over
here we have boston over here and we
have like San Francisco in the sort of
northern part of california and los
angeles in the southern part of
california now all of these are
connected by highways and and by plane
but if you are going to go and travel to
all four of these spots it's a lot more
efficient
to take from New York to Boston and then
to go to San Francisco in LA then it is
to take and go from new york to san
francisco and then back to boston and
then back to LA right you're going to be
traveling a much bigger distance if you
crisscross the country a couple of times
then you would if you only had to cross
one time all right now all of these are
connected but there is a most efficient
way to do this all right so it's the
same similar thing can we talked about
instead of going from the New York
Boston San Francisco la example you know
well how could you travel from Grand
Rapids or in Detroit in columbus and
Cleveland and Chicago and st. Louis all
of these are connected by highways you
can get you know from one to the next
sometimes it's it's more efficient to go
certain routes okay you probably
wouldn't want to go from Grand Rapids de
st. Louis and then back to Detroit and
then back to Chicago and then to
Cleveland and right there's probably a
most efficient way a best way to travel
okay however in this case it's not as
obvious what path you should take as it
was in the New York Boston and la
example okay so what we would do on
these six cities if we're really doing
this is we'd say well let's give each
one of these a point and I'm not going
to worry about at least I'm not going to
worry right now about location right
because its location sometimes it can be
deceiving to your eyes but we do know
that these are all connected by highways
so we get a complete graph
may have them all now all right now what
what you would do in reality i'm not
going to go through this entire example
because there's a lot of different paths
you can take but what we do in reality
is we say all right this edge let's
pretend Grand Rapids is up here that's a
bad color let me erase that get a new
color let's pretend Grand Rapids is up
there and Detroit is here Columbus
Cleveland Chicago and st. Louis all
right so what we do is we take each
single one of these paths there's mean
each one of these edges and we're going
to assign it a weight and in this case
the weight is going to correspond to how
long ask me how far or how long it takes
to go from Grand Rapids to Chicago and
so this blue edge that I've highlighted
is going to be assigned oh wait maybe
that's a I don't know 200 miles or maybe
that's a certain number of hours you
know three hours or something like this
not exactly sure I don't know the exact
number of miles from Grand Rapids to
Chicago but that's the sort of thing you
would do all right and then you'd have
to look at all of the paths and decide
which one minimizes the total distance
now that's why we're not doing it in
this case because if you notice there's
a lot lot of paths that you could take
through this through this maze so we're
going to do it on smaller scale but
there are computer programs that could
check you know every single path so
let's pretend your company was located
in grand rapids well there's computer
algorithms that could tell you whether
it's it's better to go to st. Louis
in chicago and then columbus and then
Cleveland and then Detroit and Grand
Rapids like weed or if it was better to
go you know a completely different way
through this through this maze all right
now this is the idea of weighted graphs
where each graph edge is given some
certain weight and usually the problem
either has to do with let's minimize the
distance let's minimize the weight that
we have to travel or there are there is
an alternative problem that says let's
maximize the distance or maximize the
weight we have to travel okay maximize
what's the worst scenario and there's
different applications for these that
the delivery route stuff is obviously
generally I'm minimizing a weight we
have to pee on a distance we have to
travel so each weight is a distance but
there are other types of connections
that can be given weight that we want to
maximize all right so let's do this let
me take a complete graph on four
vertices and i'll give each edge a
different weight now just for the sake
of time let's assume we want to start
our graph at v1 there's me our path at
v1 okay and so let's give our weights to
these vertices let's take and I'll write
the weights and green just so we can do
this let's say that's 10 that's a 20
that's
teen this one can be five this one can
be 25 and let's say this one is also 25
so the crosses are 25 and everything
else is as 5 15 s tens and 20s all right
now there's a couple of strategies that
are involved here that you could it you
could use so if you want to start at v1
what we could do start at v1 we can
employ with what's known as a minimizing
distance there's mean I'm minimizing the
the edges strategy so I don't know how
to how to say that that's there's a
technical term for that but basically
what you're going to do is you're going
to always go travel to the next lowest
so I if you start a v1 you have a choice
between 10 to 25 and 5 so if you're
trying to minimize one strategy is
always to take the path of least
resistance that you haven't traveled
already so in this case you go V 1 to V
for now take the path of least
resistance twenty five to fifteen is a
15 now take the path of least resistance
25 to 20 go to 20 row now I'll take the
path of least resistance 10 verses 25 go
to the 10 row alright so if we took that
the sort of paths of least resistance
method you will v 12 v 4v four 2 V 3 V 3
2 v2 and your total weight you've
traveled there would have been I believe
50 in this case okay now here's the some
some hard things when it comes to
weighted graphs
one of the first things that I'm sorry
it would have been not 50 but 40 excuse
me yeah 40
so one of the harder things is to say
that there's no other better path that
you could have taken all right by the
way in this case v1 v4 V 3 V 2 there
actually is no better path that you
could have taken and if this was a I
said originally weight was 40 because i
was thinking circuits but if it was a
circuit it would have also traveled on
the 10 but anyways oftentimes it's hard
to sort of prove to yourself that this
is the best path now again there's
multiple ways of proving that this is
the best path you could say well let's
travel a different way and see what we
get or let's travel you know this way
and see what we get lots and lots of
options for that lots of options to to
to go through there's another way you
could you could have done it as well and
said well if I have a path v1 to v2 v3
v1 v4 v3v to all right we know that
there is at least three edges that we
need to cross okay and if i start at v1
right one of those edges cannot be this
one or that one so if i start at v1 you
can kind of convince yourself that
that's the way to go because the 25's
these cross diagonal things are the
highest in the graph and you want to
stay off those now that's not always
going to be the case but you should
convince yourself that the total weight
of being 40 is the best we can get on a
path on a circuit total weight of 50
would be the best we could get all right
so that's the the hard part about about
looking at those kinds of things is is
this really the best now i do want to
mention something because last time it
we started at v1 if you could have
started anywhere and we had this uh this
complete graph well if you could have
started anywhere you may have had a
different result than what would have
happened if you were forced to have
started at v1 now again in real life
sometimes you are forced to start
someplace and sometimes you aren't
forced to start in a place so you do
have to kind of be wary of how that
thing worked so anyways 2525 wait a five
a 10 a 15 and 20 okay and this one was
v1 v2 v3 and v4 so what I was saying is
it's pretty clear that if you could have
started any winter there actually is a
better a better route to go you can go
the 10 the 5 and the 15 so you can go
from excuse me v-22 V 1 to V 4 2 V 3 and
have the best path possible okay if
you're doing a circuit then then
actually those two circuits would be the
same but the one I had on the last slide
and this one but on a path this is a
better path and this one's kind of easy
to prove that this is a better path
because not only are we dealing with
sort of these are the closest
neighbors each time but also notice that
if you've had to travel to four
different vertices you have to at least
have three jumps you have to at least
have traveled three edges so this one's
kind of easy to see because we are going
with the smallest three edges that exist
in the graph all these other edges are
bigger ok now it's not going to be that
easy every time but but that's what's
happening now the complete graph on four
vertices was we determined that the best
method kind of by sort of a mix of the
two different methods that I was talking
about the brute force method is to test
every possibility every single
possibility the nearest neighbor method
is always choosing that the smallest
distance you want and we kind of saw how
those things work in and in our case
both the brute force and the nearest
neighbor led us to the same results
alright so I want you guys to try on
this one this is a fairly
straightforward example I want us to do
to be able to start anywhere in this
case and find the best path going that
hits all the vertices okay by the way I
want to say well I'll say this later i
guess but find the best path in this
case push pause on the video and see
what you come up with
alright so hopefully you've gotten that
V 1 to V for 2v2 2v5 to these three is
the best path or you could have gone the
reverse of that you could have started
at v3 and went backwards along that so I
want to start a v3 first so you could
have gone v3 2v5 to v2 to v4 and to v1
and you would have gotten sort of the
best travel possible now I do want to
say something about these things what
I've been doing is I've been getting
hamilton paths and Hamilton circuits
however in real life oftentimes
oftentimes you can retrace your steps
okay this one isn't a very good example
but there are times when when you can
retrace your steps and do some things
and and make retrace retracing actually
efficient for you okay so for instance
if I was going to do a circuit on this
obviously there's no Hamilton circuit
where I hid everything once but if you
had to start at v1 and get back to v1
well you could have taken that smallest
path and then just traveled right back
on that smallest path and there might be
some other weird thing where you could
travel the smallest path and then get
you know a jump if we had other other
edges all right so just because this
doesn't have a Hamilton circuit doesn't
mean we can't optimize things same thing
with other graphs just because they
don't have a Hamilton path doesn't mean
we can't optimize the distance traveled
through all the vertices
by the way the weight what's the weight
that you get there traveling this path
what would that be 18 plus 6 is 24 24
for your weight ok so that's the the
best way to do that all right let's take
another look and give me another example
so let me draw that up which pause here
and draw it and I'll pop right up all
right so only I popped right up for you
um here's what I've done I've labeled
every single I edge in this graph and I
want to travel to all seven vertices and
I want you guys to kind of think through
what would be the best place to start
the the best route you could take now
this one is fairly complicated because
there's so many different options ok and
that's obviously done on on purpose
alright so I want you to kind of think
through where the best place to start is
and then come up with with a good answer
alright so hopefully you came up with
some ideas and maybe that I hbu they
might not be perfect they might not be
flawless by any means but but hopefully
you kind of get an idea of what we're
trying to accomplish here so what I see
is I see a couple of things that you
also just overall general ideas and this
isn't meant to be very insightful by any
means but this 100 is the biggest number
90 is the other biggest number so you
probably want to avoid those ones okay
now also it might not be nice to start
at like a v3 or a v6 so that so that we
don't have to travel the v6 and then
back to v7 right if we get in here we're
traveling down here and then travel back
and forth and then we might go I'm not
exactly sure if that would help or hurt
or what okay it might may not it may not
again in this case by the way there's a
no real nice I don't think there's a
real nice Hamilton path that you can
take that that would get you from one
vertex dealer I think you always run
into this problem that you would
rephrase a vertex if we quickly tried it
so anyways retracing we typically don't
want to do all right so at this stage we
can employ one of our our strategies
here let's employ the let's start at v3
and employ the least the smallest
neighbors strategy okay the nearest
neighbor star to excuse me well that
would mean go to v2 and then to v4 and
then to v7 v6
you take out right there you go to v5
you go 70 and then 10 I think we could
cut that out by going instead of going
from v5 we should go back that way that
would avoid is 70 and a 10100 and
replace it with a 13 and a 20 so this is
what I'm seeing is one option so v3 goes
to v2 v2 goes to vie for all right v4
goes to be 70 to v6 back to be seven
back to be five out back to be 525 back
to be seven and then v1 all right now
notice that path involve v7 a few times
so obviously it's not Hamilton but it
does give me a pretty good number all
right at least it allows me to avoid the
100 it allows me to well I had to go
from v42 v7 nice well on the 90
primarily because you know once i was at
v for my choice was either to go back 40
plus 70 or to go straight across on the
90 and so what i have gotten here is a
fairly large number and it may not be
the best it may not be but you're going
to have to try try try a few things out
ok and this is just one attempt I'll let
you guys kind of try and see if you can
come up and let me know if you come up
with a better weight than what I got by
the way what I got was i gotta wait
there's me to wait for this for the path
that I got the wait
is 226 okay and notice this one is not
not very nice now on an exam or
something I probably give you something
that's a little bit nicer than this one
and it's a little bit less fewer edges
but I wanted to get you the idea that
sometimes this is not nice this is not
pretty oftentimes you're going to have
you're not going to have a nice Hamilton
circuit sometimes you do like on the
complete graph you're going to have a
nice Hamilton circuit or Hamilton path
but sometimes you don't and that's just
the way things are okay you have to kind
of get used to that and accept and
embrace those kinds of things so I got a
weight of 226 and again let me know if
you if you thought of a better way to do
this if you came up with a weight that
gives me less than 226
Shh okay that's my crazy class I said
all right we're going silence and
they're all nuts
we're live okay so here we go
gonna do the next one boom alright so
the reason I was gonna keep talking
until everyone settles down
of course I'll get that so I start with
this little cutout from the book and
thinking about not telling the story
online but I guess I will I think I said
the story to at least one if not all the
classes about this chapter and a year
ago to this day fully admit this is a
brand new class for Truesdale and I last
year struggle to teach could have very
easily just given us a history class to
teach don't even have a history degree
and it would have been the same amount
of work just trying to get ahead of the
students trying to figure out what the
heck is going on
fully admitted that last year but then
found it really interesting a year ago
to this day or right around a year ago
to this day right in this chapter of
doing graphs and networking Trousdale
goes to a Notre Dame game true story
unless she's lying to me over the
weekend she comes to me in Monday you
were not gonna believe what happened to
me I went to a Notre Dame game with my
husband sitting down in the stands and
of course you know people you're around
you start talking to and the guy that I
was talking to this is what he does for
a living
he's a networker he's you know he does
this um this kind of thing where you get
efficiency and well specifically what he
did I refreshed my memory and talked to
her yesterday what did this guy actually
do and he was on a college campus and
his current job was to get wireless
internet that's accessible anywhere on
campus inside and out and currently what
he was trying to do is getting the
outside routers which he was attaching
to light posts outside and his job was
to do with the most efficiently using
the least amount of routers so that the
network would still be good enough to
come back to the tech office so that
they could get that wireless internet
out to everybody and that's was his job
the efficiency less routers less costs
and still the most strength in the
signal to make that happen the guy flew
in his own personal jet to that game so
just take a minute to think about that
this guy that does this for a living you
know efficiency and networking big time
money man so with that being said this
paragraph out of the book really
coincides with that business managers
and administration administrators often
carefully analyze the efficiency of a
network as it can affect the bottom line
that's what this guy's job was less
costs but the most powerful network that
still worked efficiently for example you
might want to minimize the length of a
wire using a computer network or the
mileage that delivery vans must travel
one thing I told you about this whole
chapter as well UPS truck driver how can
I most efficiently visit all of these
points all these drop-off things alright
so what we're gonna go into today is
creating a graph of making it weighted
and what the weight of that graph as I
point to the sentences I'm in class
those weights are cost from going from
one point to another or the time it
takes which time is money or the
distance it takes for like the driver
alright so from this information this is
what you can first write of course he
did not write any of you know what's in
that sentence isn't this great animation
alright so a weighted graph each edge
has a number or a weight put on it
or associated may represent time cost
distance pulled right out of this
paragraph okay
so again I just wanted to give the book
props I guess you know as far as uh you
know where does this pertain to in the
real world not that I'm saying you're
gonna go out and do this but maybe you
make a career change in you know you'll
see that this is something that would
happen of course the second one is a
sign such as they are relevant to the
problem of course this is important for
you to understand that it's not what you
have to do the length of the edge does
not have to be proportional to the
weights so the length of the edge does
not have to be proportional to the
weight and what I have is a drawing that
I put ahead of time here alright this is
what this means
pretend from point A to point B is seven
miles I think that's what I put there as
I move around
yep and then point B to Point C is six
miles and I decide to put that graph as
such then I read from point A to point C
as three miles well I'll have to see the
longest line here is for me to see
doesn't matter in fact it would be
really hard not saying impossible but
really hard to make these lines
proportional and have the drawing
actually fit it's not your job your job
is to put the weights on the lines and
that's all that matters not the length
okay and I'll give you a minute to write
that down
okay next all right so I'm gonna try to
do this last hour I could not write on a
powerpoint which is a very legal thing
to do to be able to write my own writing
that's what happened it just everything
went haywire again I honestly feel
there's someone in the tack office
that's connected to my computer you know
say about seven a good day let's start
screwing around with a book look at my
computer just starts going crazy control
my desktop I feel that what do you think
are you even listening anymore sick of
my stories aren't you alright so it
takes good old mr. Samuel
had to put good old you could put ugly
disgusting if you want 30 minutes to get
to work from home 180 is it all screwed
up I don't think you really need that
for the problem 20 minutes to get to the
kids to karate from home and 25 minutes
to get the bowling from karate which is
actually my life that's what I do
alright so I'm gonna try this gonna try
it pen ok so then this is real
simplistic I got to be real careful how
I write on the screen otherwise
everything would get jacked up so let's
call that home so I'm writing like my
seven-year-old would write actually it's
an insult to my seven-year-old she rides
better than this but it's the slippery
screen like I'm writing on ice where am
I going
Oh work go to work and then you put a 30
on that now it's a weighted graph it's
the only thing we've added this is
Mickey Mouse and then 20 minutes kids
the karate from home so home to karate
notice I put those as the same length
but I put a 20 on that and that's all
that matters and then 25 minutes from
bowling to karate so that's what I had I
dropped the kids off at karate with the
wife then I go off the bowl the wife
takes the kids home 25 now that's a much
different graph than I had a first hour
doesn't matter you could put home over
here you can put home with to the upper
right you know it doesn't matter not all
graphs have to look the same the
connections must be the same no so there
it is just a way to graph real Mickey
Mouse example I know about it
shocking no I think I'm still stuck in
pen mode okay there we go boom
don't worry about the highlighting I'll
have that figured out so I give you a
chance to write this down and hold off
on a chart for a second Amtrak travels
between six cities the distances between
each are shown in the table below I'll
hold off on that table before you write
down if you want your notes to be nice
draw a weighted graph to represent the
system
and then the reason for letter B find
two different routes between Nashville
and in the app Indianapolis which could
be called subgraphs
is because when I reveal the chart or
when the computer lets me do it there is
no denying from Indy to Nashville so
understand how the chart is read I guess
I will blabber as you're writing us down
for those that take notes I see a lot of
people not doing that can wait for an
open note quiz I don't have any notes
that's your fault why do I have the
bottom-left highlighted because there's
redundancies in this chart I know it's
different to go from Detroit to Chicago
than it is to go from Chicago to Detroit
but isn't the distance the same it's the
same track so when we do our graph which
that chicken scratches on the bottom was
part of my disaster of first hour I
could look at the writing and then all
of a sudden the computer started
betraying me something an attack off is
pressing buttons that's messing around
with mr. Samuel as' anyway you're not
there's not two connections there you
don't draw a line from Detroit to
Chicago and then you don't draw another
line from Chicago back to Detroit so
really when you're making your sub graph
you only have to look at the bottom left
or the top right because they're the
same from Columbus to Detroit's 2:04
from Detroit to Columbus it's 204 so
when we do our graph we're only worrying
about those so I'll give you a second to
write that down if you want good notes
look at this stuff
is it going yes all right so we
constructed this graph we think oh I
forgot I can't do that pen this graph in
class okay then and then you can look at
the one it's coming I think working
lightning fast is it showing up there
okay so ours on the board looks better
than this this is similar to what we did
second hour so making the connections
one
at a time I did Chicago first direct
line saw the cities and then I only
worried about the bottom left because
this there's a you know I don't care
about the top half because we're not
drawing two lines one from Chicago to
Detroit and one from Detroit to Chicago
so I'm worried about what I'm saying
online okay so on the next thing you
construct this graph not all the graphs
have to look exactly the same now we're
gonna look at from Nashville to Indy and
the whole point is this and you should
be listening to me it's hard to see in
the chart but now it's easy to see on
this graph a couple different ways I can
get from Nashville to Indy and I do have
this come up so I am gonna stay here I'm
gonna risk it that I'm able to write on
this and show highlighting and I'm gonna
try to emulate what I did in the other
class so here's from Nashville to Indy I
think you could see that one direct way
is Nashville to st. Louis and then st.
Louis to Indy do you see that can you
see that my highlighting right there
correct okay and I could go up to the
board up there and show it as well and
that would be one way to do it but then
you know seeing that on the graph is
that as efficient as maybe a different
way well we'll check because what we
need to do is add up those distances so
from Nashville to st. Louis is 580 for
st. Louis to Indy is 350 for those two
added together something like 930
something right so 930 some miles 931
938 or I could change my highlighting is
there a different way and more efficient
way maybe I can change my highlighting
this is gonna be easy
and the answer that is yes what if I
went Nashville to Chicago
shaky-shaky and then Chicago to Indy
that would only be five fifteen plus one
ten and you're getting the same thing
done and now what I watch you understand
is I have this appear up on the slide
boom those to which you might not be
able to see up there but maybe at home
you can is that's only 625 miles then
want you to think about the whole spirit
of this this section it's about finding
connections that are more efficient and
of course this is a Mickey Mouse example
the point of the graph is being able to
see the connections maybe not so obvious
in the chart but in a graph it is and
then maximizing those options everyone
ok get it fun
no this may not be working out as well
having cut outs from the other class but
it's it's what I'm stuck with you know
with what we have here is technology
that's not working out so great
sub graph sub graph is a set of vertices
and edges chosen from the original graph
and actually in this one I will do all
the questions on the board and then just
have it a you know show up for those at
home and that reference it anymore but a
redundant connection now this kind of
leads into tomorrow another efficiency
thing we could call it like the
Trousdale guy that she saw at the Notre
Dame game you know redundant connections
not necessarily needed so I I could use
less routers that's kind of the idea
there if an edge can be removed but
still maintain a connection between all
vertices routers if there is a circuit
then there has to be a redundant
connection so I'm going to try this
again as you writing this down so far
the pen hasn't betrayed me like it did
first hour if I have a to B to C this is
actually a circuit correct right so
there is a redundant connection meaning
I can get rid of maybe this edge and all
the vertices are still connected so I
don't need that edge to keep the
connection of all the critical points so
this is what removing
a redundant connection looks like in the
most simplistic way I can show it I hope
that makes sense for you if you wanted
to write that down so this was here I
could get rid of this one and I would
still have the vertices connected of
course I lost my vertex don't know why
all right
so that would be another way to remove a
redundant connection in the most
simplistic form I'm gonna race this and
then actually the last of the notes are
another chart okay and it's very similar
to the one we just had but much smaller
cities so I'm gonna go to my board ask
for volunteer to when I'm on the board
what what are those mileages make
another graph and then what I'm gonna do
is make two different sub graphs that
removes the redundant connections that
keeps the cities connected but we remove
redundancies in it and we'll talk about
that on the board and then I'll to
reiterate it on the computer where the
class doesn't really have to listen to
that and you don't have to listen to
second part but alright so we did this
in class draw a weighted graph to
represent the commute commuter airline
network and we want to step at a time
and came up with this drawing okay and
it's very similar to what second hour
had so boom there it is all right let's
should look better when you look at this
on a hard piece of paper now what we're
gonna do is remove the redundant edges
edges so what that means is no circuits
should be in there anymore and all the
cities are still connected so we're
gonna do that in class and I'll be back
to the V okay so we went ahead and did
two sub graphs that removed redundant
entity edges which means there are no
circuits left so one of them was
actually we didn't have this one I think
nope that's not the one we did in class
we did something a little different
yep okay but that is one notice the
cities are still connected but there are
no circuits so I could hit all the the
hubs
without any problem and then here's just
another one not a big deal we did two
different ones
here's another sub graph from the graph
given that's not even one I have two
different ones in the notes so you guys
Period three have the you know you have
four different sub graphs to look at
that all did the same thing 1290 oh
that's bad yeah this one's uh so we have
one in class we had a sub graph that is
weight of ten thirty so we'll talk about
that more tomorrow trying to get the
most efficient sub graph possible oh no
I'm sorry
one of those is so three whatever sorry
blabber
okay we've now seen graph search depth
first search breadth-first search and
we've seen in fact searches we're both
depth-first search and breadth first
search will find solutions find paths
with the fewest edges that may be what
we want but there are also times when we
might want more information let's go
back to our original example of finding
flights from one city to another we
could find the sequence of flights that
involves the fewest stops that will be
the minimum number of edges but we might
be more interested in minimizing time or
minimizing costs and that's information
that's on the weight on an edge so if
our edges are weighted we need to find
other solutions solutions that minimize
that total cost turns out that for depth
first search the algorithm we've shown
you is quite easy to modify rather than
just counting the number of edges we
simply sum up the weights and we keep
searching to find the solution the path
that minimizes that song structure the
algorithm other than that change is
basically the same for breadth-first
search in fact the first found solution
may not be the best because it's
minimizing by the structure of the
algorithm the number of steps the number
of edges and so one needs more
sophisticated methods to actually try
and solve it just to give you a
difference or a sense of the difference
between them let's look at a couple of
simple little examples here's that graph
extraction we have a beginning of our
lecture about different flights if we're
just minimizing the number of edges for
example going from here to there either
algorithm will find it and in fact are
in month a number of different solutions
so here's one it's got four legs here's
another it's got four legs and in fact
there are a bunch of them with four legs
here's another one with four legs we're
minimizing the total number of edges
along a path when we take weights into
account for example the cost of the
flight then things are a little bit
different and in fact in this graph one
could actually run an algorithm to show
that the best solution is this one which
has a cost of 300 plus 200 plus one
fifty plus 130
just five six seven hundred and eighty
dollars and you can explore this for
yourself that discover that any other
path through this graph in fact has a
higher cost so sometimes we want to
solve minimum minimal problems or
optimization problems with weighted
edges sometimes it's just the total
number of edges alright with that in
mind why are we doing graph optimization
well as we said we have lots of problems
that are naturally expressed as a set of
transitions between a state of a system
and those often can be easily solved as
a graph search simple examples will be
ones where the actual structure the
problem is itself a graph travel through
a physical network whether it's a flight
network or whether it's actually
something like using your GPS to find
out driving routes from one location to
another in those cases the nodes
naturally correspond to physical
locations like hubs or intersections and
the edges naturally correspond to
physical structures flight paths roads
but there are other problems that are
also well described as grass imagine
you're trying to program a robot to
accomplish some task here the nodes may
be the state of the system the locations
of pieces or the location of the robot
and the edges are actions that that
robot should take to change the state of
the system again well solved as a graph
problem and indeed that leads to a more
general sequence or collection of
problems those are problems where a
physical system is being handled or
manipulated and here the nodes are
descriptions of the state of the system
parameters that describe the positioner
state of the system in the edges or
actions that will move or transitions if
you like that will move the physical
system from one state to another and
again those are well solved by graph
optimization problems and that says
basically what we've shown you are two
very handy tools for doing depth-first
and breadth first search to find a
sequence of transitions that transforms
a system to a desired gold state these
methods can find optimal solutions to a
wide range of problems that are
described in this manner and they're
going to be really valuable as you use
these tools to solve problems of
interest to you
hello students it is already midnight on
the night before you are calculus exam
and I figure in that promised you that I
will make this video to show you how to
calculate the shortest path using
Dijkstra algorithm so this is my first
time recording this kind of video so it
will be a little bit awkward for me to
talk to myself and explaining things on
this screen so let's start we use
Dijkstra algorithm to determine the
shortest path starting from a and ending
at Z each step will follow the
pseudocode as outlined in the lecture so
I will start that by first changing the
color here to red okay and the first
step of Dexter algorithms is to set all
the cost of different of each vertex
that are not the origin to infinity so
now the cost of b c d e and z are
initially set to infinity and the cost
of a is initially set to zero then
iteratively which means we use the loops
for this it's relatively we will select
one vertex that has the lowest cost and
include that vertex into a set of paths
and then after the vertex is included we
will update all the other vertices the
cause of all the other vertices so that
it reflect the choice the choice that
you make so for the six vertices you can
see that a has the lowest wave has the
lowest cost
sorry so we initially select a to the
set when a is selected to the set we
have to update neighbors of a which are
B and C because they have they have
edges that connect a to that vertices we
if you make the cost of that vertex
lower how much lower is that depending
on or how much higher depending on the
existing constant which we have here
equals 0 the new cost will be 0 +44 B
and plus 2 for C and you can see that if
you add 0 to 4 which is equal to 4 this
4 is less than infinity the current cost
of B so we now set the course of B 2 for
the new value and the cost of C to 0
plus 2 equals 2 then from 5 vertices b c
d e and z c is the lowest so we now
select c into the list when say is
selected to the list we have to update
our tail vertices so that the cost of
all the vertices correspond to the
shorts that we make so when we select c
to the list the path from A to B passing
through C has the lower weight which
which is 2 plus 1 equal 3 comparing to
the current wave current cost which is 4
2 plus 1 equals 3 is less than 4 so we
update this cause of be 2/3 which
corresponding to moving in this
direction and then moving up here
the next one D we have to which is here
2 plus 8 equal 10 so the cost of D + 10
is less than infinity
the current cost so the cost of D here
will be updated to 10 and the last one e
the constabie be updated to 2 plus 10
equals 12 then for for what it says B is
the lowest so we will now select B into
the list this means something like we
traversing from A now to C and C now to
B but please be careful because this is
not traversing actual traversing we just
trying to determine the shortest path
it is possible like in your in-class
exercise that in some cases this path my
stuck at some dead end and we may need
to use to explore all the paths
depending on the current cost in the
network but for now you can see that it
is quite simple in this case because it
flow from the left to the right without
any dead ends for the now we selected B
we selected B into the list we have to
update the cost of de and Z the cost of
D view now be updated to 3 plus 5 equal
M which is less than 10 and the cost of
oh just that because D is the only
neighbor to B now for a and 12 and
infinity we can see that a is less than
the rest so you now selected D into the
list when do you select it to the list
we have to update e and z
because they are both neighbors 2d the
cost of e will now be updated to 8 plus
2 which is 10 and it is less than e the
existing cost of Eve each is 12 so this
is now updated to 10 and cut at Z from
infinity we reduce to 8 / 6 which is 14
from E and Z you cannot jump to see yet
because you can see that the concept
traversing from de to Z is 14 and you
have a better opportunity for now which
is 10 so we select e into the list and
after selecting a e to the list we have
to still updating the cause of Z the
last one from 14 to 10 plus T 10 plus 3
equal 13 and the last one will be
included wishes I noticed the
destination and from this we have the
path like this and the cost is 13
in this video we're going to talk about
multi graphs so this graph right here is
not a multi graph because any vertex we
start at a B C or D notice it's really
only one edge that connects any two
vertices so a and B are only connected
by this edge and D are only kept it by
this edge D and B only by this edge C
and B only by this one edge and C and D
only by this one edge I could add
another curved edge on from C all the
way to a but this is still not a multi
graph because there's only one edge that
connects two connects from A to C but a
multi graph which has a lot of great
applications which I think we'll talk
about the future videos is the situation
in which we have more than one edge
connecting any two vertices so let's add
those and in green maybe I have another
edge going from A to D well now I could
take the green edge or the red edge to
get from A to D I've made a multi graph
I can keep compounding this I can add
other edge going from D to B in C to B
and A to B and C to a so to identify a
multi graph we look at the vertices is
there more than one edge connecting a to
voters vertices if the answer is yes
then what you have is a multi graph
alright hope it helps
hello everybody I'm rich
Johnson and yes this talk today is
about a hardware platform feature on
Intel processors called Intel processor
trace and we'll talk about the internals
of how all that works and how to apply
it to things like buzzing as Belinda
mentioned i am the research lead for
cisco Talos we're a small dome dev team
and primarily focusing on finding bugs
and doing technology innovations which
is where I focus this is my third or
fourth year speaking at hack in the box
so it's great to be back I definitely do
want to highlight that I have a research
partner aundrea leaving who's done a lot
of this work with me he's a great kernel
developer and helps with the
implementation of the driver we've given
this talk together previously but he
couldn't be here today so basically my
last few years of research have been
around trying to squeeze out as much
performance as possible during the
fuzzing process and I've had a couple of
previous talks that have gone into the
directions of looking at various ways of
tracing either using hardware features
such as legacy versions of what I'm
going to talk about or using things like
dynamic binary instrumentation things
like tin and dynamo Rio so you can hook
applications as well as looking at the
platforms and processes and everything
from input selection to how to tune your
virtual machine so that there are the
higher highest performance available so
if you're interested in this topic these
slides previous talks are available out
there on the internet my websites low
flow org it'll be at the ends don't
worry and so this this research started
just last year last fall and I'll tell
you about the progression through that
and most importantly the driver's side
of what I'm talking about today is
available so the tracing engine that
powers all of this research is already
available to available it's right now on
github / Intel PT and actually the code
that I'm using for the fuzzing side will
also be released if not this week then
next week everything is going to be open
source here
so basically our agenda will be an
overview of Intel PT talk about the
internals of the driver implementation a
little bit so we're going to get into
some windows kernel programming stuff
for a little while and then there'll be
a whole bunch of demos we've got an Ida
plug-in and various demos to show you
how to use this and so on before I get
started just to get a pulse of the room
I couldn't get a raise of hands who's
done buzzing or actively does buzzing
knows a little bit about buzzing okay
good and then how many people here have
done driver developments on the Windows
platform or anything along those lines
ok so the fuzzing stuff is the second
half I apologize if it gets a little
dents in the first part where we talk
about the driver but there will be a
good payoff an end no spoilers but this
is the fastest engine for doing andros
buzzing so so Intel processor trace what
is it well it's a low overhead hardware
execution tracer it's built into the
silicon of Intel processors going from
Sky lake forward specifically Broadwell
forward but skylake is the architecture
where it's fully baked broadwell had a
limited feature set and basically what
happens is each core and including hyper
threaded cores in your processor have a
mechanism in which when the instruction
decoder encounters a branch instruction
it goes off and if you have checks a
register and the CPU that you can set
from privileged mode and it says okay
are we especially handling branches and
if so how do you want to handle them and
the processor tray subsystem is how that
all happens inside your CPU there's
something called a performance
monitoring unit you know similar just
like there is an ALU that does your
arithmetic well there's a PM you that
does your performance monitoring and
most commonly this is something that you
might see that will tell you like things
like branch misses
or how your cpu's utilizing your cash
simple counters that you can utilize
well there's a whole lot more in there
as well that aren't is commonly used
there's some legacy systems like i
mentioned called like branch try store
and other things and so the important
thing to know is that this is just
inside your processor and you configure
your processor in a specific way to turn
it on the properties of the trace and
this iteration of them giving you branch
tracing are finely tuned for perform too
for performance so it doesn't have an
impact on your CPU cache and so it's
very performance in the log that outputs
is very small so it has a small space
requirement as well so of course we're
talking about branch tracings so what do
we use this for obviously code coverage
is the main focus here for fuzzing and
then also it can be used in malware
analysis and other sorts of things where
you need to recover where your execution
went on the logic that have followed in
the program so in order to detect if
your processor supports intel PT
programmatically because you know you
can't just trust a guy like label or
something you use the instruction cpuid
and cpuid tells you you know
specifically what model of secure your
running and an MSR is a model specific
register so each version of the
architecture has different sub features
that are accessible from kernel mode or
hypervisors to configure the processor
running in different ways the most the
old common one that you may have heard
of is you know the switch from real mode
to protected mode is one type of
operating pursuit mode you know there's
a vmx mode now when you have hypervisors
and so on so this is in a similar vein
where you're specially telling your CPU
to enter a special mode and one part
that's exciting about this one of the
reasons that I took up the effort to
work on this was that there isn't an
available engine for utilizing this on
the Windows platform it is inside the
windows current on the Linux kernel side
I was like 4.3 if you
compiling some special extensions but on
the window side there really wasn't
anything available there is an Intel
system studio but they have a window bug
KD plugin for the kernel debugger that
will set these msrs for you but the way
that it's set up is really meant to be a
master-slave debugging scenario and not
really useful for fully automated
backend engines for unmonitored
execution training so that was kind of
the motivation here and then timing-wise
I've been aiming for getting it done
right about now because the Xeon CPUs
are switching to the sky like
architecture this year and so now when
you go out and you buy hardware to do
malware analysis or fuzzing at scale you
can use my software and use this right
away so so anyways as I mentioned you
see PID it looks something like this
this isn't too important but the point
is it's pretty simple once you know that
you have the right processor you can
Clary which sub features of Intel
processor traits are available because
there's a bunch of them essentially you
can trace either user mode or kernel
mode you can filter on a specific
process of using the CR 3 which is your
page table pointer you can tell it that
you want to reserve a range of physical
RAM that you want it to do like a ring
buffer right out to or you can tell it
hey you know I've actually created a set
of page tables for you so I can grow and
still only manage physical memory myself
so on so again there's a bunch of
configurations this is a whole new
chapter in the intel architecture manual
actually chapter 36 it's about 100 pages
and it covers all the sub features
available in intel processor trace and i
totally stumbled across this by accident
but it's hard to miss a whole new
chapter and the manual when it's on a
topic that you're interested so you can
do all sorts of things like you know put
out precise timing information if you
need to synchronize these or if you need
to pull out you know if you're utilizing
multiple cores then each of those logs
are written separately by each core and
you might have to synchronize them and
so on and so on I think I have a
graphical version of this in a second
but the reason that we're interested in
this for code
coverage is number one you know we can
trace native binaries so that's
important we don't need source code to
to add tracing logic to its implemented
in hardware so it's number one it's
reliable you don't have to do any sort
of graph recovery to do instrumentation
or anything related to the software at
all it runs like I mentioned in kernel
and user it runs in vmx mode it's
available in VI next mode no hypervisors
actually expose this feature yet but
we're working on that as of last week it
works but most importantly the
performance is really good so the
overheads that you see with this is
fifteen percent to cover everything
going on your system so system-wide
branch tracing for fifteen percent
overhead is more or less unheard of
unless you're able to do direct source
instrumentation and it logs to physical
ram instead of two instead of you giving
it a user space allocated buffer the
demure colonel passes down and then
there's address translation that has to
occur to write in that buffer for you if
the implementation takes the virtual
memory addresses to write that buffer
well that means that every single branch
is going to have to do a lookup in from
the physical range that its operating on
in the CPU to what that virtual address
is and that pollutes your cash that does
that translation normally so when you're
executing code or referencing normal
data and that's in the course of running
a program normally you want you know the
most recent code to be in your cash and
the most recent data to be inter cash
but if every branch you have to go out
and write out to a buffer well that's
going to pollute your translation
buffers and it will flush so by making
the consumer of this tracing engine like
us who wrote the driver have to handle
all the memory management ourselves it
can just say hey I expect some physical
RAM and it's up to you to figure out it
do it and since you're giving me
physical ranges that means that you're
ensuring that the OS isn't going to
stomp all over it or whatever and we
don't have to do any cash pollution so
it incurs a bigger cost upfront to get
everything configured but at runtime is
very very
and then another annoyance and utilizing
it is that the recording format is so
sparse that only records 1 bit per
conditional branch and it records you
know long branch target so if you have a
far call or or something like that then
then you'll have some of the actual
address in there but otherwise you have
to do an online disassembly to determine
where those branches are going so again
on the implementation start site it's
kind of a difficult thing to do but at
the end of the day once you get it all
configured you can operate in different
modes of filtering so like I mentioned
either all of user mode or all of kernel
mode or specifically you can trace a
single process using the pml for page
table which is kind of in x64 it's
another reach to your page table
partitions or you can specify up to four
ranges of instruction pointer addresses
so you can say I'm interested in this
module that's mapped into memory you
know this maybe I'm interested in these
couple of modules or I'm interested in
this kernel driver and also the user
mode application that interfacing with
it and so on so it has some pretty cool
configurations I've added some stuff to
this talk so some of these
implementation details around how to set
up the memory since we don't have too
many colonel programmers here all kind
of gloss over I got a brand new feature
working as of today that's pretty killer
so but in kernel space if you want to
Alec if you want to use it in the
simplest mode and in fact on the Linux
kernel they have an option to always
have it on and to always be writing to a
ring buffer so if you end up with a
kernel crash you have that available and
it will dump it out so one way to do
that is to reserve a range of physical
RAM when the colonel is a place is
booting before your physical memory gets
fragmented and in on the windows side
you can do that through allocate
contiguous memory our driver happens to
implement all the features available at
this point so you can use our drivers
reference kind of on the internals of
how this all works as well the table of
physical addresses
is an option for configuring it and
fortunately it ends up using the same
structures that are necessary on Windows
to set up the memory descriptor lists
that it uses for virtual memory
addressing so it turns out to be fairly
easy until made it as easy as possible
knowing that we're gonna have to do all
this work and this is the mode that we
generally operated there's a smaller or
there is a small runtime hits because it
has to do page table walks obviously but
at the end of the day you can make your
logs as large as you want them it was
much virtual memory as you need and then
of course we get interrupts whenever
that's full and it lets us dump in parts
everything so the packets of interests
are I'll just give you the visual
version on the the green ones are the
taken not taken and taken IP address so
these are your branch targets or whether
or not your conditional branches were
taken the f updates is the prime updates
then paging in packets so that's
important if you're tracing multiple
user processes and you want to know when
a certain process gets paged in and is
activated and so on if you're in ring
three mode or ring 0 and then theres
some timing stuff as well and then the
trace the PSB and oviya those are
synchronization packets that are in
there so allows you to seek ahead so for
our driver we've released a number of
versions over the last almost year I
guess since actually only since may be
almost a year and at this point in our
first version it only you know supported
the single buffer it was really weak but
right now it's fully fully working fully
baked pretty much we run version 5 or
0.5 but there isn't really anything left
to implement right now other than some
testing and we support multiprocessors
all the filtering modes and output modes
and in the last two months the thing
that we've added are the kernel mode
tracing and also you can utilize this
from another driver in kernel mode as
well so I have a user mode library that
I use to interact with it with our
driver via I octal and then now there's
also an API exposed from the kernel side
to utilize it as well and then there was
some low lower level stuff that we had
to manage along the lines of how to map
those buffers and the apex program
programming which is how all the
interrupts are handled outside your CPU
and so on so the performance monitoring
interrupt is a special interrupts and in
Hardware the basically the way that you
do asynchronous notifications are via
interrupts and so when we put the CPU
into a mode to log all your branches we
say you know go ahead until either we
tell you to stop or certain conditions
arise such as the buffer being full and
when the buffer is full we want to be
notified so we have to register a call
back in a kernel that listens for
particular interrupts to let us know
that school so in order to do that we
had to jump through some hurdles that I
will partially skip over but basically
you can use the Hal set system
information API which is pretty much
undocumented that you can grab the a pic
interrupt a dress out of there and then
register your interrupts address with it
and then of course this is running at a
super high privilege level and so in
order to be able to communicate you need
to use things like deferred procedure
calls and do things asynchronously it's
like a whole bunch of layers of
indirection so for the user mode buffer
that you want to finally get back so the
way that we utilize this right now is we
have you know a controller application
or or what have you and then you have
your target application that you want to
trace and we need to have the buffers
that you want to parse and utilize
mapped into that controller application
because if we map it into the target
application and we end up with you know
a crash or something for fuzzing and
we're trying to cause crashes well that
crashes while the CPU is locked pages
into ram and is you know expecting
things to be there all of your process
dies then all of a sudden the colonel
tries to clean up those pages and your
CPU shits the bed and that's no good so
in order to do that you know we set up
these page tables and we tell the
interrupt handler to tell us when it's
full and we use the windows memory
descriptor lyst api's and we lock it in
there with IMAP lock pages blog for the
multiprocessor and multi threading
support we just had to add a layer of
abstraction that essentially you know
has specialized structures that handle
all the configuration for this and then
of course we had to be able to handle
Kendall interrupt and determine which
cpu core comes from and then right now
the last stage which was actually
advertised on the abstract but turned
out to be a rabbit hold it didn't pay
out was we were trying to figure out how
to separate user mode threads which are
a completely different abstraction than
your hardware threads so that we can say
you know i'm interested in internet
explorer but i'm only interested in the
thread that's doing you know javascript
parsing or interacting with the dog or
maybe that's a bad example because they
spawn acing this all the time but maybe
you're interested in you know any larger
application but really you only want to
follow the parser threads and as you'll
see here since that log format was so
compressed there's a lot of work in
decoding it so the more work we can take
away from us but less data that we have
to parse and translate back into actual
branch addresses the better so we went
down the route of doing windows event
tracing etw and had to do some reverse
engineering of how that all works on the
colonel side because you're supposed to
generally you're supposed to give define
what you want to trace so we wanted to
trace the context switching
windows kernel and so you know normally
what you do is you give it an XML blob
and it generates code for you and says
okay use this library this library will
now tell you whenever context which
happens only a context which isn't
actually one of the things they let you
do and then we needed to do this from
the kernel mode side so long story short
we went through about a couple weeks as
implementing that reversing it and then
we realized oh shoot that's all
asynchronous and so at the end of the
day we were notified that thread had
switched who knows how many milliseconds
ago and so that key synchronized our
logging and so on so that is the last
remaining issue to solve which is
probably going to be solved through a PC
but that's neither here neither so the
colonel boat racing I'll be able to demo
for you it's actually really cool we can
trace our own driver because all the
tracing is happening from the cpu so
there's no issues like if you want to
kind of cell trace or trace any any
arbitrary code running on your kernel of
course the the way that you interact
with our driver is that we have named
pipe that you interact with and you said
I opticals down there and naturally you
need administrated privileges because
you know you wouldn't want a low
privileged user to tell the CPU to start
tracing a high privilege process so on
but yeah so now we can trace kernel
module loads and unloads and all the
things going on inside and so on I'll
demo that here in a little bit and at
the end of the day is abstracted fairly
well I have as I mentioned a library
that interfaces with this but generally
it's as simple as you get a handle to
the device that we expose and you
interact with it through some I octaves
to start the trace and then you can stop
the trace and then query you know how
many packets that I receive and so on
and this is probably not too important
for you there were some other tricky
issues making the page tables not get
swapped out yada yada but let's go ahead
and just look at some stuff here
let me fix my mirror
sorry as i mentioned i was working on a
new feature that's kind of the exciting
addition for this version of the talk
which will be the last version of the
talk and so I didn't get a chance to
fully get my demo set up ahead of time
but this isn't so bad okay so generally
we install a service that controls the
driver the driver right now since I was
already doing some testing as you know
compiled and installed we have a demo
app that we ship with it me make this
not at the bottom make this a little bit
bigger for you okay so that's okay
alright so first we'll do some user mode
traces you know we can do the something
as simple as notepad and how many
processors do we want to run it on we'll
just do it on the one for the moment all
right of course we get a nice unknown
error
okay so basically give an idea of what
we're dealing with here the output is
this you know this binary format that's
not at all useful to us unless we decode
it fortunately not sure ok so when the
Intel shifts a library called live ipt
and so this is the output format
obviously to binary format has all those
packets exposed we're able to jump that
to text to give you an idea of what
we're actually looking at the contents
here so these are those packets that I
had just shown you so the PSP is kind of
like the start that this is a take an IP
packet and so we can see that we do have
some long branches here so we can see
the full physical address or full
virtual address rather and then we see
things like take an IP no idea take an
IP but only the low word then we have
things like the taken not taken and the
taken not taken you'll notice how these
exclamation marks and dots and so those
are determining whether or not that
branch was taken or not so it codes up
to six branches into a single bite the
other two bits are used for the actual
packet ID and so on so this is what we
have to start with and then naturally we
need to determine what those branch
targets were that they cannot taken us
so on so let's look at this an item
let's go ahead
alright so this is notepad and we will
go ahead and run our I to plug in here
probably should I run this legal
something with symbols sorry
I'm not sure it actually loaded that
file properly
yeah okay let's try that again sorry
this has been a moving target because
every time I give this talk it's a
totally new version of the code and
obviously we get to synchronized a
little bit sometimes
maybe I'll just jump to the colonel one
that has a symbol so it'll be a lot
easier sorry about that yeah let's see
the colonel chase real quick just so
that we can get back on track
okay so now it's tracing in the
backgrounds my actual driver itself
which i think i have symbols compiled
for so we hopefully will be able to see
here
verify this
okay yes and here we can see obviously
this one's even a bigger pain because it
has a lot less full addresses that you
can utilize so let's try that one more
time
all right yes so this time we have
symbols so we should have better luck
here
shit i'm having an issue parsing the
file here unfortunately the side of
plugins probably ought to sync with the
the parser on the that we're committing
for the output basically what you
normally would see here I've got more
demos that you guys will enjoy it but
what you'll normally see here is your
typical overlay with highlight of blocks
and then it will actually deepen the
color we use blue and it gets darker
blue four cycles so it's immediately
obvious I when you get the cycles yeah
it's a real number if we have time at
the end I'll come back and do this one
again I don't want to waste too much
time just root around with this one so
yes let's get back to the slide show so
okay so we have a fast racing engine
fifteen percent overhead we're recording
all the branches you'll just have to
trust me that learn to code and abruptly
but I to plugin so how do we utilize
that for bone discovery well so
evolutionary buzzing is more or less the
hot sauce going on today it's
incremental e better mutational dumb
fuzzing via using a feedback signal
which of course in this case is code
coverage so we can determine did the new
newly generated input reach new parts of
the code right and so basically we use
coverage and then we basically use the
code coverage as a fitness function
which is what you would use in genetic
programming and then we also utilize
that over time to determine each new
input it's interesting from my last
couple years of talks the required
components in order to do this
effectively is we need a fast racing
engine obviously the slower your tracing
engine is you can't execute many times a
second we need block-based granularity
as opposed to something like function
coverage the early research in this
space was jared's Amma's and the EFS
evolutionary fuzzing system from like
two thousand six or so he did the first
PhD and he really dope deep into the
science of how genetic algorithm
work and what fitness landscapes there
are you know what attributes you can put
into it but at the end of the day we
need to minimize the attributes that
we're looking at because we need to do
very very fast lookups and references
across your entire population pool so
all your entire corpus and in order to
do that we need a data storage that is
very efficient to do comparisons over
time and so American fuzzy laugh is the
buzzer that people have been using the
last few years it develops by Michaels
the whiskey who's done a lot of great
work over the decades and it was
originally designed as a buzzer for
open-source software it operated by
modifying the assembler output at GCC
and annotating it such that you could do
call out to your coverage function it
implements the variety of traditional
mutation buzzing so you know you're
flipping bits or bytes or words or you
know kind of taking half of two files
and merging them together and so on it
has a nice catalog of different types of
mutations and then using the GCC or
using the modification on the assembler
emitted by GCC then he compiles that so
instruments the you know dot s file the
intermediate file files that so it's
baked in and then most importantly
probably it was to track it over time he
uses a bloom filter so you can determine
whether or not you've traversed this
edge from block a two block B previously
and if you're not familiar with the
bloom filter it's essentially a lookup
of a map in this case he uses 64k of RAM
which happens to be the size of a old
CPU cache modern architecture still have
128 k now but 64 k for the cash because
you're hitting it on every branch and he
takes the previous basic blocks address
and the next basic block address and
does a simple hash by shifting the high
bites off and soars them together and so
then you end up with this
you know this one 64-bit value that
represents an edge transition and then
modulo the 64 K map that he has he
indexes into that and then increments
that offset and so that's how many times
you've traversed this particular edge so
that happens to be a really really
efficient both in space to store all
that so previously if you looked at
block tracers what they would normally
do is record every time you enter a
basic block either in a text or binary
format you end up with a list of blocks
and then later on you have to figure out
how to do a diff across those executions
so this kind of keeps that state all in
one 64k blog for you and then not only
does it keep a single execution but of
course you can keep over time the entire
corpus estate as you've gone through
them so it's very very trivial to
determine if this new execution that you
just did has incremented any of those
bites in the maps so very useful and
very very fast to do comparisons on and
then of course this was written using
POSIX API and so on and what we're
interested in is applying this to
windows so I think that covered all that
also for server was another important
addition that used for performance
architectural e on Linux when you create
a new process of V of Fort uses
copy-on-write on the memory pages so
it's a very very fast to initialize new
process the matter of copying page
tables so rather than having to do a lot
of work to initialize and reload and
remap all your binaries it's using the
already maps physical memory and just
copying a page tables oversee a new
process points the same thing and then
you can do nice fancy tricks like wait
until a little bit later in the process
to do your Forks so you can skip all the
unnecessary code before your input is
seen and parsed all these things are
great performance additions and very
very important to the architecture of a
fast modern fuzzy and the kind of a
keynote here is a Venn nagi originally
pointed out
is that you know when we're buzzing
complex you know large targets like you
see commonly on Windows you can still
use these efficient buzzers to generate
corpus so now if you want to go the PDF
library and windows let me wanted
Windows 10 an edge you know that's
actually really difficult instrument
it's slow hasn't a synchronous API
there's all kinds of complications
around it but you know you can take
American fuzzy lop and point it at
poplar any other open source PDF library
and it keeps the corpus it keeps every
unique input that it saw take a
different branch and the open source
version so you take all those over and
then that's where you start buzzing on
the windows side so that's just a little
side note but some fuzz don't keep the
entire corpus they only keep the crashes
and actually a lot of value is in those
unique inputs that you can then use as
inputs into other parts of your workflow
so yeah we covered that so on the
windows side I started looking at this
ruxton or so in 2015 and the initially
my tests were actually on the Linux side
since I noticed but this feature was in
there and then was looking if anybody if
it was available to use via software you
know I notice that Linux had it
available so not only does linux have it
available but i actually used a
reference driver that's available from
intel it's on github called simple PT
written by andy clean who also wrote the
other p mu tools available for linux so
so i started off on that direction and
just to see what kind of performance
would get out of it the performance was
sufficient enough that i decided to go
on this you know kind of long trek and
trying to implement this on Windows and
naturally the biggest problem on Windows
is that we don't use a lot of open
source software or at least the software
that you might download from vendors
is the open source stuff will be baked
into other binaries and so on so we
really do need a binary tracer to work
on this and the while I was thinking
about this on how to move to the Windows
platform it turns out that I've been
Frederick from google was also on the
same track and not on the Intel PT side
but he just clearly identified that AFL
is a great closing engine wouldn't it be
great if we could get this on Windows
and he happens to work with Zaleski so
that was kind of a natural thought
process I'm sure and it's available now
it's American fuzzy blop it does work on
Windows there was quite a bit of
internals that had to be modified since
Windows is not at all posix compatible
and then of course you had to choose a
tracing engine that will work against
minors in his case he chose dynamo Rio
and the implementation on its plugin is
actually excellent in if you look at my
previous talks I really dissect the
differences between tune and dynamo Rio
diagrams and so on and why you should
choose one over the other and my
conclusion there was that dynamo Rio is
the better platform if you need
performance and the primary reason is
because on pin and most dbi platforms
will allow you to insert hooks out to a
callback function but dynamo real
actually lets you synthesize
instructions directly within the basic
blocks so you can do and it also
supports small static analysis so it can
do a live pneus analysis on certain
registers within that basic block you
can determine that oh this is a dead
register within the block so I can use
it to implement you know a faster table
reference for example rather than
calling out and you know doing cash
pollution that way so he definitely it's
one of the prettier dynamo real plugins
out there it's worth studying for that
alone it's good code but yeah so he's
using dynamo Rio you can filter based
upon which module you want to do code
coverage on because demo reel is good
it's fast for dbi but it's about 30
times slower than eight of execution or
so so you want to limit the code that
you're tracing and then he also i
recently actually had a chat with them
and we kind of fixed the multi threading
edge coverage but it has a block mode in
edge mode essentially the solution for
doing the edge tracing across threads is
to use the thread-local storage to store
your last branch otherwise if you get
interrupted in another threads executing
you have a fake edge that doesn't
actually exist and then the biggest part
the most important part is that he does
persistent execution meaning that he's
doing in memory fuzzing and this is
important in particular with dbi because
the way that they work is there a custom
loader for your process and when you run
your process the dbi loads it and took
every branch if you register branch
callbacks and it has to disassemble that
branch each time it discovers a new one
and so naturally every time you restart
a process that has to do that all over
again these aren't being cached to disk
tenemo real does have a flag that's
meant to cash its instrumented basic
blocks to disk but it it has issues and
in reality it isn't fully there so so I
haven't sucked the persistent mode
approach and the idea is that you pass
in an offset into a module the module
can be your own module that you wrote
that's a wrapper for an API which tends
to be the right way to go if you can or
you can specify an arbitrary offset into
an application or arbitrary dll that's
the function entry points and you tell
it how many parameters are passed to
that function and then it's able to use
the dynamo Rio API to rapper that entry
point and you know do a loop for n
number of iterations before exiting so
this works out to be really good and
very performance better than anything
else that was out there on Windows and
for example since we are using dynamo
Rio if we restart the process every time
which essentially disables the
persistence because it's not doing it
memory buzzing it takes a you know a
half a second at least to do their demo
which is a wrapper for gdi+ now if we
enable persistence mode then we get a
much healthier 72 executions a second
and that kind of tops out somewhere
around a thousand iterations just over
100 executions a second so this is good
performance it's not quite where we're
at on the Linux side with being able to
do source instrumentation which might be
triple or you know up to five times that
speed or so but it is quite good and
really just the key takeaway here is
that persistence is the key particularly
if you're using BB I so where did we go
with this well we use our Intel PT
driver I wrote some code to wrap that
inside of a FL and initially we have all
these problems that we have to solve the
block IDs aren't available so I had to
figure out a way to you know obviously
it's a disassembled online and then
build your own cash for those branch
targets to do it efficiently and then
ideally say that out to disk we you know
the larger the file is the log file
obviously it takes a while to do that
parsing so we want to limit the amount
of parsing Lee need to do previously the
third point said that said that
persistence wasn't implemented yet but
that's the new big feature as of today
and we can limit our the code that we're
tracing down to the four ranges that are
available supported by the hardware
engine so so the current at current
status is now we accurately decode the
full trace the take an IP packet of
course hold the target address and we
get that for the indirect branches in
return we disassemble you taken not
taken packets and have a branch cache
and then of course we use that we have
to come up with our own little way to
encode it into the bloom filter since we
have full addresses and not block IDs
but that's fairly simple and of course
since we don't have fort we need to
use create process and wait for single
object just like you normally would I
did do some research we did try to
implement native windows fork using some
undocumented ap is called NCR RTL
colonias or process and went down that
path we got it working the only problem
is these are NT subsystem api's and are
not aware of the win32 subsystem so
basically anything that links against
user32 and CS RSS is not aware that your
process exists and so it was kind of a
chicken and the egg thing we could
compile library is especially not to
link against user32 and do that and have
fast forking and that was all great on
our own wrapper but the default compile
flags for visual studio the ones that
all software are going to use that you
will see I mean you'd be lucky to find
any program out that it doesn't like to
use a 32 so unfortunately that ended up
being a fun little journey down a rabbit
hole again that didn't pay off but it
was interesting research but so so
previously I was comparing my
performance iterating each time creating
new process and puzzling against it and
I'll show you those numbers in a second
but as of today the native persistence
mode is now implemented I don't have a
lot of slides and describe this to you
so I'll just kind of do it verbally Alex
lioness do last year at recon gave a
talk on various modes of Windows hooking
that are built into the system and one
in particular that's interesting and may
now be on your radar as of the last week
or two is application verifier dll hooks
they're relevant again because some
cyber company out there thought that
they invented some new malware technique
or something but so now I don't know I
chose this approach as opposed to just
doing DLL injection because I figured
well I want to run this on systems that
might also have anti-malware software
running didn't want to cause issues and
flag with that so I figured ok if you're
going to use something like page heap
and windows the way that it's utilized
is via application verifier
infrastructure and so I was like
thinking that would be a great system
supported undocumented the system
supported API for
doing DLL injection so that's what it
uses it's pretty cool maybe I'll pull up
that code in the second but you can
define some structures that say I'm
interested in hooking this export from
this library and all you got to do is to
find a couple of structures and your
hook function and it's done turns out
that and I also needed to do raw hooking
as well in order to do like you know
arbitrary function hooks and so on your
actual rapper hook and so I ended up
using die storm X which was just
released last summer by the author add I
storm which is separately I've done some
research on various assembler engines
and I storm is actually twice as fast as
capstone and more accurate it's the
fastest and most accurate disassembler
out there so that's the 1i favor and
then there needed to be an IPC channel
when you're doing the persistence mode
because now instead of just waiting for
a process to exit you need to be able to
notify the buzzer that okay i did an
iteration i'm back to the wrapper
function i need a new input to be
generated so i can do it again so
there's a small little IPC mechanism
using named pipes as well and so what
does this all looks like so in order to
do some raw performance testing i
figured the first thing that we should
do is figure out what would be our
create process in wait top ends before I
got to the persistence side so in this
particular demo the one that comes with
win AFL the gdi+ rapper I was able to
only create 85 you know it or 85
processes the second is that we're
loading and parsley file that's without
tracing whatsoever that's literally just
a tight loop createprocess wait for
single object parsad bitmap file using
the gdi+ API the two API calls so then I
enabled the Intel processor trace
without logging the output just to see
okay what is the runtime hit that we're
getting here the docs say they should be
about fifteen percent is that what we're
seeing so yes in fact it was almost
exactly fifteen percent so we went from
85 down to 72 executions a second
alright so then we add in the part
thing of that log file with you know the
binary logging and we're down to 55
executions a second which was another
twenty two percent parsing overhead so
in sum we hit about thirty-five percent
overhead on doing the Intel processor
trace tracing and starting any process
each time which turned out to be
slightly slower than the win AFL version
which I used to have in this slide but
it got moved out of here but basically
they were they were hitting closer to
like 80 executions a second and I was
getting 55 so that's where basically the
the talk was ending you know last time I
gave it except there are some gotchas
because dynamo Rio has a variable
performance depending on how much code
ass is disassembled and and what it
takes to bring that process online under
the dbi whereas intel PT has a reliable
fifteen percent to code overhead so I
decided okay well they use a gdi+ rapper
why don't I use lib PNG or something and
naively just wrote a simple PNG parser I
was like what the hell this went down to
half an execution a second versus what i
was getting with intel PT which was like
60 for executions a second and that
seemed weird so I ping dive in and I'm
like hey that doesn't seem right that's
a hundred times performance difference
well it turns out there's a lot of
gotchas when you use something like
dynamo Rio this turned out to be an
issue with vile descriptor management
where and windows file management is a
pain in the ass but long story short
that's not an accurate representation
once I modified some stuff a little bit
they were back on par so it was up to me
to say alright we're finally going to
tackle this persistence problem and so
I'll demo that for you but what we
should see is we're now five times
faster than the current version of
winning FL so if the demo gods are with
me on this one we'll at least get to see
that so first let me show the dynamo
real version
alright this one
okay yes okay so this is a live version
of dynamo Rio tracing the gdi+ and we're
seeing this will climb a little bit over
time as things that the cash gets hot
and so on I think this actually does top
out closer to 65 or 70 but as you can
see pretty obviously the performance is
in that range and as of today some of
the changes that I had to put in here
that obviously screwed up some of my
other demos but yes so now we're seeing
that with live in Intel BTW tracing
using persistence mode in memory fuzzing
we have 230 this actually will get to
like 260 as well so we've got like a
five times performance increase so
that's the the main new thing here today
so the driver is open source right now
this code will be open source soon and
it will have advanced the performance
against windows binary by five times
yeah thanks so the conclusions takeaways
here trey songz use and buzzing dynamic
analysis we you know have all kinds of
applications for doing the branch
tracing my particular application today
is buzzing yours might be doing mallar
analysis across the billion or I'm you
know a million samples a day or
something it's definitely a promising
iteration in the hardware support of
tracing it's like 30 times faster than
the previous generation of supported
tracing if not more which tells us the
Intel is actually dedicated to producing
you know more interesting dedicated
silicon for doing things like security
analysis and so on my hope is that
someday they will put some sort of data
flow tracing capability into the
processors so we can do things like
online paint tracing that are efficient
and so on so we'll see if we get there
so the to-do list number one we tried
that we finished that doesn't work so
that's not the right way but the right
way is probably using asynchronous
procedure calls which allow you to
preempt thread activation with your own
custom function if I was thinking like a
malware author I would
at first but i was thinking like a like
an antivirus author went the other way
so yeah that wasn't good the hypervisor
support on this as i mentioned when your
cpu is in vmx mode the hypervisor mode
is supported now none of the hypervisor
is currently available then k vm
virtualbox hyper-v and none of those
support it at all only one of those even
supports the legacy BTS mechanism but
the good news is my research partner
andreia he actually has written a module
it turns out that hyper-v is pluggable
he's going to be giving a talk at recon
just got accepted today that goes all
into the sub architecture of hyper-v and
he actually is now got this working like
last night so that we can trace his
guests from the hypervisor which is
great that was kind of the last piece to
scale this out so that will be on your
radar this year we have heard that smm
code should be traceable with this as
well which is very intriguing however do
like and some other guys says that it
might require an Intel provided
certificate so we may never get there oh
and the number for I can check that off
the list here so that works now alright
so this code github / Intel PT this talk
and all the other talks related to it
are at mofo org you can reach me on
Twitter rich in Seattle ondrea's the
other one and thank you for listening
I'll take any questions
[Applause]
any questions from the floor all maybe
questions off the floor thank you very
much richer yeah we're good okay yeah no
question thank you doing the break thank
you for so sorry about that first demo
if you I have the video up from my talk
is a cancer quest it has those demos
available and since all those codes out
there I need to write a blog post that
will show you to do it I apologize
clearly the drivers working with the
buzzer i modified it and fuck it up but
thanks again all right thank you thank
you very much reaching
for the last of our craft demonstrations
we're going to take a look at Dijkstra's
algorithm and we're going to apply
Dijkstra's algorithm to a directed
weighted graph first step we're going to
start out at a and we're going to figure
out where we can get to from a that's
better than what we've already got now
again all of these are infinite to start
out with so anything is going to be an
improvement over that so we take a look
at all the edges originating at a we
have an edge from A to B it cost 20 well
20 is better than infinity so we have a
new lowest cost path from A to B and
that's cost 20 and that's from vertex a
we have another one from A to G that's
cost 90 knots also from a and we have
another one from a to D and that's 80
and it also originates at vertex a and
all of the remainder are going to be
infinity because we have no path
standing those vertices yet in the next
step we're going to take a look at the
lowest cost path of all the ones we have
so far we have 80 90 a lot of infinities
but we have a 20 so 20 is the best we've
done so far so we're going to pick that
as our lowest cost path and we're going
to say that that one is now complete so
in our next round we're going to start
out the search at the place where that
lowest cost path has taken us which is B
now B we already know the lowest cost
path is 20 but we're going to see where
else we can get to from B that we
haven't been to before
well B only has one edge originating and
that takes us to vertex F and we haven't
been to F before so its cost is
currently infinity so the cost to get to
F via B is just 10 more than whatever
the cost was to get to B so in other
words 20 plus 10 is 30
and that's a pacifier be everything else
is unchanged so we're just going to copy
it down
in the next round we're going to take a
look at all of the pads we have so far
excluding the one that we've already
picked and we're going to find the
lowest-cost path well in this case it's
the newest one that we've added which is
32 F so f is going to be our starting
point for the next round now we have two
edges originating from f1 which takes us
from F to C at a cost of 10 now that's
10 plus the cost we have already of
getting to F 30 so 30 plus 10 is 40 to
get C 40 is better than infinity so we
have a path to C cost of 40 and it comes
from F we also have an edge from F to D
now the cost of that edge is 40 now 40
plus the cost of a 2 B 2 F is a total of
30 plus 40 70 now our path currently 2 D
is cost 80 70 is an improvement so we'll
take 70 instead and that's via F and
nothing else changes so 20 from a still
no way to get to e 30 from b 90 from a
and still no path to H either in the
next round we're going to pick the
lowest cost path of all the ones we
haven't completed yet and that's this
one over here so our path vertex C at
cost of 40 so C is going to be our
starting point for the next round
now there's several edges originating at
sea one takes us back to F it cost 50
now that would give us a total cost of
well 42 C plus 50 more is a total of 90
now 90 is not better than 30 which is of
course what we'd expect because we've
already found the lowest cost half but
we do have one from C to H and that's in
addition to the cost of getting to see
in the first place which was 40 so 40
plus 20 is 60 60 is a big improvement
over infinity so we'll take that one
pass to H cost of 60 coming from C we
also have an edge from C to D at a cost
of 10 now 10 plus the cost to get to sea
of 40 is a total of 50 which gives us a
path from A to B - f - C - D of cost 50
which is less than the cost of the path
we have so far so we have another
improvement 50 to get to D via C instead
and that's the only change so everything
else gets copied down
and that's still the best path to be and
that's still the best past path to see
and that's still the best path to F but
if we of what we've got left this path
to D is now the lowest cost path the
week so we finally settled on path to D
that's going to be the best that we can
get so that's at a cost of 50 so now
let's take a look at where we can get to
from vertex D from vertex D you get to
vertex G at a cost of well 50 to get to
D in the first place plus 20 from D to G
grand total of 70 70 to get to G well
that's an improvement over the direct
route from A to G which was 90 so 70 is
better than 90 so we pick 70 instead and
that's via D but that's the only new
path we have that's the only edge we
have originating into D so everything
else just gets copied down once again
and we're already done with this one and
this one and this one this one so now
our next lowest cost path is this one
2h at a cost of 60 so we're going to
pick that for the next round and we're
going to start exploring paths starting
from vertex H now vertex H is very
interesting because there is no edges
originating there so there's nothing
more we can do all we're going to do is
say that everything stays the same as
was before by copying everything down
and all the finished paths are still
finished kind of the remaining
unfinished paths the lowest-cost one is
this one over here it costs 70 so we're
going to mark that one is finished and
we're going to add that vertex G and
we're going to take a look at all the
edges starting from G now there's only
one edge originating a G that takes us
back to a at a cost to 20 grand total of
90 to do a round-trip back to a but we
weren't trying to do a round-trip in the
first place so that adds no new
information everything just gets copied
down
all of these are complete which leaves
us with one last value which is e has a
value of infinity now in this case value
of infinity tells us that there's no
path to he at all and in fact if we take
a look at the vertex E we can see of
course if there are no edges leading
into E which means that there is not
going to be any way of getting there and
having the value infinity left over as
our result shows us that there is in
fact no path to e so we can mark it is
done that's the best path we can get
none at all
and now our Dijkstra's algorithm finding
the lowest cost paths from a to all the
other vertices in a graph is complete
this video introduces you to the basic
concepts behind graph theory I will not
focus on the formal definition of a
graph that will come later instead I'll
emphasize the various applications of
the subject
Alfred Whitehead a mathematician and
philosopher once said the whole of
mathematics consists in the organization
of a series of age to the imagination in
the process of reasoning for example a
detective when solving a crime will post
various facts and a board and visually
connect the ideas concepts and people
via string in this spirit if a difficult
problem involves a discrete collection
of objects it's natural to sketch these
objects and draw lines between them to
indicate a relationship a graph can help
us represent relationships between
discrete objects but we do not have
enough mathematical knowledge to provide
a solid definition for the word graph to
emphasize this point please notice that
the following terms are not in a blue
box this is not the real definition that
will come later for now think of a graph
informally as a diagram of dots called
vertices connected by lines or curves
called edges the edges may have an arrow
if so the graph is called directed
otherwise it is called undirected here
is an undirected graph here is a
directed graph notice the arrows a few
quick notes about graphs two drawings
could represent the same graph an edge
drawn between two vertices typically
represents a relationship between
between the vertices so the position of
the vertices on the page doesn't matter
by coloring the vertices you see that
these diagrams could represent the same
graph also the edges cannot intersect to
make a new graph these edges are
different from traditional lines in
geometry in particular
their length their curviness is
immaterial the only thing that matters
for edges is what vertices they connect
here's an example of a graph the
vertices correspond to subway stations
and the edges describe which stations
are connected by the trolleys some
puzzles can be solved by graphs suppose
there is a river on one side the river
there are two foxes two chickens and a
boat our goal is to get all animals
across the river alive while following
these rules first the boat must be
propelled by an animal and can carry at
most two animals should the Foxes ever
outnumber the chickens on banks on
either side of the river the Foxes
immediately gobbled down the chickens
that's bad an arrangement of symbols F F
C CB and a line will represent the
current state of the puzzle each of my
vertices will represent a possible state
of the puzzle each F represents a fox
sees our pathetic ins the line
represents the river and separates the
left and right bank
finally the B represents a boat for
example if vertex contains FCB
the line F C then that means the foxes
and chickens are divided by the river
and the boat is on the left bank my
edges will connect to vertices if it is
possible for the game to be in one state
and then the animals move from one bank
to the other via the boat and therefore
reach a new state of the game when our
puzzle begins all animals are on the
left bank with the boat either one or
two animals take the boat to the right
bank if one chicken takes the dreadful
journey he's safe but it leaves his
buddy behind for lunch for the two foxes
that's not a good result the four
animals could agree to send one box to
chickens
Fox and a chicken or two foxes the cross
to the right bank in any of these cases
no chickens are chopped up and
deep-fried this is definitely an
improvement consider the case where two
foxes took the boat to the right bank
there are two animals still left behind
in the left bank so either one or both
foxes must take a boat back to get them
but taking both foxes back will return
us to the original state of the puzzle
and as that does not progress the puzzle
let's ignore that so the only other
option is to send one Fox back with the
boat to the left bank this results in a
new state of the game and as a benefit
no chickens meet their maker now
consider the case where the river
separates the chickens and the Foxes and
a boat is on the right bank once again
there are animals in the left bank
waiting the rescue so someone must go
back and take a boat as before both
animals taking the boat back just
returns us to a previous day of the
puzzle let's ignore that choice if the
chicken takes a solo voyage back the
puzzle has reached a state already
considered I'll draw an edge between the
corresponding vertices to represent this
relationship but if a fox goes back then
the Fox will number the poor singleton
chicken on the left bank and have at it
while this is the new state of the
puzzle is clearly a less than optimal
result now consider if two brave
chickens had crossed the river and are
now on the right bank there's only two
options either both chickens return to
the left bank or a solo chicken paddles
to his doom either way these choices
return the game to a previous state I'll
just connect the vertices to represent
these choices there's only one
possibility left among our original
choices but it's a silly one the single
Fox on the right bank has left behind
all the other animals well he must
travel back to get them and so the
puzzle has returned to a previous state
there is only one vertex whose state I
haven't completely discussed here the
foxes are separated by the river
both chickens lie shivering on the left
bank while staring at the boat now
either a fox or our chicken could make
the trip across the river but those
options are a accounted for and a fox
and a chicken could ride together on a
fateful one-way trip to the far bank but
a chicken would croak so that should be
avoided so the only option left would be
to send both chickens across this is a
new state of the puzzle and I'll connect
the corresponding vertices after that
then we could then send both a fox and a
chicken back but that would
unfortunately lead to a dead chicken we
could send a chicken across which would
lead to a new state of the game we could
send a fox across which would lead to a
new state of the particular puzzle or
once we have sent across the chicken we
could if you like send back a fox but
that will just lead to a dead chicken
but in either these two remaining cases
it seems pretty obvious what we should
do is now the boats on the left-hand
side let's just take both animals across
and now all the animals on the
right-hand side in order to discuss or
pinpoint features of a problem we often
define handy terms to grease the wheels
of the discourse the next three slides
introduces a number of these terms as
these definitions won't change later
I'll present them as a formal definition
all edges begin and end at vertices
called endpoints two distinct edges with
the same endpoints are called parallel
in the graph edge e3 and e4 are parallel
an edge with just one endpoint is called
a loop 'if I've is a loop an edge
connects its endpoints and two vertices
are connected if they are endpoints for
some edge in the graph e6 connects
vertices v5 of these
six I could also say that v2 and v3 are
connected without mentioning the edge
connecting them let G be a graph with
vertex V the degree of V written degree
of V equals the times an edge is
incident to the vertex loops counting
twice for a directed graph the in degree
of V equals the number of edges coming
into V while the out degree equals the
number of edges coming out the total
degree of G is the sum of all degrees of
all the vertices for example the degree
of v3 it is three the in degree of v3 is
to the out degree of v3 is 1 and the
degree of V 2 is 5 notice the loop
counts twice let G be a graph and let X
and y be vertices in G let's discuss
traversing the graph a path is an
alternating sequence of vertices and
edges so that each edge connects the
corresponding vertices the path begins
at the first vertex and ends at the last
we can say then the path is from the
first vertex to the last a circuit is a
path that begins where it ends a graph
is considered to be connected if there's
a path between any two vertices on the
graph a directed graph is connected if
the corresponding underlying undirected
graph is connected a graph is called
simple if it does not contain any loops
or parallel edges as in the graph you
see to the right the complete graph on n
vertices often denoted with a capital K
and a lowercase n is a simple graph but
where every single pair of vertices is
connected by an edge I've drawn for you
an example of K 5 my puzzle example may
not have driven home the usefulness of
graphs so now I'll show you a few
examples which are much closer to a
computer science majors heart
a college wants to schedule the
following courses in a few time slots as
possible physics Kampai calculus biology
psychology and chemistry the following
classes though have students in common
and cannot be placed in the same time
slots so cat Hills and computer science
calculus and biology calculus and
physics biology and computer science
biology and chemistry biology and
psychology physics in Comp Sci physics
and chemistry and psychology and
chemistry so what is the fewest number
of time slots needed to schedule all
their courses without any conflicts at
all make a graph where each vertex is a
course and connect the vertices if the
courses cannot be scheduled in the same
time slot here is one model of such a
graph now to assign a course to a time
slot I'll just color its vertex
different colors will mean different
time slots connected vertices mean that
they cannot be in the same time slot so
those vertices must have different
coloring if I can color the graph
following these rules then the Cowlitz
can schedule its courses the trick will
be to minimize the number of colors this
will correspond to the minimum number of
time slots required to schedule all the
courses let's start coloring I'll begin
by assigning calculus to one timeslot by
coloring its vertex blue that means bio
comps I in physics must have a different
time slot and therefore a different
color than blue that does not mean bio
comma and physics have to have different
colors from each other just they can't
be blue so all science physics would be
red a new time slot that means kansai
then must be a third color for our new
time slot but then chemistry I can go
back to blue because it's only adjacent
to the red time slot that also means
that biology then being adjacent only to
blue and green
I can assign thread that timeslot
finally psychology can be labeled back
at green thereby coloring the entire
graph and I can now say that I can
certainly go and assign these different
courses to three different time slots
and I can guarantee that the students
who are involved with these courses
won't ever have to worry about attending
a class at the same time as another
class this is a great example of what's
called coloring in the graph it's a very
common problem
here's another modeling problem in my
last example you saw it was useful to
color the Versys but it's also handy
they labeled the edges my puzzle problem
was one example here's another the
following table describes driving
distances along selected routes between
cities the cities are a through F I'd
like to know looking at this table can I
figure out what the shortest route is
from C to F make a graph where each
vertex is a city and connect vertices if
there is a route between them as
described in that table label the edges
with the distance traveled when taking
this route this is an example of a way
to graph the diagram here provides a
visual way to solve the problem clearly
out of all the possible routes you could
travel from C to F this one provides the
shortest distance traveled one more
example your spell checker keeps lists
of words that you don't want flag for
misspellings these words can be added
one at a time and just in no particular
order
but the list must be organized so that
searching the list is relatively easy to
do let's suppose that your spell checker
has the words Mapple pop a Peas AK zebra
and no now while graphs don't have
orientation let's think of this next one
that way let's make a top-down graph
each word will be a vertex each vertex
is connected to at most two
other verses below its these vertices
are called the left and right children
of the above parent vertex let's just
start with the very first vertex in this
case the very first word in our list
Mapple now from here the next word was
pop I place pop to the right of Mapple
as the right child of Mapple because
alphabetically it comes after Mapple now
the next word was a peas or a please
this word F Bentley comes before Mapple
so then I fall to the left of Mapple
realizing that there's no left child
there it will then become the left child
of Mapple the next word is AK well AK
alphabetically is before Mapple so I go
to the left and it's also alphabetically
before a please so it will move to the
left of a peas becoming then the left
child of it please the next word was
zebra and says I bruh is alphabetically
after Mapple I would move down to the
right since its alphabetically after pop
I would move down to the right here then
since there was no right child for pop
cyber then becomes the right child
the next word would have been no and
since alphabetically no comes after map
I would move down to the right from
Apple but it comes before pop so then
since pop didn't have a left child now
it does it has no this graph is an
example of what's called a binary tree
and the topmost vertex maple is called
its root
